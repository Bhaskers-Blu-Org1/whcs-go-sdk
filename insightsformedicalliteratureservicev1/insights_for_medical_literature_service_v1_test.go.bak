/**
 * (C) Copyright IBM Corp. 2020.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package insightsformedicalliteratureservicev1_test

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"os"
	"time"

	"github.com/IBM/go-sdk-core/v3/core"
	insightsformedicalliteratureservicev1 "github.com/IBM/whcs-go-sdk/insights-for-medical-literature"
	"github.com/go-openapi/strfmt"
	. "github.com/onsi/ginkgo"
	. "github.com/onsi/gomega"
)

var _ = Describe(`InsightsForMedicalLiteratureServiceV1`, func() {
	Describe(`Service constructor tests`, func() {
		version := "testString"
		It(`Instantiate service client`, func() {
			testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
				Authenticator: &core.NoAuthAuthenticator{},
				Version:       core.StringPtr(version),
			})
			Expect(testService).ToNot(BeNil())
			Expect(testServiceErr).To(BeNil())
		})
		It(`Instantiate service client with error: Invalid URL`, func() {
			testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
				URL:     "{{BAD_URL_STRING",
				Version: core.StringPtr(version),
			})
			Expect(testService).To(BeNil())
			Expect(testServiceErr).ToNot(BeNil())
		})
		It(`Instantiate service client with error: Invalid Auth`, func() {
			testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
				URL:     "https://insightsformedicalliteratureservicev1/api",
				Version: core.StringPtr(version),
				Authenticator: &core.BasicAuthenticator{
					Username: "",
					Password: "",
				},
			})
			Expect(testService).To(BeNil())
			Expect(testServiceErr).ToNot(BeNil())
		})
		It(`Instantiate service client with error: Validation Error`, func() {
			testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{})
			Expect(testService).To(BeNil())
			Expect(testServiceErr).ToNot(BeNil())
		})
	})
	Describe(`Service constructor tests using external config`, func() {
		version := "testString"
		Context(`Using external config, construct service client instances`, func() {
			// Map containing environment variables used in testing.
			var testEnvironment = map[string]string{
				"INSIGHTS_FOR_MEDICAL_LITERATURE_SERVICE_URL":       "https://insightsformedicalliteratureservicev1/api",
				"INSIGHTS_FOR_MEDICAL_LITERATURE_SERVICE_AUTH_TYPE": "noauth",
			}

			It(`Create service client using external config successfully`, func() {
				SetTestEnvironment(testEnvironment)
				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1UsingExternalConfig(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					Version: core.StringPtr(version),
				})
				Expect(testService).ToNot(BeNil())
				Expect(testServiceErr).To(BeNil())
				ClearTestEnvironment(testEnvironment)
			})
			It(`Create service client using external config and set url from constructor successfully`, func() {
				SetTestEnvironment(testEnvironment)
				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1UsingExternalConfig(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					URL:     "https://testService/api",
					Version: core.StringPtr(version),
				})
				Expect(testService).ToNot(BeNil())
				Expect(testServiceErr).To(BeNil())
				Expect(testService.Service.GetServiceURL()).To(Equal("https://testService/api"))
				ClearTestEnvironment(testEnvironment)
			})
			It(`Create service client using external config and set url programatically successfully`, func() {
				SetTestEnvironment(testEnvironment)
				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1UsingExternalConfig(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					Version: core.StringPtr(version),
				})
				err := testService.SetServiceURL("https://testService/api")
				Expect(err).To(BeNil())
				Expect(testService).ToNot(BeNil())
				Expect(testServiceErr).To(BeNil())
				Expect(testService.Service.GetServiceURL()).To(Equal("https://testService/api"))
				ClearTestEnvironment(testEnvironment)
			})
		})
		Context(`Using external config, construct service client instances with error: Invalid Auth`, func() {
			// Map containing environment variables used in testing.
			var testEnvironment = map[string]string{
				"INSIGHTS_FOR_MEDICAL_LITERATURE_SERVICE_URL":       "https://insightsformedicalliteratureservicev1/api",
				"INSIGHTS_FOR_MEDICAL_LITERATURE_SERVICE_AUTH_TYPE": "someOtherAuth",
			}

			SetTestEnvironment(testEnvironment)
			testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1UsingExternalConfig(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
				Version: core.StringPtr(version),
			})

			It(`Instantiate service client with error`, func() {
				Expect(testService).To(BeNil())
				Expect(testServiceErr).ToNot(BeNil())
				ClearTestEnvironment(testEnvironment)
			})
		})
		Context(`Using external config, construct service client instances with error: Invalid URL`, func() {
			// Map containing environment variables used in testing.
			var testEnvironment = map[string]string{
				"INSIGHTS_FOR_MEDICAL_LITERATURE_SERVICE_AUTH_TYPE": "NOAuth",
			}

			SetTestEnvironment(testEnvironment)
			testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1UsingExternalConfig(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
				URL:     "{{BAD_URL_STRING",
				Version: core.StringPtr(version),
			})

			It(`Instantiate service client with error`, func() {
				Expect(testService).To(BeNil())
				Expect(testServiceErr).ToNot(BeNil())
				ClearTestEnvironment(testEnvironment)
			})
		})
	})
	Describe(`GetDocuments(getDocumentsOptions *GetDocumentsOptions)`, func() {
		version := "testString"
		getDocumentsPath := "/v1/corpora/testString/documents"
		Context(`Using mock server endpoint`, func() {
			testServer := httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
				defer GinkgoRecover()

				// Verify the contents of the request
				Expect(req.URL.Path).To(Equal(getDocumentsPath))
				Expect(req.Method).To(Equal("GET"))
				Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))

				res.Header().Set("Content-type", "application/json")
				res.WriteHeader(200)
				fmt.Fprintf(res, `{"corpusName": "CorpusName", "ontologies": ["Ontologies"], "descriptiveName": "DescriptiveName", "bvt": false, "elasticsearchIndex": "ElasticsearchIndex"}`)
			}))
			It(`Invoke GetDocuments successfully`, func() {
				defer testServer.Close()

				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
					Version:       core.StringPtr(version),
				})
				Expect(testServiceErr).To(BeNil())
				Expect(testService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := testService.GetDocuments(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetDocumentsOptions model
				getDocumentsOptionsModel := new(insightsformedicalliteratureservicev1.GetDocumentsOptions)
				getDocumentsOptionsModel.Corpus = core.StringPtr("testString")

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = testService.GetDocuments(getDocumentsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())
			})
		})
	})
	Describe(`AddCorpusDocument(addCorpusDocumentOptions *AddCorpusDocumentOptions)`, func() {
		version := "testString"
		addCorpusDocumentPath := "/v1/corpora/testString/documents"
		Context(`Using mock server endpoint`, func() {
			testServer := httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
				defer GinkgoRecover()

				// Verify the contents of the request
				Expect(req.URL.Path).To(Equal(addCorpusDocumentPath))
				Expect(req.Method).To(Equal("POST"))
				Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))

				res.WriteHeader(200)
			}))
			It(`Invoke AddCorpusDocument successfully`, func() {
				defer testServer.Close()

				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
					Version:       core.StringPtr(version),
				})
				Expect(testServiceErr).To(BeNil())
				Expect(testService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := testService.AddCorpusDocument(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the AddCorpusDocumentOptions model
				addCorpusDocumentOptionsModel := new(insightsformedicalliteratureservicev1.AddCorpusDocumentOptions)
				addCorpusDocumentOptionsModel.Corpus = core.StringPtr("testString")
				addCorpusDocumentOptionsModel.Document = CreateMockMap()
				addCorpusDocumentOptionsModel.AcdURL = core.StringPtr("testString")
				addCorpusDocumentOptionsModel.ApiKey = core.StringPtr("testString")
				addCorpusDocumentOptionsModel.FlowID = core.StringPtr("testString")
				addCorpusDocumentOptionsModel.AccessToken = core.StringPtr("testString")
				addCorpusDocumentOptionsModel.OtherAnnotators = nil

				// Invoke operation with valid options model (positive test)
				response, operationErr = testService.AddCorpusDocument(addCorpusDocumentOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
		})
	})
	Describe(`GetDocumentInfo(getDocumentInfoOptions *GetDocumentInfoOptions)`, func() {
		version := "testString"
		getDocumentInfoPath := "/v1/corpora/testString/documents/testString"
		Context(`Using mock server endpoint`, func() {
			testServer := httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
				defer GinkgoRecover()

				// Verify the contents of the request
				Expect(req.URL.Path).To(Equal(getDocumentInfoPath))
				Expect(req.Method).To(Equal("GET"))
				Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))

				// TODO: Add check for verbose query parameter

				res.Header().Set("Content-type", "application/json")
				res.WriteHeader(200)
				fmt.Fprintf(res, `{}`)
			}))
			It(`Invoke GetDocumentInfo successfully`, func() {
				defer testServer.Close()

				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
					Version:       core.StringPtr(version),
				})
				Expect(testServiceErr).To(BeNil())
				Expect(testService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := testService.GetDocumentInfo(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetDocumentInfoOptions model
				getDocumentInfoOptionsModel := new(insightsformedicalliteratureservicev1.GetDocumentInfoOptions)
				getDocumentInfoOptionsModel.Corpus = core.StringPtr("testString")
				getDocumentInfoOptionsModel.DocumentID = core.StringPtr("testString")
				getDocumentInfoOptionsModel.Verbose = core.BoolPtr(true)

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = testService.GetDocumentInfo(getDocumentInfoOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())
			})
		})
	})
	Describe(`GetDocumentAnnotations(getDocumentAnnotationsOptions *GetDocumentAnnotationsOptions)`, func() {
		version := "testString"
		getDocumentAnnotationsPath := "/v1/corpora/testString/documents/testString/annotations"
		Context(`Using mock server endpoint`, func() {
			testServer := httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
				defer GinkgoRecover()

				// Verify the contents of the request
				Expect(req.URL.Path).To(Equal(getDocumentAnnotationsPath))
				Expect(req.Method).To(Equal("GET"))
				Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))

				Expect(req.URL.Query()["document_section"]).To(Equal([]string{"testString"}))

				// TODO: Add check for include_text query parameter

				res.WriteHeader(200)
			}))
			It(`Invoke GetDocumentAnnotations successfully`, func() {
				defer testServer.Close()

				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
					Version:       core.StringPtr(version),
				})
				Expect(testServiceErr).To(BeNil())
				Expect(testService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := testService.GetDocumentAnnotations(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the GetDocumentAnnotationsOptions model
				getDocumentAnnotationsOptionsModel := new(insightsformedicalliteratureservicev1.GetDocumentAnnotationsOptions)
				getDocumentAnnotationsOptionsModel.Corpus = core.StringPtr("testString")
				getDocumentAnnotationsOptionsModel.DocumentID = core.StringPtr("testString")
				getDocumentAnnotationsOptionsModel.DocumentSection = core.StringPtr("testString")
				getDocumentAnnotationsOptionsModel.Cuis = []string{"testString"}
				getDocumentAnnotationsOptionsModel.IncludeText = core.BoolPtr(true)

				// Invoke operation with valid options model (positive test)
				response, operationErr = testService.GetDocumentAnnotations(getDocumentAnnotationsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
		})
	})
	Describe(`GetDocumentCategories(getDocumentCategoriesOptions *GetDocumentCategoriesOptions)`, func() {
		version := "testString"
		getDocumentCategoriesPath := "/v1/corpora/testString/documents/testString/categories"
		Context(`Using mock server endpoint`, func() {
			testServer := httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
				defer GinkgoRecover()

				// Verify the contents of the request
				Expect(req.URL.Path).To(Equal(getDocumentCategoriesPath))
				Expect(req.Method).To(Equal("GET"))
				Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))

				Expect(req.URL.Query()["highlight_tag_begin"]).To(Equal([]string{"testString"}))

				Expect(req.URL.Query()["highlight_tag_end"]).To(Equal([]string{"testString"}))

				Expect(req.URL.Query()["category"]).To(Equal([]string{"disorders"}))

				// TODO: Add check for only_negated_concepts query parameter

				Expect(req.URL.Query()["_fields"]).To(Equal([]string{"testString"}))

				Expect(req.URL.Query()["_limit"]).To(Equal([]string{fmt.Sprint(int64(38))}))

				res.Header().Set("Content-type", "application/json")
				res.WriteHeader(200)
				fmt.Fprintf(res, `{"modelLicense": "ModelLicense", "highlightedTitle": "testString", "highlightedAbstract": "testString", "highlightedBody": "testString", "highlightedSections": {"mapKey": "testString"}, "passages": {"mapKey": {"mapKey": {"id": "ID", "negated": false, "sentences": [{"documentSection": "DocumentSection", "text": {}, "begin": 5, "end": 3, "timestamp": 9}]}}}, "annotations": {"mapKey": {"uniqueId": 8, "stickyIds": [9], "ontology": "Ontology", "section": "Section", "preferredName": "PreferredName", "cui": "Cui", "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "type": "Type", "negated": false, "hypothetical": true, "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "begin": 5, "end": 3, "score": 5, "timestamp": 9, "features": {"mapKey": "Inner"}, "hits": 4}}}`)
			}))
			It(`Invoke GetDocumentCategories successfully`, func() {
				defer testServer.Close()

				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
					Version:       core.StringPtr(version),
				})
				Expect(testServiceErr).To(BeNil())
				Expect(testService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := testService.GetDocumentCategories(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetDocumentCategoriesOptions model
				getDocumentCategoriesOptionsModel := new(insightsformedicalliteratureservicev1.GetDocumentCategoriesOptions)
				getDocumentCategoriesOptionsModel.Corpus = core.StringPtr("testString")
				getDocumentCategoriesOptionsModel.DocumentID = core.StringPtr("testString")
				getDocumentCategoriesOptionsModel.HighlightTagBegin = core.StringPtr("testString")
				getDocumentCategoriesOptionsModel.HighlightTagEnd = core.StringPtr("testString")
				getDocumentCategoriesOptionsModel.Types = []string{"testString"}
				getDocumentCategoriesOptionsModel.Category = core.StringPtr("disorders")
				getDocumentCategoriesOptionsModel.OnlyNegatedConcepts = core.BoolPtr(true)
				getDocumentCategoriesOptionsModel.Fields = core.StringPtr("testString")
				getDocumentCategoriesOptionsModel.Limit = core.Int64Ptr(int64(38))

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = testService.GetDocumentCategories(getDocumentCategoriesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())
			})
		})
	})
	Describe(`GetDocumentMultipleCategories(getDocumentMultipleCategoriesOptions *GetDocumentMultipleCategoriesOptions)`, func() {
		version := "testString"
		getDocumentMultipleCategoriesPath := "/v1/corpora/testString/documents/testString/categories"
		Context(`Using mock server endpoint`, func() {
			testServer := httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
				defer GinkgoRecover()

				// Verify the contents of the request
				Expect(req.URL.Path).To(Equal(getDocumentMultipleCategoriesPath))
				Expect(req.Method).To(Equal("POST"))
				Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))

				Expect(req.URL.Query()["highlight_tag_begin"]).To(Equal([]string{"testString"}))

				Expect(req.URL.Query()["highlight_tag_end"]).To(Equal([]string{"testString"}))

				Expect(req.URL.Query()["_fields"]).To(Equal([]string{"testString"}))

				Expect(req.URL.Query()["_limit"]).To(Equal([]string{fmt.Sprint(int64(38))}))

				res.Header().Set("Content-type", "application/json")
				res.WriteHeader(200)
				fmt.Fprintf(res, `{"modelLicense": "ModelLicense", "highlightedTitle": "testString", "highlightedAbstract": "testString", "highlightedBody": "testString", "highlightedSections": {"mapKey": "testString"}, "passages": {"mapKey": {"mapKey": {"id": "ID", "negated": false, "sentences": [{"documentSection": "DocumentSection", "text": {}, "begin": 5, "end": 3, "timestamp": 9}]}}}, "annotations": {"mapKey": {"uniqueId": 8, "stickyIds": [9], "ontology": "Ontology", "section": "Section", "preferredName": "PreferredName", "cui": "Cui", "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "type": "Type", "negated": false, "hypothetical": true, "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "begin": 5, "end": 3, "score": 5, "timestamp": 9, "features": {"mapKey": "Inner"}, "hits": 4}}}`)
			}))
			It(`Invoke GetDocumentMultipleCategories successfully`, func() {
				defer testServer.Close()

				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
					Version:       core.StringPtr(version),
				})
				Expect(testServiceErr).To(BeNil())
				Expect(testService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := testService.GetDocumentMultipleCategories(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the AnnotationModel model
				annotationModelModel := new(insightsformedicalliteratureservicev1.AnnotationModel)
				annotationModelModel.UniqueID = core.Int64Ptr(int64(38))
				annotationModelModel.StickyIds = []int64{int64(38)}
				annotationModelModel.Ontology = core.StringPtr("testString")
				annotationModelModel.Section = core.StringPtr("testString")
				annotationModelModel.PreferredName = core.StringPtr("testString")
				annotationModelModel.Cui = core.StringPtr("testString")
				annotationModelModel.AttributeID = core.StringPtr("testString")
				annotationModelModel.Qualifiers = []string{"testString"}
				annotationModelModel.Type = core.StringPtr("testString")
				annotationModelModel.Negated = core.BoolPtr(true)
				annotationModelModel.Hypothetical = core.BoolPtr(true)
				annotationModelModel.Unit = core.StringPtr("testString")
				annotationModelModel.MinValue = core.StringPtr("testString")
				annotationModelModel.MaxValue = core.StringPtr("testString")
				annotationModelModel.Operator = core.StringPtr("testString")
				annotationModelModel.NluSourceType = core.StringPtr("testString")
				annotationModelModel.NluRelation = core.StringPtr("testString")
				annotationModelModel.NluTargetType = core.StringPtr("testString")
				annotationModelModel.NluEntityIndex = core.StringPtr("testString")
				annotationModelModel.NluMentionIndex = core.StringPtr("testString")
				annotationModelModel.NluRelationID = core.StringPtr("testString")
				annotationModelModel.NluSide = core.StringPtr("testString")
				annotationModelModel.Begin = core.Int64Ptr(int64(38))
				annotationModelModel.End = core.Int64Ptr(int64(38))
				annotationModelModel.Score = core.Float32Ptr(36.0)
				annotationModelModel.Timestamp = core.Int64Ptr(int64(26))
				annotationModelModel.Features = make(map[string]string)
				annotationModelModel.Hits = core.Int64Ptr(int64(38))

				// Construct an instance of the StringBuilder model
//				stringBuilderModel := new(insightsformedicalliteratureservicev1.StringBuilder)

				// Construct an instance of the GetDocumentMultipleCategoriesOptions model
				category := insightsformedicalliteratureservicev1.Category{}
				category.Name = core.StringPtr("disorders")
				category.Category = core.StringPtr("disorders")
				categories := []insightsformedicalliteratureservicev1.Category{category}
				getDocumentMultipleCategoriesOptionsModel := new(insightsformedicalliteratureservicev1.GetDocumentMultipleCategoriesOptions)
				getDocumentMultipleCategoriesOptionsModel.Corpus = core.StringPtr("testString")
				getDocumentMultipleCategoriesOptionsModel.DocumentID = core.StringPtr("testString")
				getDocumentMultipleCategoriesOptionsModel.Categories = categories
				//getDocumentMultipleCategoriesOptionsModel.ModelLicense = core.StringPtr("testString")
				//getDocumentMultipleCategoriesOptionsModel.HighlightedTitle = stringBuilderModel
				//getDocumentMultipleCategoriesOptionsModel.HighlightedAbstract = stringBuilderModel
				//getDocumentMultipleCategoriesOptionsModel.HighlightedBody = stringBuilderModel
				//				getDocumentMultipleCategoriesOptionsModel.HighlightedSections = CreateMockMap()
				//				getDocumentMultipleCategoriesOptionsModel.Passages = CreateMockMap()
				//				getDocumentMultipleCategoriesOptionsModel.Annotations = CreateMockMap()
				getDocumentMultipleCategoriesOptionsModel.HighlightTagBegin = core.StringPtr("testString")
				getDocumentMultipleCategoriesOptionsModel.HighlightTagEnd = core.StringPtr("testString")
				getDocumentMultipleCategoriesOptionsModel.Fields = core.StringPtr("testString")
				getDocumentMultipleCategoriesOptionsModel.Limit = core.Int64Ptr(int64(38))

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = testService.GetDocumentMultipleCategories(getDocumentMultipleCategoriesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())
			})
		})
	})
	Describe(`GetSearchMatches(getSearchMatchesOptions *GetSearchMatchesOptions)`, func() {
		version := "testString"
		getSearchMatchesPath := "/v1/corpora/testString/documents/testString/search_matches"
		Context(`Using mock server endpoint`, func() {
			testServer := httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
				defer GinkgoRecover()

				// Verify the contents of the request
				Expect(req.URL.Path).To(Equal(getSearchMatchesPath))
				Expect(req.Method).To(Equal("GET"))
				Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))

				// TODO: Add check for min_score query parameter

				Expect(req.URL.Query()["_limit"]).To(Equal([]string{fmt.Sprint(int64(38))}))

				Expect(req.URL.Query()["search_tag_begin"]).To(Equal([]string{"testString"}))

				Expect(req.URL.Query()["search_tag_end"]).To(Equal([]string{"testString"}))

				Expect(req.URL.Query()["related_tag_begin"]).To(Equal([]string{"testString"}))

				Expect(req.URL.Query()["related_tag_end"]).To(Equal([]string{"testString"}))

				Expect(req.URL.Query()["_fields"]).To(Equal([]string{"testString"}))

				res.Header().Set("Content-type", "application/json")
				res.WriteHeader(200)
				fmt.Fprintf(res, `{"externalId": "ExternalID", "documentId": "DocumentID", "parentDocumentId": "ParentDocumentID", "publicationName": "PublicationName", "publicationDate": "PublicationDate", "publicationURL": "PublicationURL", "authors": ["Authors"], "title": "Title", "medlineLicense": "MedlineLicense", "hrefPubMed": "HrefPubMed", "hrefPmc": "HrefPmc", "hrefDoi": "HrefDoi", "pdfUrl": "PdfURL", "referenceUrl": "ReferenceURL", "highlightedTitle": {}, "highlightedAbstract": {}, "highlightedBody": {}, "highlightedSections": {"mapKey": {}}, "passages": {"mapKey": {"mapKey": {"negated": false, "score": 5, "sentences": [{"documentSection": "DocumentSection", "text": {}, "begin": 5, "end": 3, "timestamp": 9}], "id": "ID"}}}, "annotations": {"mapKey": {"uniqueId": 8, "stickyIds": [9], "ontology": "Ontology", "section": "Section", "preferredName": "PreferredName", "cui": "Cui", "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "type": "Type", "negated": false, "hypothetical": true, "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "begin": 5, "end": 3, "score": 5, "timestamp": 9, "features": {"mapKey": "Inner"}, "hits": 4}}}`)
			}))
			It(`Invoke GetSearchMatches successfully`, func() {
				defer testServer.Close()

				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
					Version:       core.StringPtr(version),
				})
				Expect(testServiceErr).To(BeNil())
				Expect(testService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := testService.GetSearchMatches(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetSearchMatchesOptions model
				getSearchMatchesOptionsModel := new(insightsformedicalliteratureservicev1.GetSearchMatchesOptions)
				getSearchMatchesOptionsModel.Corpus = core.StringPtr("testString")
				getSearchMatchesOptionsModel.DocumentID = core.StringPtr("testString")
				getSearchMatchesOptionsModel.MinScore = core.Float32Ptr(36.0)
				getSearchMatchesOptionsModel.Cuis = []string{"testString"}
				getSearchMatchesOptionsModel.Text = []string{"testString"}
				getSearchMatchesOptionsModel.Types = []string{"testString"}
				getSearchMatchesOptionsModel.Attributes = []string{"testString"}
				getSearchMatchesOptionsModel.Values = []string{"testString"}
				getSearchMatchesOptionsModel.NluRelations = []string{"testString"}
				getSearchMatchesOptionsModel.Limit = core.Int64Ptr(int64(38))
				getSearchMatchesOptionsModel.SearchTagBegin = core.StringPtr("testString")
				getSearchMatchesOptionsModel.SearchTagEnd = core.StringPtr("testString")
				getSearchMatchesOptionsModel.RelatedTagBegin = core.StringPtr("testString")
				getSearchMatchesOptionsModel.RelatedTagEnd = core.StringPtr("testString")
				getSearchMatchesOptionsModel.Fields = core.StringPtr("testString")

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = testService.GetSearchMatches(getSearchMatchesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())
			})
		})
	})
	Describe(`Service constructor tests`, func() {
		version := "testString"
		It(`Instantiate service client`, func() {
			testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
				Authenticator: &core.NoAuthAuthenticator{},
				Version:       core.StringPtr(version),
			})
			Expect(testService).ToNot(BeNil())
			Expect(testServiceErr).To(BeNil())
		})
		It(`Instantiate service client with error: Invalid URL`, func() {
			testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
				URL:     "{{BAD_URL_STRING",
				Version: core.StringPtr(version),
			})
			Expect(testService).To(BeNil())
			Expect(testServiceErr).ToNot(BeNil())
		})
		It(`Instantiate service client with error: Invalid Auth`, func() {
			testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
				URL:     "https://insightsformedicalliteratureservicev1/api",
				Version: core.StringPtr(version),
				Authenticator: &core.BasicAuthenticator{
					Username: "",
					Password: "",
				},
			})
			Expect(testService).To(BeNil())
			Expect(testServiceErr).ToNot(BeNil())
		})
		It(`Instantiate service client with error: Validation Error`, func() {
			testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{})
			Expect(testService).To(BeNil())
			Expect(testServiceErr).ToNot(BeNil())
		})
	})
	Describe(`Service constructor tests using external config`, func() {
		version := "testString"
		Context(`Using external config, construct service client instances`, func() {
			// Map containing environment variables used in testing.
			var testEnvironment = map[string]string{
				"INSIGHTS_FOR_MEDICAL_LITERATURE_SERVICE_URL":       "https://insightsformedicalliteratureservicev1/api",
				"INSIGHTS_FOR_MEDICAL_LITERATURE_SERVICE_AUTH_TYPE": "noauth",
			}

			It(`Create service client using external config successfully`, func() {
				SetTestEnvironment(testEnvironment)
				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1UsingExternalConfig(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					Version: core.StringPtr(version),
				})
				Expect(testService).ToNot(BeNil())
				Expect(testServiceErr).To(BeNil())
				ClearTestEnvironment(testEnvironment)
			})
			It(`Create service client using external config and set url from constructor successfully`, func() {
				SetTestEnvironment(testEnvironment)
				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1UsingExternalConfig(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					URL:     "https://testService/api",
					Version: core.StringPtr(version),
				})
				Expect(testService).ToNot(BeNil())
				Expect(testServiceErr).To(BeNil())
				Expect(testService.Service.GetServiceURL()).To(Equal("https://testService/api"))
				ClearTestEnvironment(testEnvironment)
			})
			It(`Create service client using external config and set url programatically successfully`, func() {
				SetTestEnvironment(testEnvironment)
				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1UsingExternalConfig(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					Version: core.StringPtr(version),
				})
				err := testService.SetServiceURL("https://testService/api")
				Expect(err).To(BeNil())
				Expect(testService).ToNot(BeNil())
				Expect(testServiceErr).To(BeNil())
				Expect(testService.Service.GetServiceURL()).To(Equal("https://testService/api"))
				ClearTestEnvironment(testEnvironment)
			})
		})
		Context(`Using external config, construct service client instances with error: Invalid Auth`, func() {
			// Map containing environment variables used in testing.
			var testEnvironment = map[string]string{
				"INSIGHTS_FOR_MEDICAL_LITERATURE_SERVICE_URL":       "https://insightsformedicalliteratureservicev1/api",
				"INSIGHTS_FOR_MEDICAL_LITERATURE_SERVICE_AUTH_TYPE": "someOtherAuth",
			}

			SetTestEnvironment(testEnvironment)
			testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1UsingExternalConfig(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
				Version: core.StringPtr(version),
			})

			It(`Instantiate service client with error`, func() {
				Expect(testService).To(BeNil())
				Expect(testServiceErr).ToNot(BeNil())
				ClearTestEnvironment(testEnvironment)
			})
		})
		Context(`Using external config, construct service client instances with error: Invalid URL`, func() {
			// Map containing environment variables used in testing.
			var testEnvironment = map[string]string{
				"INSIGHTS_FOR_MEDICAL_LITERATURE_SERVICE_AUTH_TYPE": "NOAuth",
			}

			SetTestEnvironment(testEnvironment)
			testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1UsingExternalConfig(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
				URL:     "{{BAD_URL_STRING",
				Version: core.StringPtr(version),
			})

			It(`Instantiate service client with error`, func() {
				Expect(testService).To(BeNil())
				Expect(testServiceErr).ToNot(BeNil())
				ClearTestEnvironment(testEnvironment)
			})
		})
	})
	Describe(`GetCorporaConfig(getCorporaConfigOptions *GetCorporaConfigOptions)`, func() {
		version := "testString"
		getCorporaConfigPath := "/v1/corpora"
		Context(`Using mock server endpoint`, func() {
			testServer := httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
				defer GinkgoRecover()

				// Verify the contents of the request
				Expect(req.URL.Path).To(Equal(getCorporaConfigPath))
				Expect(req.Method).To(Equal("GET"))
				Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))

				// TODO: Add check for verbose query parameter

				res.Header().Set("Content-type", "application/json")
				res.WriteHeader(200)
				fmt.Fprintf(res, `{"corpora": [{"corpusName": "CorpusName", "ontologies": ["Ontologies"], "descriptiveName": "DescriptiveName", "bvt": false, "elasticsearchIndex": "ElasticsearchIndex"}]}`)
			}))
			It(`Invoke GetCorporaConfig successfully`, func() {
				defer testServer.Close()

				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
					Version:       core.StringPtr(version),
				})
				Expect(testServiceErr).To(BeNil())
				Expect(testService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := testService.GetCorporaConfig(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetCorporaConfigOptions model
				getCorporaConfigOptionsModel := new(insightsformedicalliteratureservicev1.GetCorporaConfigOptions)
				getCorporaConfigOptionsModel.Verbose = core.BoolPtr(true)

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = testService.GetCorporaConfig(getCorporaConfigOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())
			})
		})
	})
	Describe(`SetCorpusSchema(setCorpusSchemaOptions *SetCorpusSchemaOptions)`, func() {
		version := "testString"
		setCorpusSchemaPath := "/v1/corpora"
		Context(`Using mock server endpoint`, func() {
			testServer := httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
				defer GinkgoRecover()

				// Verify the contents of the request
				Expect(req.URL.Path).To(Equal(setCorpusSchemaPath))
				Expect(req.Method).To(Equal("POST"))
				Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))

				res.Header().Set("Content-type", "application/json")
				res.WriteHeader(200)
				fmt.Fprintf(res, `{"corpora": [{"corpusName": "CorpusName", "ontologies": ["Ontologies"], "descriptiveName": "DescriptiveName", "bvt": false, "elasticsearchIndex": "ElasticsearchIndex"}]}`)
			}))
			It(`Invoke SetCorpusSchema successfully`, func() {
				defer testServer.Close()

				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
					Version:       core.StringPtr(version),
				})
				Expect(testServiceErr).To(BeNil())
				Expect(testService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := testService.SetCorpusSchema(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the SetCorpusSchemaOptions model
				setCorpusSchemaOptionsModel := new(insightsformedicalliteratureservicev1.SetCorpusSchemaOptions)
				//				setCorpusSchemaOptionsModel.EnrichmentTargets = []interface{}{*(CreateMockMap())}
				//				setCorpusSchemaOptionsModel.MetadataFields = []interface{}{*(CreateMockMap())}
				setCorpusSchemaOptionsModel.CorpusName = core.StringPtr("testString")
				setCorpusSchemaOptionsModel.References = CreateMockMap()

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = testService.SetCorpusSchema(setCorpusSchemaOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())
			})
		})
	})
	Describe(`DeleteCorpusSchema(deleteCorpusSchemaOptions *DeleteCorpusSchemaOptions)`, func() {
		version := "testString"
		deleteCorpusSchemaPath := "/v1/corpora"
		Context(`Using mock server endpoint`, func() {
			testServer := httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
				defer GinkgoRecover()

				// Verify the contents of the request
				Expect(req.URL.Path).To(Equal(deleteCorpusSchemaPath))
				Expect(req.Method).To(Equal("DELETE"))
				Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))

				Expect(req.URL.Query()["instance"]).To(Equal([]string{"testString"}))

				res.Header().Set("Content-type", "application/json")
				res.WriteHeader(200)
				fmt.Fprintf(res, `{"corpora": [{"corpusName": "CorpusName", "ontologies": ["Ontologies"], "descriptiveName": "DescriptiveName", "bvt": false, "elasticsearchIndex": "ElasticsearchIndex"}]}`)
			}))
			It(`Invoke DeleteCorpusSchema successfully`, func() {
				defer testServer.Close()

				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
					Version:       core.StringPtr(version),
				})
				Expect(testServiceErr).To(BeNil())
				Expect(testService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := testService.DeleteCorpusSchema(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the DeleteCorpusSchemaOptions model
				deleteCorpusSchemaOptionsModel := new(insightsformedicalliteratureservicev1.DeleteCorpusSchemaOptions)
				deleteCorpusSchemaOptionsModel.Instance = core.StringPtr("testString")

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = testService.DeleteCorpusSchema(deleteCorpusSchemaOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())
			})
		})
	})
	Describe(`SetCorpusConfig(setCorpusConfigOptions *SetCorpusConfigOptions)`, func() {
		version := "testString"
		setCorpusConfigPath := "/v1/corpora/configure"
		Context(`Using mock server endpoint`, func() {
			testServer := httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
				defer GinkgoRecover()

				// Verify the contents of the request
				Expect(req.URL.Path).To(Equal(setCorpusConfigPath))
				Expect(req.Method).To(Equal("POST"))
				Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))

				res.Header().Set("Content-type", "application/json")
				res.WriteHeader(200)
				fmt.Fprintf(res, `{"corpora": [{"corpusName": "CorpusName", "ontologies": ["Ontologies"], "descriptiveName": "DescriptiveName", "bvt": false, "elasticsearchIndex": "ElasticsearchIndex"}]}`)
			}))
			It(`Invoke SetCorpusConfig successfully`, func() {
				defer testServer.Close()

				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
					Version:       core.StringPtr(version),
				})
				Expect(testServiceErr).To(BeNil())
				Expect(testService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := testService.SetCorpusConfig(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the SetCorpusConfigOptions model
				setCorpusConfigOptionsModel := new(insightsformedicalliteratureservicev1.SetCorpusConfigOptions)
				setCorpusConfigOptionsModel.UserName = core.StringPtr("testString")
				setCorpusConfigOptionsModel.Password = core.StringPtr("testString")
				setCorpusConfigOptionsModel.CorpusURI = core.StringPtr("testString")

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = testService.SetCorpusConfig(setCorpusConfigOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())
			})
		})
	})
	Describe(`MonitorCorpus(monitorCorpusOptions *MonitorCorpusOptions)`, func() {
		version := "testString"
		monitorCorpusPath := "/v1/corpora/monitor"
		Context(`Using mock server endpoint`, func() {
			testServer := httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
				defer GinkgoRecover()

				// Verify the contents of the request
				Expect(req.URL.Path).To(Equal(monitorCorpusPath))
				Expect(req.Method).To(Equal("PUT"))
				Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))

				Expect(req.URL.Query()["apikey"]).To(Equal([]string{"testString"}))

				res.WriteHeader(200)
			}))
			It(`Invoke MonitorCorpus successfully`, func() {
				defer testServer.Close()

				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
					Version:       core.StringPtr(version),
				})
				Expect(testServiceErr).To(BeNil())
				Expect(testService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := testService.MonitorCorpus(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the MonitorCorpusOptions model
				monitorCorpusOptionsModel := new(insightsformedicalliteratureservicev1.MonitorCorpusOptions)
				monitorCorpusOptionsModel.Apikey = core.StringPtr("testString")

				// Invoke operation with valid options model (positive test)
				response, operationErr = testService.MonitorCorpus(monitorCorpusOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
		})
	})
	Describe(`EnableCorpusSearchTracking(enableCorpusSearchTrackingOptions *EnableCorpusSearchTrackingOptions)`, func() {
		version := "testString"
		enableCorpusSearchTrackingPath := "/v1/corpora/tracking"
		Context(`Using mock server endpoint`, func() {
			testServer := httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
				defer GinkgoRecover()

				// Verify the contents of the request
				Expect(req.URL.Path).To(Equal(enableCorpusSearchTrackingPath))
				Expect(req.Method).To(Equal("PUT"))
				Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))

				// TODO: Add check for enable_tracking query parameter

				res.WriteHeader(200)
			}))
			It(`Invoke EnableCorpusSearchTracking successfully`, func() {
				defer testServer.Close()

				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
					Version:       core.StringPtr(version),
				})
				Expect(testServiceErr).To(BeNil())
				Expect(testService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := testService.EnableCorpusSearchTracking(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the EnableCorpusSearchTrackingOptions model
				enableCorpusSearchTrackingOptionsModel := new(insightsformedicalliteratureservicev1.EnableCorpusSearchTrackingOptions)
				enableCorpusSearchTrackingOptionsModel.EnableTracking = core.BoolPtr(true)

				// Invoke operation with valid options model (positive test)
				response, operationErr = testService.EnableCorpusSearchTracking(enableCorpusSearchTrackingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
		})
	})
	Describe(`GetCorpusConfig(getCorpusConfigOptions *GetCorpusConfigOptions)`, func() {
		version := "testString"
		getCorpusConfigPath := "/v1/corpora/testString"
		Context(`Using mock server endpoint`, func() {
			testServer := httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
				defer GinkgoRecover()

				// Verify the contents of the request
				Expect(req.URL.Path).To(Equal(getCorpusConfigPath))
				Expect(req.Method).To(Equal("GET"))
				Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))

				// TODO: Add check for verbose query parameter

				res.Header().Set("Content-type", "application/json")
				res.WriteHeader(200)
				fmt.Fprintf(res, `{"corpora": [{"corpusName": "CorpusName", "ontologies": ["Ontologies"], "descriptiveName": "DescriptiveName", "bvt": false, "elasticsearchIndex": "ElasticsearchIndex"}]}`)
			}))
			It(`Invoke GetCorpusConfig successfully`, func() {
				defer testServer.Close()

				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
					Version:       core.StringPtr(version),
				})
				Expect(testServiceErr).To(BeNil())
				Expect(testService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := testService.GetCorpusConfig(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetCorpusConfigOptions model
				getCorpusConfigOptionsModel := new(insightsformedicalliteratureservicev1.GetCorpusConfigOptions)
				getCorpusConfigOptionsModel.Corpus = core.StringPtr("testString")
				getCorpusConfigOptionsModel.Verbose = core.BoolPtr(true)

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = testService.GetCorpusConfig(getCorpusConfigOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())
			})
		})
	})
	Describe(`Service constructor tests using external config`, func() {
		version := "testString"
		Context(`Using external config, construct service client instances`, func() {
			// Map containing environment variables used in testing.
			var testEnvironment = map[string]string{
				"INSIGHTS_FOR_MEDICAL_LITERATURE_SERVICE_URL":       "https://insightsformedicalliteratureservicev1/api",
				"INSIGHTS_FOR_MEDICAL_LITERATURE_SERVICE_AUTH_TYPE": "noauth",
			}

			It(`Create service client using external config successfully`, func() {
				SetTestEnvironment(testEnvironment)
				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1UsingExternalConfig(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					Version: core.StringPtr(version),
				})
				Expect(testService).ToNot(BeNil())
				Expect(testServiceErr).To(BeNil())
				ClearTestEnvironment(testEnvironment)
			})
			It(`Create service client using external config and set url from constructor successfully`, func() {
				SetTestEnvironment(testEnvironment)
				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1UsingExternalConfig(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					URL:     "https://testService/api",
					Version: core.StringPtr(version),
				})
				Expect(testService).ToNot(BeNil())
				Expect(testServiceErr).To(BeNil())
				Expect(testService.Service.GetServiceURL()).To(Equal("https://testService/api"))
				ClearTestEnvironment(testEnvironment)
			})
			It(`Create service client using external config and set url programatically successfully`, func() {
				SetTestEnvironment(testEnvironment)
				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1UsingExternalConfig(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					Version: core.StringPtr(version),
				})
				err := testService.SetServiceURL("https://testService/api")
				Expect(err).To(BeNil())
				Expect(testService).ToNot(BeNil())
				Expect(testServiceErr).To(BeNil())
				Expect(testService.Service.GetServiceURL()).To(Equal("https://testService/api"))
				ClearTestEnvironment(testEnvironment)
			})
		})
		Context(`Using external config, construct service client instances with error: Invalid Auth`, func() {
			// Map containing environment variables used in testing.
			var testEnvironment = map[string]string{
				"INSIGHTS_FOR_MEDICAL_LITERATURE_SERVICE_URL":       "https://insightsformedicalliteratureservicev1/api",
				"INSIGHTS_FOR_MEDICAL_LITERATURE_SERVICE_AUTH_TYPE": "someOtherAuth",
			}

			SetTestEnvironment(testEnvironment)
			testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1UsingExternalConfig(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
				Version: core.StringPtr(version),
			})

			It(`Instantiate service client with error`, func() {
				Expect(testService).To(BeNil())
				Expect(testServiceErr).ToNot(BeNil())
				ClearTestEnvironment(testEnvironment)
			})
		})
		Context(`Using external config, construct service client instances with error: Invalid URL`, func() {
			// Map containing environment variables used in testing.
			var testEnvironment = map[string]string{
				"INSIGHTS_FOR_MEDICAL_LITERATURE_SERVICE_AUTH_TYPE": "NOAuth",
			}

			SetTestEnvironment(testEnvironment)
			testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1UsingExternalConfig(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
				URL:     "{{BAD_URL_STRING",
				Version: core.StringPtr(version),
			})

			It(`Instantiate service client with error`, func() {
				Expect(testService).To(BeNil())
				Expect(testServiceErr).ToNot(BeNil())
				ClearTestEnvironment(testEnvironment)
			})
		})
	})
	Describe(`GetHealthCheckStatus(getHealthCheckStatusOptions *GetHealthCheckStatusOptions)`, func() {
		version := "testString"
		getHealthCheckStatusPath := "/v1/status/health_check"
		Context(`Using mock server endpoint`, func() {
			testServer := httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
				defer GinkgoRecover()

				// Verify the contents of the request
				Expect(req.URL.Path).To(Equal(getHealthCheckStatusPath))
				Expect(req.Method).To(Equal("GET"))
				Expect(req.Header["Accept"]).ToNot(BeNil())
				Expect(req.Header["Accept"][0]).To(Equal(fmt.Sprintf("%v", "application/json")))
				Expect(req.URL.Query()["format"]).To(Equal([]string{"json"}))

				res.Header().Set("Content-type", "application/json")
				res.WriteHeader(200)
				fmt.Fprintf(res, `{"version": "Version", "upTime": "UpTime", "serviceState": "OK", "stateDetails": "StateDetails", "hostName": "HostName", "requestCount": 12, "maxMemoryMb": 11, "commitedMemoryMb": 16, "inUseMemoryMb": 13, "availableProcessors": 19, "concurrentRequests": 18, "maxConcurrentRequests": 21, "totalRejectedRequests": 21, "totalBlockedRequests": 20}`)
			}))
			It(`Invoke GetHealthCheckStatus successfully`, func() {
				defer testServer.Close()

				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
					Version:       core.StringPtr(version),
				})
				Expect(testServiceErr).To(BeNil())
				Expect(testService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := testService.GetHealthCheckStatus(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetHealthCheckStatusOptions model
				getHealthCheckStatusOptionsModel := new(insightsformedicalliteratureservicev1.GetHealthCheckStatusOptions)
				getHealthCheckStatusOptionsModel.Accept = core.StringPtr("application/json")
				getHealthCheckStatusOptionsModel.Format = core.StringPtr("json")

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = testService.GetHealthCheckStatus(getHealthCheckStatusOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())
			})
		})
	})
	Describe(`Service constructor tests`, func() {
		version := "testString"
		It(`Instantiate service client`, func() {
			testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
				Authenticator: &core.NoAuthAuthenticator{},
				Version:       core.StringPtr(version),
			})
			Expect(testService).ToNot(BeNil())
			Expect(testServiceErr).To(BeNil())
		})
		It(`Instantiate service client with error: Invalid URL`, func() {
			testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
				URL:     "{{BAD_URL_STRING",
				Version: core.StringPtr(version),
			})
			Expect(testService).To(BeNil())
			Expect(testServiceErr).ToNot(BeNil())
		})
		It(`Instantiate service client with error: Invalid Auth`, func() {
			testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
				URL:     "https://insightsformedicalliteratureservicev1/api",
				Version: core.StringPtr(version),
				Authenticator: &core.BasicAuthenticator{
					Username: "",
					Password: "",
				},
			})
			Expect(testService).To(BeNil())
			Expect(testServiceErr).ToNot(BeNil())
		})
		It(`Instantiate service client with error: Validation Error`, func() {
			testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{})
			Expect(testService).To(BeNil())
			Expect(testServiceErr).ToNot(BeNil())
		})
	})
	Describe(`Service constructor tests using external config`, func() {
		version := "testString"
		Context(`Using external config, construct service client instances`, func() {
			// Map containing environment variables used in testing.
			var testEnvironment = map[string]string{
				"INSIGHTS_FOR_MEDICAL_LITERATURE_SERVICE_URL":       "https://insightsformedicalliteratureservicev1/api",
				"INSIGHTS_FOR_MEDICAL_LITERATURE_SERVICE_AUTH_TYPE": "noauth",
			}

			It(`Create service client using external config successfully`, func() {
				SetTestEnvironment(testEnvironment)
				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1UsingExternalConfig(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					Version: core.StringPtr(version),
				})
				Expect(testService).ToNot(BeNil())
				Expect(testServiceErr).To(BeNil())
				ClearTestEnvironment(testEnvironment)
			})
			It(`Create service client using external config and set url from constructor successfully`, func() {
				SetTestEnvironment(testEnvironment)
				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1UsingExternalConfig(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					URL:     "https://testService/api",
					Version: core.StringPtr(version),
				})
				Expect(testService).ToNot(BeNil())
				Expect(testServiceErr).To(BeNil())
				Expect(testService.Service.GetServiceURL()).To(Equal("https://testService/api"))
				ClearTestEnvironment(testEnvironment)
			})
			It(`Create service client using external config and set url programatically successfully`, func() {
				SetTestEnvironment(testEnvironment)
				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1UsingExternalConfig(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					Version: core.StringPtr(version),
				})
				err := testService.SetServiceURL("https://testService/api")
				Expect(err).To(BeNil())
				Expect(testService).ToNot(BeNil())
				Expect(testServiceErr).To(BeNil())
				Expect(testService.Service.GetServiceURL()).To(Equal("https://testService/api"))
				ClearTestEnvironment(testEnvironment)
			})
		})
		Context(`Using external config, construct service client instances with error: Invalid Auth`, func() {
			// Map containing environment variables used in testing.
			var testEnvironment = map[string]string{
				"INSIGHTS_FOR_MEDICAL_LITERATURE_SERVICE_URL":       "https://insightsformedicalliteratureservicev1/api",
				"INSIGHTS_FOR_MEDICAL_LITERATURE_SERVICE_AUTH_TYPE": "someOtherAuth",
			}

			SetTestEnvironment(testEnvironment)
			testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1UsingExternalConfig(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
				Version: core.StringPtr(version),
			})

			It(`Instantiate service client with error`, func() {
				Expect(testService).To(BeNil())
				Expect(testServiceErr).ToNot(BeNil())
				ClearTestEnvironment(testEnvironment)
			})
		})
		Context(`Using external config, construct service client instances with error: Invalid URL`, func() {
			// Map containing environment variables used in testing.
			var testEnvironment = map[string]string{
				"INSIGHTS_FOR_MEDICAL_LITERATURE_SERVICE_AUTH_TYPE": "NOAuth",
			}

			SetTestEnvironment(testEnvironment)
			testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1UsingExternalConfig(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
				URL:     "{{BAD_URL_STRING",
				Version: core.StringPtr(version),
			})

			It(`Instantiate service client with error`, func() {
				Expect(testService).To(BeNil())
				Expect(testServiceErr).ToNot(BeNil())
				ClearTestEnvironment(testEnvironment)
			})
		})
	})
	Describe(`Search(searchOptions *SearchOptions)`, func() {
		version := "testString"
		searchPath := "/v1/corpora/testString/search"
		Context(`Using mock server endpoint`, func() {
			testServer := httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
				defer GinkgoRecover()

				// Verify the contents of the request
				Expect(req.URL.Path).To(Equal(searchPath))
				Expect(req.Method).To(Equal("POST"))
				Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))

				// TODO: Add check for verbose query parameter

				res.Header().Set("Content-type", "application/json")
				res.WriteHeader(200)
				fmt.Fprintf(res, `{"href": "Href", "pageNumber": 10, "get_limit": 8, "totalDocumentCount": 18, "concepts": [{"ontology": "Ontology", "cui": "Cui", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "count": 5, "hitCount": 8, "score": 5, "parents": {"count": 5, "hits": 4}, "children": {"count": 5, "hits": 4}, "siblings": {"count": 5, "hits": 4}, "related": {"count": 5, "hits": 4}, "documentIds": ["DocumentIds"], "dataType": "DataType", "unit": "Unit", "operator": "Operator", "minValue": "MinValue", "maxValue": "MaxValue", "vocab": "Vocab", "properties": ["Properties"]}], "types": ["Types"], "attributes": [{"attributeId": "AttributeID", "displayName": "DisplayName", "count": 5}], "values": [{"ontology": "Ontology", "cui": "Cui", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "count": 5, "hitCount": 8, "score": 5, "parents": {"count": 5, "hits": 4}, "children": {"count": 5, "hits": 4}, "siblings": {"count": 5, "hits": 4}, "related": {"count": 5, "hits": 4}, "documentIds": ["DocumentIds"], "dataType": "DataType", "unit": "Unit", "operator": "Operator", "minValue": "MinValue", "maxValue": "MaxValue", "vocab": "Vocab", "properties": ["Properties"]}], "ranges": {"mapKey": {"operator": "Operator", "min": "Min", "max": "Max", "count": 5}}, "typeahead": [{"ontology": "Ontology", "cui": "Cui", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "count": 5, "hitCount": 8, "score": 5, "parents": {"count": 5, "hits": 4}, "children": {"count": 5, "hits": 4}, "siblings": {"count": 5, "hits": 4}, "related": {"count": 5, "hits": 4}, "documentIds": ["DocumentIds"], "dataType": "DataType", "unit": "Unit", "operator": "Operator", "minValue": "MinValue", "maxValue": "MaxValue", "vocab": "Vocab", "properties": ["Properties"]}], "aggregations": {"mapKey": [{"name": "Name", "documentCount": 13}]}, "dateHistograms": {"mapKey": [{"date": "Date", "hits": 4}]}, "qualifiers": [{"id": "ID", "name": "Name"}], "backend": {"messages": [{"messageType": "expanded_request", "url": "URL", "request": {"anyKey": "anyValue"}, "headers": ["Headers"], "status": 6, "response": {"anyKey": "anyValue"}}]}, "expandedQuery": {"anyKey": "anyValue"}, "parsedBoolExpression": {"boolExpression": "BoolExpression", "boolOperands": [{"boolOperand": "BoolOperand"}]}, "conceptsExist": {"mapKey": 5}, "cursorId": "CursorID", "vocabs": ["Vocabs"], "annotations": {"mapKey": {"unstructured": [{"text": "Text", "data": {"concepts": [{"uniqueId": 8, "stickyIds": [9], "section": "Section", "type": "Type", "begin": 5, "end": 3, "coveredText": "CoveredText", "cui": "Cui", "preferredName": "PreferredName", "source": "Source", "negated": false, "hypothetical": true, "timestamp": 9, "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "features": {"mapKey": "Inner"}, "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "hits": 4}], "attributeValues": [{"uniqueId": 8, "stickyIds": [9], "section": "Section", "type": "Type", "begin": 5, "end": 3, "coveredText": "CoveredText", "cui": "Cui", "preferredName": "PreferredName", "source": "Source", "negated": false, "hypothetical": true, "timestamp": 9, "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "features": {"mapKey": "Inner"}, "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "hits": 4}], "relations": [{"relationId": "RelationID", "relation": "Relation", "source": {"section": "Section", "begin": 5, "end": 3, "coveredText": "CoveredText", "source": "Source", "type": "Type"}, "target": {"section": "Section", "begin": 5, "end": 3, "coveredText": "CoveredText", "source": "Source", "type": "Type"}}], "mesh": [{"uniqueId": 8, "stickyIds": [9], "section": "Section", "type": "Type", "begin": 5, "end": 3, "coveredText": "CoveredText", "cui": "Cui", "preferredName": "PreferredName", "source": "Source", "negated": false, "hypothetical": true, "timestamp": 9, "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "features": {"mapKey": "Inner"}, "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "hits": 4}], "text": [{"uniqueId": 8, "stickyIds": [9], "section": "Section", "type": "Type", "begin": 5, "end": 3, "coveredText": "CoveredText", "cui": "Cui", "preferredName": "PreferredName", "source": "Source", "negated": false, "hypothetical": true, "timestamp": 9, "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "features": {"mapKey": "Inner"}, "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "hits": 4}]}}]}}, "metadata": {"corpus": "Corpus", "corpusDescription": "CorpusDescription", "fields": {"mapKey": ["Inner"]}}, "documents": [{"documentId": "DocumentID", "title": "Title", "metadata": {"mapKey": ["Inner"]}, "sectionName": "SectionName", "sectionId": "SectionID", "corpus": "Corpus", "links": {"hrefSearchMatches": "HrefSearchMatches", "hrefCategories": "HrefCategories"}, "passages": {"allPassages": [{"documentSection": "DocumentSection", "text": {}, "timestamp": 9, "preferredName": "PreferredName"}], "searchTermToPassages": {"mapKey": [{"documentSection": "DocumentSection", "text": {}, "timestamp": 9, "preferredName": "PreferredName"}]}}, "annotations": {"mapKey": {"uniqueId": 8, "stickyIds": [9], "ontology": "Ontology", "section": "Section", "preferredName": "PreferredName", "cui": "Cui", "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "type": "Type", "negated": false, "hypothetical": true, "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "begin": 5, "end": 3, "score": 5, "timestamp": 9, "features": {"mapKey": "Inner"}, "hits": 4}}}], "subQueries": [{"href": "Href", "pageNumber": 10, "get_limit": 8, "totalDocumentCount": 18, "concepts": [{"ontology": "Ontology", "cui": "Cui", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "count": 5, "hitCount": 8, "score": 5, "parents": {"count": 5, "hits": 4}, "children": {"count": 5, "hits": 4}, "siblings": {"count": 5, "hits": 4}, "related": {"count": 5, "hits": 4}, "documentIds": ["DocumentIds"], "dataType": "DataType", "unit": "Unit", "operator": "Operator", "minValue": "MinValue", "maxValue": "MaxValue", "vocab": "Vocab", "properties": ["Properties"]}], "types": ["Types"], "attributes": [{"attributeId": "AttributeID", "displayName": "DisplayName", "count": 5}], "values": [{"ontology": "Ontology", "cui": "Cui", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "count": 5, "hitCount": 8, "score": 5, "parents": {"count": 5, "hits": 4}, "children": {"count": 5, "hits": 4}, "siblings": {"count": 5, "hits": 4}, "related": {"count": 5, "hits": 4}, "documentIds": ["DocumentIds"], "dataType": "DataType", "unit": "Unit", "operator": "Operator", "minValue": "MinValue", "maxValue": "MaxValue", "vocab": "Vocab", "properties": ["Properties"]}], "ranges": {"mapKey": {"operator": "Operator", "min": "Min", "max": "Max", "count": 5}}, "typeahead": [{"ontology": "Ontology", "cui": "Cui", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "count": 5, "hitCount": 8, "score": 5, "parents": {"count": 5, "hits": 4}, "children": {"count": 5, "hits": 4}, "siblings": {"count": 5, "hits": 4}, "related": {"count": 5, "hits": 4}, "documentIds": ["DocumentIds"], "dataType": "DataType", "unit": "Unit", "operator": "Operator", "minValue": "MinValue", "maxValue": "MaxValue", "vocab": "Vocab", "properties": ["Properties"]}], "aggregations": {"mapKey": [{"name": "Name", "documentCount": 13}]}, "dateHistograms": {"mapKey": [{"date": "Date", "hits": 4}]}, "qualifiers": [{"id": "ID", "name": "Name"}], "backend": {"messages": [{"messageType": "expanded_request", "url": "URL", "request": {"anyKey": "anyValue"}, "headers": ["Headers"], "status": 6, "response": {"anyKey": "anyValue"}}]}, "expandedQuery": {"anyKey": "anyValue"}, "parsedBoolExpression": {"boolExpression": "BoolExpression", "boolOperands": [{"boolOperand": "BoolOperand"}]}, "conceptsExist": {"mapKey": 5}, "cursorId": "CursorID", "vocabs": ["Vocabs"], "annotations": {"mapKey": {"unstructured": [{"text": "Text", "data": {"concepts": [{"uniqueId": 8, "stickyIds": [9], "section": "Section", "type": "Type", "begin": 5, "end": 3, "coveredText": "CoveredText", "cui": "Cui", "preferredName": "PreferredName", "source": "Source", "negated": false, "hypothetical": true, "timestamp": 9, "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "features": {"mapKey": "Inner"}, "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "hits": 4}], "attributeValues": [{"uniqueId": 8, "stickyIds": [9], "section": "Section", "type": "Type", "begin": 5, "end": 3, "coveredText": "CoveredText", "cui": "Cui", "preferredName": "PreferredName", "source": "Source", "negated": false, "hypothetical": true, "timestamp": 9, "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "features": {"mapKey": "Inner"}, "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "hits": 4}], "relations": [{"relationId": "RelationID", "relation": "Relation", "source": {"section": "Section", "begin": 5, "end": 3, "coveredText": "CoveredText", "source": "Source", "type": "Type"}, "target": {"section": "Section", "begin": 5, "end": 3, "coveredText": "CoveredText", "source": "Source", "type": "Type"}}], "mesh": [{"uniqueId": 8, "stickyIds": [9], "section": "Section", "type": "Type", "begin": 5, "end": 3, "coveredText": "CoveredText", "cui": "Cui", "preferredName": "PreferredName", "source": "Source", "negated": false, "hypothetical": true, "timestamp": 9, "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "features": {"mapKey": "Inner"}, "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "hits": 4}], "text": [{"uniqueId": 8, "stickyIds": [9], "section": "Section", "type": "Type", "begin": 5, "end": 3, "coveredText": "CoveredText", "cui": "Cui", "preferredName": "PreferredName", "source": "Source", "negated": false, "hypothetical": true, "timestamp": 9, "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "features": {"mapKey": "Inner"}, "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "hits": 4}]}}]}}, "metadata": {"corpus": "Corpus", "corpusDescription": "CorpusDescription", "fields": {"mapKey": ["Inner"]}}, "documents": [{"documentId": "DocumentID", "title": "Title", "metadata": {"mapKey": ["Inner"]}, "sectionName": "SectionName", "sectionId": "SectionID", "corpus": "Corpus", "links": {"hrefSearchMatches": "HrefSearchMatches", "hrefCategories": "HrefCategories"}, "passages": {"allPassages": [{"documentSection": "DocumentSection", "text": {}, "timestamp": 9, "preferredName": "PreferredName"}], "searchTermToPassages": {"mapKey": [{"documentSection": "DocumentSection", "text": {}, "timestamp": 9, "preferredName": "PreferredName"}]}}, "annotations": {"mapKey": {"uniqueId": 8, "stickyIds": [9], "ontology": "Ontology", "section": "Section", "preferredName": "PreferredName", "cui": "Cui", "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "type": "Type", "negated": false, "hypothetical": true, "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "begin": 5, "end": 3, "score": 5, "timestamp": 9, "features": {"mapKey": "Inner"}, "hits": 4}}}], "subQueries": [{"href": "Href", "pageNumber": 10, "get_limit": 8, "totalDocumentCount": 18, "concepts": [{"ontology": "Ontology", "cui": "Cui", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "count": 5, "hitCount": 8, "score": 5, "parents": {"count": 5, "hits": 4}, "children": {"count": 5, "hits": 4}, "siblings": {"count": 5, "hits": 4}, "related": {"count": 5, "hits": 4}, "documentIds": ["DocumentIds"], "dataType": "DataType", "unit": "Unit", "operator": "Operator", "minValue": "MinValue", "maxValue": "MaxValue", "vocab": "Vocab", "properties": ["Properties"]}], "types": ["Types"], "attributes": [{"attributeId": "AttributeID", "displayName": "DisplayName", "count": 5}], "values": [{"ontology": "Ontology", "cui": "Cui", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "count": 5, "hitCount": 8, "score": 5, "parents": {"count": 5, "hits": 4}, "children": {"count": 5, "hits": 4}, "siblings": {"count": 5, "hits": 4}, "related": {"count": 5, "hits": 4}, "documentIds": ["DocumentIds"], "dataType": "DataType", "unit": "Unit", "operator": "Operator", "minValue": "MinValue", "maxValue": "MaxValue", "vocab": "Vocab", "properties": ["Properties"]}], "ranges": {"mapKey": {"operator": "Operator", "min": "Min", "max": "Max", "count": 5}}, "typeahead": [{"ontology": "Ontology", "cui": "Cui", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "count": 5, "hitCount": 8, "score": 5, "parents": {"count": 5, "hits": 4}, "children": {"count": 5, "hits": 4}, "siblings": {"count": 5, "hits": 4}, "related": {"count": 5, "hits": 4}, "documentIds": ["DocumentIds"], "dataType": "DataType", "unit": "Unit", "operator": "Operator", "minValue": "MinValue", "maxValue": "MaxValue", "vocab": "Vocab", "properties": ["Properties"]}], "aggregations": {"mapKey": [{"name": "Name", "documentCount": 13}]}, "dateHistograms": {"mapKey": [{"date": "Date", "hits": 4}]}, "qualifiers": [{"id": "ID", "name": "Name"}], "backend": {"messages": [{"messageType": "expanded_request", "url": "URL", "request": {"anyKey": "anyValue"}, "headers": ["Headers"], "status": 6, "response": {"anyKey": "anyValue"}}]}, "expandedQuery": {"anyKey": "anyValue"}, "parsedBoolExpression": {"boolExpression": "BoolExpression", "boolOperands": [{"boolOperand": "BoolOperand"}]}, "conceptsExist": {"mapKey": 5}, "cursorId": "CursorID", "vocabs": ["Vocabs"], "annotations": {"mapKey": {"unstructured": [{"text": "Text", "data": {"concepts": [{"uniqueId": 8, "stickyIds": [9], "section": "Section", "type": "Type", "begin": 5, "end": 3, "coveredText": "CoveredText", "cui": "Cui", "preferredName": "PreferredName", "source": "Source", "negated": false, "hypothetical": true, "timestamp": 9, "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "features": {"mapKey": "Inner"}, "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "hits": 4}], "attributeValues": [{"uniqueId": 8, "stickyIds": [9], "section": "Section", "type": "Type", "begin": 5, "end": 3, "coveredText": "CoveredText", "cui": "Cui", "preferredName": "PreferredName", "source": "Source", "negated": false, "hypothetical": true, "timestamp": 9, "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "features": {"mapKey": "Inner"}, "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "hits": 4}], "relations": [{"relationId": "RelationID", "relation": "Relation", "source": {"section": "Section", "begin": 5, "end": 3, "coveredText": "CoveredText", "source": "Source", "type": "Type"}, "target": {"section": "Section", "begin": 5, "end": 3, "coveredText": "CoveredText", "source": "Source", "type": "Type"}}], "mesh": [{"uniqueId": 8, "stickyIds": [9], "section": "Section", "type": "Type", "begin": 5, "end": 3, "coveredText": "CoveredText", "cui": "Cui", "preferredName": "PreferredName", "source": "Source", "negated": false, "hypothetical": true, "timestamp": 9, "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "features": {"mapKey": "Inner"}, "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "hits": 4}], "text": [{"uniqueId": 8, "stickyIds": [9], "section": "Section", "type": "Type", "begin": 5, "end": 3, "coveredText": "CoveredText", "cui": "Cui", "preferredName": "PreferredName", "source": "Source", "negated": false, "hypothetical": true, "timestamp": 9, "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "features": {"mapKey": "Inner"}, "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "hits": 4}]}}]}}, "metadata": {"corpus": "Corpus", "corpusDescription": "CorpusDescription", "fields": {"mapKey": ["Inner"]}}, "documents": [{"documentId": "DocumentID", "title": "Title", "metadata": {"mapKey": ["Inner"]}, "sectionName": "SectionName", "sectionId": "SectionID", "corpus": "Corpus", "links": {"hrefSearchMatches": "HrefSearchMatches", "hrefCategories": "HrefCategories"}, "passages": {"allPassages": [{"documentSection": "DocumentSection", "text": {}, "timestamp": 9, "preferredName": "PreferredName"}], "searchTermToPassages": {"mapKey": [{"documentSection": "DocumentSection", "text": {}, "timestamp": 9, "preferredName": "PreferredName"}]}}, "annotations": {"mapKey": {"uniqueId": 8, "stickyIds": [9], "ontology": "Ontology", "section": "Section", "preferredName": "PreferredName", "cui": "Cui", "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "type": "Type", "negated": false, "hypothetical": true, "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "begin": 5, "end": 3, "score": 5, "timestamp": 9, "features": {"mapKey": "Inner"}, "hits": 4}}}], "subQueries": [{"href": "Href", "pageNumber": 10, "get_limit": 8, "totalDocumentCount": 18, "concepts": [{"ontology": "Ontology", "cui": "Cui", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "count": 5, "hitCount": 8, "score": 5, "parents": {"count": 5, "hits": 4}, "children": {"count": 5, "hits": 4}, "siblings": {"count": 5, "hits": 4}, "related": {"count": 5, "hits": 4}, "documentIds": ["DocumentIds"], "dataType": "DataType", "unit": "Unit", "operator": "Operator", "minValue": "MinValue", "maxValue": "MaxValue", "vocab": "Vocab", "properties": ["Properties"]}], "types": ["Types"], "attributes": [{"attributeId": "AttributeID", "displayName": "DisplayName", "count": 5}], "values": [{"ontology": "Ontology", "cui": "Cui", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "count": 5, "hitCount": 8, "score": 5, "parents": {"count": 5, "hits": 4}, "children": {"count": 5, "hits": 4}, "siblings": {"count": 5, "hits": 4}, "related": {"count": 5, "hits": 4}, "documentIds": ["DocumentIds"], "dataType": "DataType", "unit": "Unit", "operator": "Operator", "minValue": "MinValue", "maxValue": "MaxValue", "vocab": "Vocab", "properties": ["Properties"]}], "ranges": {"mapKey": {"operator": "Operator", "min": "Min", "max": "Max", "count": 5}}, "typeahead": [{"ontology": "Ontology", "cui": "Cui", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "count": 5, "hitCount": 8, "score": 5, "parents": {"count": 5, "hits": 4}, "children": {"count": 5, "hits": 4}, "siblings": {"count": 5, "hits": 4}, "related": {"count": 5, "hits": 4}, "documentIds": ["DocumentIds"], "dataType": "DataType", "unit": "Unit", "operator": "Operator", "minValue": "MinValue", "maxValue": "MaxValue", "vocab": "Vocab", "properties": ["Properties"]}], "aggregations": {"mapKey": [{"name": "Name", "documentCount": 13}]}, "dateHistograms": {"mapKey": [{"date": "Date", "hits": 4}]}, "qualifiers": [{"id": "ID", "name": "Name"}], "backend": {"messages": [{"messageType": "expanded_request", "url": "URL", "request": {"anyKey": "anyValue"}, "headers": ["Headers"], "status": 6, "response": {"anyKey": "anyValue"}}]}, "expandedQuery": {"anyKey": "anyValue"}, "parsedBoolExpression": {"boolExpression": "BoolExpression", "boolOperands": [{"boolOperand": "BoolOperand"}]}, "conceptsExist": {"mapKey": 5}, "cursorId": "CursorID", "vocabs": ["Vocabs"], "annotations": {"mapKey": {"unstructured": [{"text": "Text", "data": {"concepts": [{"uniqueId": 8, "stickyIds": [9], "section": "Section", "type": "Type", "begin": 5, "end": 3, "coveredText": "CoveredText", "cui": "Cui", "preferredName": "PreferredName", "source": "Source", "negated": false, "hypothetical": true, "timestamp": 9, "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "features": {"mapKey": "Inner"}, "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "hits": 4}], "attributeValues": [{"uniqueId": 8, "stickyIds": [9], "section": "Section", "type": "Type", "begin": 5, "end": 3, "coveredText": "CoveredText", "cui": "Cui", "preferredName": "PreferredName", "source": "Source", "negated": false, "hypothetical": true, "timestamp": 9, "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "features": {"mapKey": "Inner"}, "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "hits": 4}], "relations": [{"relationId": "RelationID", "relation": "Relation", "source": {"section": "Section", "begin": 5, "end": 3, "coveredText": "CoveredText", "source": "Source", "type": "Type"}, "target": {"section": "Section", "begin": 5, "end": 3, "coveredText": "CoveredText", "source": "Source", "type": "Type"}}], "mesh": [{"uniqueId": 8, "stickyIds": [9], "section": "Section", "type": "Type", "begin": 5, "end": 3, "coveredText": "CoveredText", "cui": "Cui", "preferredName": "PreferredName", "source": "Source", "negated": false, "hypothetical": true, "timestamp": 9, "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "features": {"mapKey": "Inner"}, "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "hits": 4}], "text": [{"uniqueId": 8, "stickyIds": [9], "section": "Section", "type": "Type", "begin": 5, "end": 3, "coveredText": "CoveredText", "cui": "Cui", "preferredName": "PreferredName", "source": "Source", "negated": false, "hypothetical": true, "timestamp": 9, "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "features": {"mapKey": "Inner"}, "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "hits": 4}]}}]}}, "metadata": {"corpus": "Corpus", "corpusDescription": "CorpusDescription", "fields": {"mapKey": ["Inner"]}}, "documents": [{"documentId": "DocumentID", "title": "Title", "metadata": {"mapKey": ["Inner"]}, "sectionName": "SectionName", "sectionId": "SectionID", "corpus": "Corpus", "links": {"hrefSearchMatches": "HrefSearchMatches", "hrefCategories": "HrefCategories"}, "passages": {"allPassages": [{"documentSection": "DocumentSection", "text": {}, "timestamp": 9, "preferredName": "PreferredName"}], "searchTermToPassages": {"mapKey": [{"documentSection": "DocumentSection", "text": {}, "timestamp": 9, "preferredName": "PreferredName"}]}}, "annotations": {"mapKey": {"uniqueId": 8, "stickyIds": [9], "ontology": "Ontology", "section": "Section", "preferredName": "PreferredName", "cui": "Cui", "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "type": "Type", "negated": false, "hypothetical": true, "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "begin": 5, "end": 3, "score": 5, "timestamp": 9, "features": {"mapKey": "Inner"}, "hits": 4}}}], "subQueries": [{"href": "Href", "pageNumber": 10, "get_limit": 8, "totalDocumentCount": 18, "concepts": [{"ontology": "Ontology", "cui": "Cui", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "count": 5, "hitCount": 8, "score": 5, "parents": {"count": 5, "hits": 4}, "children": {"count": 5, "hits": 4}, "siblings": {"count": 5, "hits": 4}, "related": {"count": 5, "hits": 4}, "documentIds": ["DocumentIds"], "dataType": "DataType", "unit": "Unit", "operator": "Operator", "minValue": "MinValue", "maxValue": "MaxValue", "vocab": "Vocab", "properties": ["Properties"]}], "types": ["Types"], "attributes": [{"attributeId": "AttributeID", "displayName": "DisplayName", "count": 5}], "values": [{"ontology": "Ontology", "cui": "Cui", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "count": 5, "hitCount": 8, "score": 5, "parents": {"count": 5, "hits": 4}, "children": {"count": 5, "hits": 4}, "siblings": {"count": 5, "hits": 4}, "related": {"count": 5, "hits": 4}, "documentIds": ["DocumentIds"], "dataType": "DataType", "unit": "Unit", "operator": "Operator", "minValue": "MinValue", "maxValue": "MaxValue", "vocab": "Vocab", "properties": ["Properties"]}], "ranges": {"mapKey": {"operator": "Operator", "min": "Min", "max": "Max", "count": 5}}, "typeahead": [{"ontology": "Ontology", "cui": "Cui", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "count": 5, "hitCount": 8, "score": 5, "parents": {"count": 5, "hits": 4}, "children": {"count": 5, "hits": 4}, "siblings": {"count": 5, "hits": 4}, "related": {"count": 5, "hits": 4}, "documentIds": ["DocumentIds"], "dataType": "DataType", "unit": "Unit", "operator": "Operator", "minValue": "MinValue", "maxValue": "MaxValue", "vocab": "Vocab", "properties": ["Properties"]}], "aggregations": {"mapKey": [{"name": "Name", "documentCount": 13}]}, "dateHistograms": {"mapKey": [{"date": "Date", "hits": 4}]}, "qualifiers": [{"id": "ID", "name": "Name"}], "backend": {"messages": [{"messageType": "expanded_request", "url": "URL", "request": {"anyKey": "anyValue"}, "headers": ["Headers"], "status": 6, "response": {"anyKey": "anyValue"}}]}, "expandedQuery": {"anyKey": "anyValue"}, "parsedBoolExpression": {"boolExpression": "BoolExpression", "boolOperands": [{"boolOperand": "BoolOperand"}]}, "conceptsExist": {"mapKey": 5}, "cursorId": "CursorID", "vocabs": ["Vocabs"], "annotations": {"mapKey": {"unstructured": [{"text": "Text", "data": {"concepts": [{"uniqueId": 8, "stickyIds": [9], "section": "Section", "type": "Type", "begin": 5, "end": 3, "coveredText": "CoveredText", "cui": "Cui", "preferredName": "PreferredName", "source": "Source", "negated": false, "hypothetical": true, "timestamp": 9, "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "features": {"mapKey": "Inner"}, "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "hits": 4}], "attributeValues": [{"uniqueId": 8, "stickyIds": [9], "section": "Section", "type": "Type", "begin": 5, "end": 3, "coveredText": "CoveredText", "cui": "Cui", "preferredName": "PreferredName", "source": "Source", "negated": false, "hypothetical": true, "timestamp": 9, "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "features": {"mapKey": "Inner"}, "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "hits": 4}], "relations": [{"relationId": "RelationID", "relation": "Relation", "source": {"section": "Section", "begin": 5, "end": 3, "coveredText": "CoveredText", "source": "Source", "type": "Type"}, "target": {"section": "Section", "begin": 5, "end": 3, "coveredText": "CoveredText", "source": "Source", "type": "Type"}}], "mesh": [{"uniqueId": 8, "stickyIds": [9], "section": "Section", "type": "Type", "begin": 5, "end": 3, "coveredText": "CoveredText", "cui": "Cui", "preferredName": "PreferredName", "source": "Source", "negated": false, "hypothetical": true, "timestamp": 9, "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "features": {"mapKey": "Inner"}, "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "hits": 4}], "text": [{"uniqueId": 8, "stickyIds": [9], "section": "Section", "type": "Type", "begin": 5, "end": 3, "coveredText": "CoveredText", "cui": "Cui", "preferredName": "PreferredName", "source": "Source", "negated": false, "hypothetical": true, "timestamp": 9, "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "features": {"mapKey": "Inner"}, "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "hits": 4}]}}]}}, "metadata": {"corpus": "Corpus", "corpusDescription": "CorpusDescription", "fields": {"mapKey": ["Inner"]}}, "documents": [{"documentId": "DocumentID", "title": "Title", "metadata": {"mapKey": ["Inner"]}, "sectionName": "SectionName", "sectionId": "SectionID", "corpus": "Corpus", "links": {"hrefSearchMatches": "HrefSearchMatches", "hrefCategories": "HrefCategories"}, "passages": {"allPassages": [{"documentSection": "DocumentSection", "text": {}, "timestamp": 9, "preferredName": "PreferredName"}], "searchTermToPassages": {"mapKey": [{"documentSection": "DocumentSection", "text": {}, "timestamp": 9, "preferredName": "PreferredName"}]}}, "annotations": {"mapKey": {"uniqueId": 8, "stickyIds": [9], "ontology": "Ontology", "section": "Section", "preferredName": "PreferredName", "cui": "Cui", "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "type": "Type", "negated": false, "hypothetical": true, "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "begin": 5, "end": 3, "score": 5, "timestamp": 9, "features": {"mapKey": "Inner"}, "hits": 4}}}], "subQueries": [{"href": "Href", "pageNumber": 10, "get_limit": 8, "totalDocumentCount": 18, "concepts": [{"ontology": "Ontology", "cui": "Cui", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "count": 5, "hitCount": 8, "score": 5, "parents": {"count": 5, "hits": 4}, "children": {"count": 5, "hits": 4}, "siblings": {"count": 5, "hits": 4}, "related": {"count": 5, "hits": 4}, "documentIds": ["DocumentIds"], "dataType": "DataType", "unit": "Unit", "operator": "Operator", "minValue": "MinValue", "maxValue": "MaxValue", "vocab": "Vocab", "properties": ["Properties"]}], "types": ["Types"], "attributes": [{"attributeId": "AttributeID", "displayName": "DisplayName", "count": 5}], "values": [{"ontology": "Ontology", "cui": "Cui", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "count": 5, "hitCount": 8, "score": 5, "parents": {"count": 5, "hits": 4}, "children": {"count": 5, "hits": 4}, "siblings": {"count": 5, "hits": 4}, "related": {"count": 5, "hits": 4}, "documentIds": ["DocumentIds"], "dataType": "DataType", "unit": "Unit", "operator": "Operator", "minValue": "MinValue", "maxValue": "MaxValue", "vocab": "Vocab", "properties": ["Properties"]}], "ranges": {"mapKey": {"operator": "Operator", "min": "Min", "max": "Max", "count": 5}}, "typeahead": [{"ontology": "Ontology", "cui": "Cui", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "count": 5, "hitCount": 8, "score": 5, "parents": {"count": 5, "hits": 4}, "children": {"count": 5, "hits": 4}, "siblings": {"count": 5, "hits": 4}, "related": {"count": 5, "hits": 4}, "documentIds": ["DocumentIds"], "dataType": "DataType", "unit": "Unit", "operator": "Operator", "minValue": "MinValue", "maxValue": "MaxValue", "vocab": "Vocab", "properties": ["Properties"]}], "aggregations": {"mapKey": [{"name": "Name", "documentCount": 13}]}, "dateHistograms": {"mapKey": [{"date": "Date", "hits": 4}]}, "qualifiers": [{"id": "ID", "name": "Name"}], "backend": {"messages": [{"messageType": "expanded_request", "url": "URL", "request": {"anyKey": "anyValue"}, "headers": ["Headers"], "status": 6, "response": {"anyKey": "anyValue"}}]}, "expandedQuery": {"anyKey": "anyValue"}, "parsedBoolExpression": {"boolExpression": "BoolExpression", "boolOperands": [{"boolOperand": "BoolOperand"}]}, "conceptsExist": {"mapKey": 5}, "cursorId": "CursorID", "vocabs": ["Vocabs"], "annotations": {"mapKey": {"unstructured": [{"text": "Text", "data": {"concepts": [{"uniqueId": 8, "stickyIds": [9], "section": "Section", "type": "Type", "begin": 5, "end": 3, "coveredText": "CoveredText", "cui": "Cui", "preferredName": "PreferredName", "source": "Source", "negated": false, "hypothetical": true, "timestamp": 9, "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "features": {"mapKey": "Inner"}, "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "hits": 4}], "attributeValues": [{"uniqueId": 8, "stickyIds": [9], "section": "Section", "type": "Type", "begin": 5, "end": 3, "coveredText": "CoveredText", "cui": "Cui", "preferredName": "PreferredName", "source": "Source", "negated": false, "hypothetical": true, "timestamp": 9, "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "features": {"mapKey": "Inner"}, "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "hits": 4}], "relations": [{"relationId": "RelationID", "relation": "Relation"}], "mesh": [{"uniqueId": 8, "stickyIds": [9], "section": "Section", "type": "Type", "begin": 5, "end": 3, "coveredText": "CoveredText", "cui": "Cui", "preferredName": "PreferredName", "source": "Source", "negated": false, "hypothetical": true, "timestamp": 9, "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "features": {"mapKey": "Inner"}, "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "hits": 4}], "text": [{"uniqueId": 8, "stickyIds": [9], "section": "Section", "type": "Type", "begin": 5, "end": 3, "coveredText": "CoveredText", "cui": "Cui", "preferredName": "PreferredName", "source": "Source", "negated": false, "hypothetical": true, "timestamp": 9, "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "features": {"mapKey": "Inner"}, "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "hits": 4}]}}]}}, "metadata": {"corpus": "Corpus", "corpusDescription": "CorpusDescription", "fields": {"mapKey": ["Inner"]}}, "documents": [{"documentId": "DocumentID", "title": "Title", "metadata": {"mapKey": ["Inner"]}, "sectionName": "SectionName", "sectionId": "SectionID", "corpus": "Corpus", "links": {"hrefSearchMatches": "HrefSearchMatches", "hrefCategories": "HrefCategories"}, "passages": {"allPassages": [{"documentSection": "DocumentSection", "text": {}, "timestamp": 9, "preferredName": "PreferredName"}], "searchTermToPassages": {"mapKey": [{"documentSection": "DocumentSection", "text": {}, "timestamp": 9, "preferredName": "PreferredName"}]}}, "annotations": {"mapKey": {"uniqueId": 8, "stickyIds": [9], "ontology": "Ontology", "section": "Section", "preferredName": "PreferredName", "cui": "Cui", "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "type": "Type", "negated": false, "hypothetical": true, "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "begin": 5, "end": 3, "score": 5, "timestamp": 9, "features": {"mapKey": "Inner"}, "hits": 4}}}], "subQueries": [{"href": "Href", "pageNumber": 10, "get_limit": 8, "totalDocumentCount": 18, "concepts": [{"ontology": "Ontology", "cui": "Cui", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "count": 5, "hitCount": 8, "score": 5, "parents": {"count": 5, "hits": 4}, "children": {"count": 5, "hits": 4}, "siblings": {"count": 5, "hits": 4}, "related": {"count": 5, "hits": 4}, "documentIds": ["DocumentIds"], "dataType": "DataType", "unit": "Unit", "operator": "Operator", "minValue": "MinValue", "maxValue": "MaxValue", "vocab": "Vocab", "properties": ["Properties"]}], "types": ["Types"], "attributes": [{"attributeId": "AttributeID", "displayName": "DisplayName", "count": 5}], "values": [{"ontology": "Ontology", "cui": "Cui", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "count": 5, "hitCount": 8, "score": 5, "parents": {"count": 5, "hits": 4}, "children": {"count": 5, "hits": 4}, "siblings": {"count": 5, "hits": 4}, "related": {"count": 5, "hits": 4}, "documentIds": ["DocumentIds"], "dataType": "DataType", "unit": "Unit", "operator": "Operator", "minValue": "MinValue", "maxValue": "MaxValue", "vocab": "Vocab", "properties": ["Properties"]}], "ranges": {"mapKey": {"operator": "Operator", "min": "Min", "max": "Max", "count": 5}}, "typeahead": [{"ontology": "Ontology", "cui": "Cui", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "count": 5, "hitCount": 8, "score": 5, "parents": {"count": 5, "hits": 4}, "children": {"count": 5, "hits": 4}, "siblings": {"count": 5, "hits": 4}, "related": {"count": 5, "hits": 4}, "documentIds": ["DocumentIds"], "dataType": "DataType", "unit": "Unit", "operator": "Operator", "minValue": "MinValue", "maxValue": "MaxValue", "vocab": "Vocab", "properties": ["Properties"]}], "aggregations": {"mapKey": [{"name": "Name", "documentCount": 13}]}, "dateHistograms": {"mapKey": [{"date": "Date", "hits": 4}]}, "qualifiers": [{"id": "ID", "name": "Name"}], "backend": {"messages": [{"messageType": "expanded_request", "url": "URL", "request": {"anyKey": "anyValue"}, "headers": ["Headers"], "status": 6, "response": {"anyKey": "anyValue"}}]}, "expandedQuery": {"anyKey": "anyValue"}, "parsedBoolExpression": {"boolExpression": "BoolExpression", "boolOperands": [{"boolOperand": "BoolOperand"}]}, "conceptsExist": {"mapKey": 5}, "cursorId": "CursorID", "vocabs": ["Vocabs"], "annotations": {"mapKey": {"unstructured": [{"text": "Text", "data": {"concepts": [], "attributeValues": [], "relations": [], "mesh": [], "text": []}}]}}, "metadata": {"corpus": "Corpus", "corpusDescription": "CorpusDescription", "fields": {"mapKey": ["Inner"]}}, "documents": [{"documentId": "DocumentID", "title": "Title", "metadata": {"mapKey": ["Inner"]}, "sectionName": "SectionName", "sectionId": "SectionID", "corpus": "Corpus", "links": {"hrefSearchMatches": "HrefSearchMatches", "hrefCategories": "HrefCategories"}, "passages": {"allPassages": [{"documentSection": "DocumentSection", "timestamp": 9, "preferredName": "PreferredName"}], "searchTermToPassages": {"mapKey": [{"documentSection": "DocumentSection", "timestamp": 9, "preferredName": "PreferredName"}]}}, "annotations": {"mapKey": {"uniqueId": 8, "stickyIds": [9], "ontology": "Ontology", "section": "Section", "preferredName": "PreferredName", "cui": "Cui", "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "type": "Type", "negated": false, "hypothetical": true, "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "begin": 5, "end": 3, "score": 5, "timestamp": 9, "features": {"mapKey": "Inner"}, "hits": 4}}}], "subQueries": [{"href": "Href", "pageNumber": 10, "get_limit": 8, "totalDocumentCount": 18, "concepts": [{"ontology": "Ontology", "cui": "Cui", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "count": 5, "hitCount": 8, "score": 5, "parents": {"count": 5, "hits": 4}, "children": {"count": 5, "hits": 4}, "siblings": {"count": 5, "hits": 4}, "related": {"count": 5, "hits": 4}, "documentIds": ["DocumentIds"], "dataType": "DataType", "unit": "Unit", "operator": "Operator", "minValue": "MinValue", "maxValue": "MaxValue", "vocab": "Vocab", "properties": ["Properties"]}], "types": ["Types"], "attributes": [{"attributeId": "AttributeID", "displayName": "DisplayName", "count": 5}], "values": [{"ontology": "Ontology", "cui": "Cui", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "count": 5, "hitCount": 8, "score": 5, "parents": {"count": 5, "hits": 4}, "children": {"count": 5, "hits": 4}, "siblings": {"count": 5, "hits": 4}, "related": {"count": 5, "hits": 4}, "documentIds": ["DocumentIds"], "dataType": "DataType", "unit": "Unit", "operator": "Operator", "minValue": "MinValue", "maxValue": "MaxValue", "vocab": "Vocab", "properties": ["Properties"]}], "ranges": {"mapKey": {"operator": "Operator", "min": "Min", "max": "Max", "count": 5}}, "typeahead": [{"ontology": "Ontology", "cui": "Cui", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "count": 5, "hitCount": 8, "score": 5, "parents": {"count": 5, "hits": 4}, "children": {"count": 5, "hits": 4}, "siblings": {"count": 5, "hits": 4}, "related": {"count": 5, "hits": 4}, "documentIds": ["DocumentIds"], "dataType": "DataType", "unit": "Unit", "operator": "Operator", "minValue": "MinValue", "maxValue": "MaxValue", "vocab": "Vocab", "properties": ["Properties"]}], "aggregations": {"mapKey": [{"name": "Name", "documentCount": 13}]}, "dateHistograms": {"mapKey": [{"date": "Date", "hits": 4}]}, "qualifiers": [{"id": "ID", "name": "Name"}], "backend": {"messages": [{"messageType": "expanded_request", "url": "URL", "request": {"anyKey": "anyValue"}, "headers": ["Headers"], "status": 6, "response": {"anyKey": "anyValue"}}]}, "expandedQuery": {"anyKey": "anyValue"}, "parsedBoolExpression": {"boolExpression": "BoolExpression", "boolOperands": [{"boolOperand": "BoolOperand"}]}, "conceptsExist": {"mapKey": 5}, "cursorId": "CursorID", "vocabs": ["Vocabs"], "annotations": {"mapKey": {"unstructured": [{"text": "Text"}]}}, "metadata": {"corpus": "Corpus", "corpusDescription": "CorpusDescription", "fields": {"mapKey": ["Inner"]}}, "documents": [{"documentId": "DocumentID", "title": "Title", "metadata": {"mapKey": ["Inner"]}, "sectionName": "SectionName", "sectionId": "SectionID", "corpus": "Corpus", "links": {"hrefSearchMatches": "HrefSearchMatches", "hrefCategories": "HrefCategories"}, "passages": {"allPassages": [], "searchTermToPassages": {"mapKey": []}}, "annotations": {"mapKey": {"uniqueId": 8, "stickyIds": [9], "ontology": "Ontology", "section": "Section", "preferredName": "PreferredName", "cui": "Cui", "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "type": "Type", "negated": false, "hypothetical": true, "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "begin": 5, "end": 3, "score": 5, "timestamp": 9, "features": {"mapKey": "Inner"}, "hits": 4}}}], "subQueries": [{"href": "Href", "pageNumber": 10, "get_limit": 8, "totalDocumentCount": 18, "concepts": [{"ontology": "Ontology", "cui": "Cui", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "count": 5, "hitCount": 8, "score": 5, "documentIds": ["DocumentIds"], "dataType": "DataType", "unit": "Unit", "operator": "Operator", "minValue": "MinValue", "maxValue": "MaxValue", "vocab": "Vocab", "properties": ["Properties"]}], "types": ["Types"], "attributes": [{"attributeId": "AttributeID", "displayName": "DisplayName", "count": 5}], "values": [{"ontology": "Ontology", "cui": "Cui", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "count": 5, "hitCount": 8, "score": 5, "documentIds": ["DocumentIds"], "dataType": "DataType", "unit": "Unit", "operator": "Operator", "minValue": "MinValue", "maxValue": "MaxValue", "vocab": "Vocab", "properties": ["Properties"]}], "ranges": {"mapKey": {"operator": "Operator", "min": "Min", "max": "Max", "count": 5}}, "typeahead": [{"ontology": "Ontology", "cui": "Cui", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "count": 5, "hitCount": 8, "score": 5, "documentIds": ["DocumentIds"], "dataType": "DataType", "unit": "Unit", "operator": "Operator", "minValue": "MinValue", "maxValue": "MaxValue", "vocab": "Vocab", "properties": ["Properties"]}], "aggregations": {"mapKey": [{"name": "Name", "documentCount": 13}]}, "dateHistograms": {"mapKey": [{"date": "Date", "hits": 4}]}, "qualifiers": [{"id": "ID", "name": "Name"}], "backend": {"messages": []}, "expandedQuery": {"anyKey": "anyValue"}, "parsedBoolExpression": {"boolExpression": "BoolExpression", "boolOperands": []}, "conceptsExist": {"mapKey": 5}, "cursorId": "CursorID", "vocabs": ["Vocabs"], "annotations": {"mapKey": {"unstructured": []}}, "metadata": {"corpus": "Corpus", "corpusDescription": "CorpusDescription", "fields": {"mapKey": ["Inner"]}}, "documents": [{"documentId": "DocumentID", "title": "Title", "metadata": {"mapKey": ["Inner"]}, "sectionName": "SectionName", "sectionId": "SectionID", "corpus": "Corpus", "annotations": {"mapKey": null}}], "subQueries": [{"href": "Href", "pageNumber": 10, "get_limit": 8, "totalDocumentCount": 18, "concepts": [], "types": ["Types"], "attributes": [], "values": [], "ranges": {"mapKey": null}, "typeahead": [], "aggregations": {"mapKey": []}, "dateHistograms": {"mapKey": []}, "qualifiers": [], "expandedQuery": {"anyKey": "anyValue"}, "conceptsExist": {"mapKey": 5}, "cursorId": "CursorID", "vocabs": ["Vocabs"], "annotations": {"mapKey": null}, "documents": [], "subQueries": []}]}]}]}]}]}]}]}]}]}`)
			}))
			It(`Invoke Search successfully`, func() {
				defer testServer.Close()

				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
					Version:       core.StringPtr(version),
				})
				Expect(testServiceErr).To(BeNil())
				Expect(testService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := testService.Search(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the SearchOptions model
				searchOptionsModel := new(insightsformedicalliteratureservicev1.SearchOptions)
				searchOptionsModel.Corpus = core.StringPtr("testString")
				searchOptionsModel.Body = core.StringPtr("testString")
				searchOptionsModel.Verbose = core.BoolPtr(true)

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = testService.Search(searchOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())
			})
		})
	})
	Describe(`GetFields(getFieldsOptions *GetFieldsOptions)`, func() {
		version := "testString"
		getFieldsPath := "/v1/corpora/testString/search/metadata"
		Context(`Using mock server endpoint`, func() {
			testServer := httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
				defer GinkgoRecover()

				// Verify the contents of the request
				Expect(req.URL.Path).To(Equal(getFieldsPath))
				Expect(req.Method).To(Equal("GET"))
				Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))

				res.Header().Set("Content-type", "application/json")
				res.WriteHeader(200)
				fmt.Fprintf(res, `{"fields": {"mapKey": {"supports": ["Supports"]}}, "sectionFieldNames": ["SectionFieldNames"], "attrSectionFieldNames": ["AttrSectionFieldNames"], "qualifierSectionFieldNames": ["QualifierSectionFieldNames"], "meshSectionFieldNames": ["MeshSectionFieldNames"], "fieldIndexMap": {"mapKey": "Inner"}}`)
			}))
			It(`Invoke GetFields successfully`, func() {
				defer testServer.Close()

				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
					Version:       core.StringPtr(version),
				})
				Expect(testServiceErr).To(BeNil())
				Expect(testService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := testService.GetFields(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetFieldsOptions model
				getFieldsOptionsModel := new(insightsformedicalliteratureservicev1.GetFieldsOptions)
				getFieldsOptionsModel.Corpus = core.StringPtr("testString")

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = testService.GetFields(getFieldsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())
			})
		})
	})
	Describe(`Typeahead(typeaheadOptions *TypeaheadOptions)`, func() {
		version := "testString"
		typeaheadPath := "/v1/corpora/testString/search/typeahead"
		Context(`Using mock server endpoint`, func() {
			testServer := httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
				defer GinkgoRecover()

				// Verify the contents of the request
				Expect(req.URL.Path).To(Equal(typeaheadPath))
				Expect(req.Method).To(Equal("GET"))
				Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))

				Expect(req.URL.Query()["query"]).To(Equal([]string{"testString"}))

				Expect(req.URL.Query()["category"]).To(Equal([]string{"disorders"}))

				// TODO: Add check for verbose query parameter

				Expect(req.URL.Query()["_limit"]).To(Equal([]string{fmt.Sprint(int64(38))}))

				Expect(req.URL.Query()["max_hit_count"]).To(Equal([]string{fmt.Sprint(int64(38))}))

				// TODO: Add check for no_duplicates query parameter

				res.Header().Set("Content-type", "application/json")
				res.WriteHeader(200)
				fmt.Fprintf(res, `{"concepts": [{"cui": "Cui", "ontology": "Ontology", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "rank": 4, "hitCount": 8, "score": 5, "surfaceForms": ["SurfaceForms"]}]}`)
			}))
			It(`Invoke Typeahead successfully`, func() {
				defer testServer.Close()

				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
					Version:       core.StringPtr(version),
				})
				Expect(testServiceErr).To(BeNil())
				Expect(testService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := testService.Typeahead(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the TypeaheadOptions model
				typeaheadOptionsModel := new(insightsformedicalliteratureservicev1.TypeaheadOptions)
				typeaheadOptionsModel.Corpus = core.StringPtr("testString")
				typeaheadOptionsModel.Query = core.StringPtr("testString")
				typeaheadOptionsModel.Ontologies = []string{"concepts"}
				typeaheadOptionsModel.Types = []string{"testString"}
				typeaheadOptionsModel.Category = core.StringPtr("disorders")
				typeaheadOptionsModel.Verbose = core.BoolPtr(true)
				typeaheadOptionsModel.Limit = core.Int64Ptr(int64(38))
				typeaheadOptionsModel.MaxHitCount = core.Int64Ptr(int64(38))
				typeaheadOptionsModel.NoDuplicates = core.BoolPtr(true)

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = testService.Typeahead(typeaheadOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())
			})
		})
	})
	Describe(`Service constructor tests`, func() {
		version := "testString"
		It(`Instantiate service client`, func() {
			testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
				Authenticator: &core.NoAuthAuthenticator{},
				Version:       core.StringPtr(version),
			})
			Expect(testService).ToNot(BeNil())
			Expect(testServiceErr).To(BeNil())
		})
		It(`Instantiate service client with error: Invalid URL`, func() {
			testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
				URL:     "{{BAD_URL_STRING",
				Version: core.StringPtr(version),
			})
			Expect(testService).To(BeNil())
			Expect(testServiceErr).ToNot(BeNil())
		})
		It(`Instantiate service client with error: Invalid Auth`, func() {
			testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
				URL:     "https://insightsformedicalliteratureservicev1/api",
				Version: core.StringPtr(version),
				Authenticator: &core.BasicAuthenticator{
					Username: "",
					Password: "",
				},
			})
			Expect(testService).To(BeNil())
			Expect(testServiceErr).ToNot(BeNil())
		})
		It(`Instantiate service client with error: Validation Error`, func() {
			testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{})
			Expect(testService).To(BeNil())
			Expect(testServiceErr).ToNot(BeNil())
		})
	})
	Describe(`Service constructor tests using external config`, func() {
		version := "testString"
		Context(`Using external config, construct service client instances`, func() {
			// Map containing environment variables used in testing.
			var testEnvironment = map[string]string{
				"INSIGHTS_FOR_MEDICAL_LITERATURE_SERVICE_URL":       "https://insightsformedicalliteratureservicev1/api",
				"INSIGHTS_FOR_MEDICAL_LITERATURE_SERVICE_AUTH_TYPE": "noauth",
			}

			It(`Create service client using external config successfully`, func() {
				SetTestEnvironment(testEnvironment)
				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1UsingExternalConfig(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					Version: core.StringPtr(version),
				})
				Expect(testService).ToNot(BeNil())
				Expect(testServiceErr).To(BeNil())
				ClearTestEnvironment(testEnvironment)
			})
			It(`Create service client using external config and set url from constructor successfully`, func() {
				SetTestEnvironment(testEnvironment)
				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1UsingExternalConfig(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					URL:     "https://testService/api",
					Version: core.StringPtr(version),
				})
				Expect(testService).ToNot(BeNil())
				Expect(testServiceErr).To(BeNil())
				Expect(testService.Service.GetServiceURL()).To(Equal("https://testService/api"))
				ClearTestEnvironment(testEnvironment)
			})
			It(`Create service client using external config and set url programatically successfully`, func() {
				SetTestEnvironment(testEnvironment)
				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1UsingExternalConfig(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					Version: core.StringPtr(version),
				})
				err := testService.SetServiceURL("https://testService/api")
				Expect(err).To(BeNil())
				Expect(testService).ToNot(BeNil())
				Expect(testServiceErr).To(BeNil())
				Expect(testService.Service.GetServiceURL()).To(Equal("https://testService/api"))
				ClearTestEnvironment(testEnvironment)
			})
		})
		Context(`Using external config, construct service client instances with error: Invalid Auth`, func() {
			// Map containing environment variables used in testing.
			var testEnvironment = map[string]string{
				"INSIGHTS_FOR_MEDICAL_LITERATURE_SERVICE_URL":       "https://insightsformedicalliteratureservicev1/api",
				"INSIGHTS_FOR_MEDICAL_LITERATURE_SERVICE_AUTH_TYPE": "someOtherAuth",
			}

			SetTestEnvironment(testEnvironment)
			testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1UsingExternalConfig(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
				Version: core.StringPtr(version),
			})

			It(`Instantiate service client with error`, func() {
				Expect(testService).To(BeNil())
				Expect(testServiceErr).ToNot(BeNil())
				ClearTestEnvironment(testEnvironment)
			})
		})
		Context(`Using external config, construct service client instances with error: Invalid URL`, func() {
			// Map containing environment variables used in testing.
			var testEnvironment = map[string]string{
				"INSIGHTS_FOR_MEDICAL_LITERATURE_SERVICE_AUTH_TYPE": "NOAuth",
			}

			SetTestEnvironment(testEnvironment)
			testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1UsingExternalConfig(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
				URL:     "{{BAD_URL_STRING",
				Version: core.StringPtr(version),
			})

			It(`Instantiate service client with error`, func() {
				Expect(testService).To(BeNil())
				Expect(testServiceErr).ToNot(BeNil())
				ClearTestEnvironment(testEnvironment)
			})
		})
	})
	Describe(`GetConcepts(getConceptsOptions *GetConceptsOptions)`, func() {
		version := "testString"
		getConceptsPath := "/v1/corpora/testString/concepts"
		Context(`Using mock server endpoint`, func() {
			testServer := httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
				defer GinkgoRecover()

				// Verify the contents of the request
				Expect(req.URL.Path).To(Equal(getConceptsPath))
				Expect(req.Method).To(Equal("GET"))
				Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))

				// TODO: Add check for verbose query parameter

				Expect(req.URL.Query()["_sort"]).To(Equal([]string{"hitCount"}))

				Expect(req.URL.Query()["_limit"]).To(Equal([]string{fmt.Sprint(int64(38))}))

				res.Header().Set("Content-type", "application/json")
				res.WriteHeader(200)
				fmt.Fprintf(res, `{"concepts": [{"cui": "Cui", "ontology": "Ontology", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "rank": 4, "hitCount": 8, "score": 5, "surfaceForms": ["SurfaceForms"]}]}`)
			}))
			It(`Invoke GetConcepts successfully`, func() {
				defer testServer.Close()

				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
					Version:       core.StringPtr(version),
				})
				Expect(testServiceErr).To(BeNil())
				Expect(testService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := testService.GetConcepts(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetConceptsOptions model
				getConceptsOptionsModel := new(insightsformedicalliteratureservicev1.GetConceptsOptions)
				getConceptsOptionsModel.Corpus = core.StringPtr("testString")
				getConceptsOptionsModel.Cuis = []string{"testString"}
				getConceptsOptionsModel.PreferredNames = []string{"testString"}
				getConceptsOptionsModel.SurfaceForms = []string{"testString"}
				getConceptsOptionsModel.Attributes = []string{"testString"}
				getConceptsOptionsModel.Verbose = core.BoolPtr(true)
				getConceptsOptionsModel.Sort = core.StringPtr("hitCount")
				getConceptsOptionsModel.Limit = core.Int64Ptr(int64(38))

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = testService.GetConcepts(getConceptsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())
			})
		})
	})
	Describe(`AddArtifact(addArtifactOptions *AddArtifactOptions)`, func() {
		version := "testString"
		addArtifactPath := "/v1/corpora/testString/concepts/definitions"
		Context(`Using mock server endpoint`, func() {
			testServer := httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
				defer GinkgoRecover()

				// Verify the contents of the request
				Expect(req.URL.Path).To(Equal(addArtifactPath))
				Expect(req.Method).To(Equal("POST"))
				Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))

				res.WriteHeader(200)
			}))
			It(`Invoke AddArtifact successfully`, func() {
				defer testServer.Close()

				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
					Version:       core.StringPtr(version),
				})
				Expect(testServiceErr).To(BeNil())
				Expect(testService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := testService.AddArtifact(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the PossbileValues model
				possbileValuesModel := new(insightsformedicalliteratureservicev1.PossbileValues)
				possbileValuesModel.DisplayValue = core.StringPtr("testString")
				possbileValuesModel.Value = core.StringPtr("testString")

				// Construct an instance of the AttributeEntry model
				attributeEntryModel := new(insightsformedicalliteratureservicev1.AttributeEntry)
				attributeEntryModel.AttrName = core.StringPtr("testString")
				attributeEntryModel.DataType = core.StringPtr("testString")
				attributeEntryModel.DefaultValue = core.StringPtr("testString")
				attributeEntryModel.Description = core.StringPtr("testString")
				attributeEntryModel.DisplayName = core.StringPtr("testString")
				attributeEntryModel.DocID = core.StringPtr("testString")
				attributeEntryModel.FieldValues = []string{"testString"}
				attributeEntryModel.MaximumValue = core.StringPtr("testString")
				attributeEntryModel.MinimumValue = core.StringPtr("testString")
				attributeEntryModel.MultiValue = core.BoolPtr(true)
				attributeEntryModel.Units = core.StringPtr("testString")
				attributeEntryModel.ValueType = core.StringPtr("testString")
				attributeEntryModel.PossibleValues = []insightsformedicalliteratureservicev1.PossbileValues{*possbileValuesModel}

				// Construct an instance of the DictonaryEntry model
				dictonaryEntryModel := new(insightsformedicalliteratureservicev1.DictonaryEntry)
				dictonaryEntryModel.Children = []string{"testString"}
				dictonaryEntryModel.Cui = core.StringPtr("testString")
				dictonaryEntryModel.Definition = []string{"testString"}
				dictonaryEntryModel.Parents = []string{"testString"}
				dictonaryEntryModel.PreferredName = core.StringPtr("testString")
				dictonaryEntryModel.Semtypes = []string{"testString"}
				dictonaryEntryModel.Siblings = []string{"testString"}
				dictonaryEntryModel.SurfaceForms = []string{"testString"}
				dictonaryEntryModel.Variants = []string{"testString"}
				dictonaryEntryModel.Vocab = core.StringPtr("testString")
				dictonaryEntryModel.Related = []string{"testString"}
				dictonaryEntryModel.Source = core.StringPtr("testString")
				dictonaryEntryModel.SourceVersion = core.StringPtr("testString")

				// Construct an instance of the AddArtifactOptions model
				addArtifactOptionsModel := new(insightsformedicalliteratureservicev1.AddArtifactOptions)
				addArtifactOptionsModel.Corpus = core.StringPtr("testString")
				addArtifactOptionsModel.DictionaryEntry = dictonaryEntryModel
				addArtifactOptionsModel.AttributeEntry = attributeEntryModel

				// Invoke operation with valid options model (positive test)
				response, operationErr = testService.AddArtifact(addArtifactOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
		})
	})
	Describe(`GetCuiInfo(getCuiInfoOptions *GetCuiInfoOptions)`, func() {
		version := "testString"
		getCuiInfoPath := "/v1/corpora/testString/concepts/testString"
		Context(`Using mock server endpoint`, func() {
			testServer := httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
				defer GinkgoRecover()

				// Verify the contents of the request
				Expect(req.URL.Path).To(Equal(getCuiInfoPath))
				Expect(req.Method).To(Equal("GET"))
				Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))

				Expect(req.URL.Query()["ontology"]).To(Equal([]string{"testString"}))

				Expect(req.URL.Query()["_fields"]).To(Equal([]string{"testString"}))

				// TODO: Add check for tree_layout query parameter

				res.Header().Set("Content-type", "application/json")
				res.WriteHeader(200)
				fmt.Fprintf(res, `{"cui": "Cui", "ontology": "Ontology", "preferredName": "PreferredName", "semanticTypes": ["SemanticTypes"], "surfaceForms": ["SurfaceForms"], "definition": "Definition", "hasParents": true, "hasChildren": false, "hasSiblings": false}`)
			}))
			It(`Invoke GetCuiInfo successfully`, func() {
				defer testServer.Close()

				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
					Version:       core.StringPtr(version),
				})
				Expect(testServiceErr).To(BeNil())
				Expect(testService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := testService.GetCuiInfo(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetCuiInfoOptions model
				getCuiInfoOptionsModel := new(insightsformedicalliteratureservicev1.GetCuiInfoOptions)
				getCuiInfoOptionsModel.Corpus = core.StringPtr("testString")
				getCuiInfoOptionsModel.NameOrID = core.StringPtr("testString")
				getCuiInfoOptionsModel.Ontology = core.StringPtr("testString")
				getCuiInfoOptionsModel.Fields = core.StringPtr("testString")
				getCuiInfoOptionsModel.TreeLayout = core.BoolPtr(true)

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = testService.GetCuiInfo(getCuiInfoOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())
			})
		})
	})
	Describe(`GetHitCount(getHitCountOptions *GetHitCountOptions)`, func() {
		version := "testString"
		getHitCountPath := "/v1/corpora/testString/concepts/testString/hit_count"
		Context(`Using mock server endpoint`, func() {
			testServer := httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
				defer GinkgoRecover()

				// Verify the contents of the request
				Expect(req.URL.Path).To(Equal(getHitCountPath))
				Expect(req.Method).To(Equal("GET"))
				Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))

				Expect(req.URL.Query()["ontology"]).To(Equal([]string{"testString"}))

				res.Header().Set("Content-type", "application/json")
				res.WriteHeader(200)
				fmt.Fprintf(res, `{"hitCount": 8}`)
			}))
			It(`Invoke GetHitCount successfully`, func() {
				defer testServer.Close()

				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
					Version:       core.StringPtr(version),
				})
				Expect(testServiceErr).To(BeNil())
				Expect(testService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := testService.GetHitCount(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetHitCountOptions model
				getHitCountOptionsModel := new(insightsformedicalliteratureservicev1.GetHitCountOptions)
				getHitCountOptionsModel.Corpus = core.StringPtr("testString")
				getHitCountOptionsModel.NameOrID = core.StringPtr("testString")
				getHitCountOptionsModel.Ontology = core.StringPtr("testString")

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = testService.GetHitCount(getHitCountOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())
			})
		})
	})
	Describe(`GetRelatedConcepts(getRelatedConceptsOptions *GetRelatedConceptsOptions)`, func() {
		version := "testString"
		getRelatedConceptsPath := "/v1/corpora/testString/concepts/testString/related_concepts"
		Context(`Using mock server endpoint`, func() {
			testServer := httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
				defer GinkgoRecover()

				// Verify the contents of the request
				Expect(req.URL.Path).To(Equal(getRelatedConceptsPath))
				Expect(req.Method).To(Equal("GET"))
				Expect(req.URL.Query()["relationship"]).To(Equal([]string{"children"}))

				Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))

				Expect(req.URL.Query()["ontology"]).To(Equal([]string{"testString"}))

				// TODO: Add check for recursive query parameter

				// TODO: Add check for tree_layout query parameter

				Expect(req.URL.Query()["max_depth"]).To(Equal([]string{fmt.Sprint(int64(38))}))

				res.Header().Set("Content-type", "application/json")
				res.WriteHeader(200)
				fmt.Fprintf(res, `{"concepts": [{"cui": "Cui", "ontology": "Ontology", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "rank": 4, "hitCount": 8, "score": 5, "surfaceForms": ["SurfaceForms"], "nextConcepts": [{"cui": "Cui", "ontology": "Ontology", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "rank": 4, "hitCount": 8, "score": 5, "surfaceForms": ["SurfaceForms"], "nextConcepts": [{"cui": "Cui", "ontology": "Ontology", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "rank": 4, "hitCount": 8, "score": 5, "surfaceForms": ["SurfaceForms"], "nextConcepts": [{"cui": "Cui", "ontology": "Ontology", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "rank": 4, "hitCount": 8, "score": 5, "surfaceForms": ["SurfaceForms"], "nextConcepts": [{"cui": "Cui", "ontology": "Ontology", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "rank": 4, "hitCount": 8, "score": 5, "surfaceForms": ["SurfaceForms"], "nextConcepts": [{"cui": "Cui", "ontology": "Ontology", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "rank": 4, "hitCount": 8, "score": 5, "surfaceForms": ["SurfaceForms"], "nextConcepts": [{"cui": "Cui", "ontology": "Ontology", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "rank": 4, "hitCount": 8, "score": 5, "surfaceForms": ["SurfaceForms"], "nextConcepts": [{"cui": "Cui", "ontology": "Ontology", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "rank": 4, "hitCount": 8, "score": 5, "surfaceForms": ["SurfaceForms"], "nextConcepts": [{"cui": "Cui", "ontology": "Ontology", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "rank": 4, "hitCount": 8, "score": 5, "surfaceForms": ["SurfaceForms"], "nextConcepts": []}]}]}]}]}]}]}]}]}]}`)
			}))
			It(`Invoke GetRelatedConcepts successfully`, func() {
				defer testServer.Close()

				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
					Version:       core.StringPtr(version),
				})
				Expect(testServiceErr).To(BeNil())
				Expect(testService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := testService.GetRelatedConcepts(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetRelatedConceptsOptions model
				getRelatedConceptsOptionsModel := new(insightsformedicalliteratureservicev1.GetRelatedConceptsOptions)
				getRelatedConceptsOptionsModel.Corpus = core.StringPtr("testString")
				getRelatedConceptsOptionsModel.NameOrID = core.StringPtr("testString")
				getRelatedConceptsOptionsModel.Relationship = core.StringPtr("children")
				getRelatedConceptsOptionsModel.Ontology = core.StringPtr("testString")
				getRelatedConceptsOptionsModel.RelationshipAttributes = []string{"testString"}
				getRelatedConceptsOptionsModel.Sources = []string{"testString"}
				getRelatedConceptsOptionsModel.Recursive = core.BoolPtr(true)
				getRelatedConceptsOptionsModel.TreeLayout = core.BoolPtr(true)
				getRelatedConceptsOptionsModel.MaxDepth = core.Int64Ptr(int64(38))

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = testService.GetRelatedConcepts(getRelatedConceptsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())
			})
		})
	})
	Describe(`GetSimilarConcepts(getSimilarConceptsOptions *GetSimilarConceptsOptions)`, func() {
		version := "testString"
		getSimilarConceptsPath := "/v1/corpora/testString/concepts/testString/similar_concepts"
		Context(`Using mock server endpoint`, func() {
			testServer := httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
				defer GinkgoRecover()

				// Verify the contents of the request
				Expect(req.URL.Path).To(Equal(getSimilarConceptsPath))
				Expect(req.Method).To(Equal("GET"))
				Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))

				Expect(req.URL.Query()["ontology"]).To(Equal([]string{"testString"}))

				Expect(req.URL.Query()["_limit"]).To(Equal([]string{fmt.Sprint(int64(38))}))

				res.Header().Set("Content-type", "application/json")
				res.WriteHeader(200)
				fmt.Fprintf(res, `{"concepts": [{"cui": "Cui", "ontology": "Ontology", "preferredName": "PreferredName", "alternativeName": "AlternativeName", "semanticType": "SemanticType", "rank": 4, "hitCount": 8, "score": 5, "surfaceForms": ["SurfaceForms"]}]}`)
			}))
			It(`Invoke GetSimilarConcepts successfully`, func() {
				defer testServer.Close()

				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
					Version:       core.StringPtr(version),
				})
				Expect(testServiceErr).To(BeNil())
				Expect(testService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := testService.GetSimilarConcepts(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetSimilarConceptsOptions model
				getSimilarConceptsOptionsModel := new(insightsformedicalliteratureservicev1.GetSimilarConceptsOptions)
				getSimilarConceptsOptionsModel.Corpus = core.StringPtr("testString")
				getSimilarConceptsOptionsModel.NameOrID = core.StringPtr("testString")
				getSimilarConceptsOptionsModel.ReturnOntologies = []string{"testString"}
				getSimilarConceptsOptionsModel.Ontology = core.StringPtr("testString")
				getSimilarConceptsOptionsModel.Limit = core.Int64Ptr(int64(38))

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = testService.GetSimilarConcepts(getSimilarConceptsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())
			})
		})
	})
	Describe(`Service constructor tests`, func() {
		version := "testString"
		It(`Instantiate service client`, func() {
			testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
				Authenticator: &core.NoAuthAuthenticator{},
				Version:       core.StringPtr(version),
			})
			Expect(testService).ToNot(BeNil())
			Expect(testServiceErr).To(BeNil())
		})
		It(`Instantiate service client with error: Invalid URL`, func() {
			testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
				URL:     "{{BAD_URL_STRING",
				Version: core.StringPtr(version),
			})
			Expect(testService).To(BeNil())
			Expect(testServiceErr).ToNot(BeNil())
		})
		It(`Instantiate service client with error: Invalid Auth`, func() {
			testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
				URL:     "https://insightsformedicalliteratureservicev1/api",
				Version: core.StringPtr(version),
				Authenticator: &core.BasicAuthenticator{
					Username: "",
					Password: "",
				},
			})
			Expect(testService).To(BeNil())
			Expect(testServiceErr).ToNot(BeNil())
		})
		It(`Instantiate service client with error: Validation Error`, func() {
			testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{})
			Expect(testService).To(BeNil())
			Expect(testServiceErr).ToNot(BeNil())
		})
	})
	Describe(`Service constructor tests using external config`, func() {
		version := "testString"
		Context(`Using external config, construct service client instances`, func() {
			// Map containing environment variables used in testing.
			var testEnvironment = map[string]string{
				"INSIGHTS_FOR_MEDICAL_LITERATURE_SERVICE_URL":       "https://insightsformedicalliteratureservicev1/api",
				"INSIGHTS_FOR_MEDICAL_LITERATURE_SERVICE_AUTH_TYPE": "noauth",
			}

			It(`Create service client using external config successfully`, func() {
				SetTestEnvironment(testEnvironment)
				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1UsingExternalConfig(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					Version: core.StringPtr(version),
				})
				Expect(testService).ToNot(BeNil())
				Expect(testServiceErr).To(BeNil())
				ClearTestEnvironment(testEnvironment)
			})
			It(`Create service client using external config and set url from constructor successfully`, func() {
				SetTestEnvironment(testEnvironment)
				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1UsingExternalConfig(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					URL:     "https://testService/api",
					Version: core.StringPtr(version),
				})
				Expect(testService).ToNot(BeNil())
				Expect(testServiceErr).To(BeNil())
				Expect(testService.Service.GetServiceURL()).To(Equal("https://testService/api"))
				ClearTestEnvironment(testEnvironment)
			})
			It(`Create service client using external config and set url programatically successfully`, func() {
				SetTestEnvironment(testEnvironment)
				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1UsingExternalConfig(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					Version: core.StringPtr(version),
				})
				err := testService.SetServiceURL("https://testService/api")
				Expect(err).To(BeNil())
				Expect(testService).ToNot(BeNil())
				Expect(testServiceErr).To(BeNil())
				Expect(testService.Service.GetServiceURL()).To(Equal("https://testService/api"))
				ClearTestEnvironment(testEnvironment)
			})
		})
		Context(`Using external config, construct service client instances with error: Invalid Auth`, func() {
			// Map containing environment variables used in testing.
			var testEnvironment = map[string]string{
				"INSIGHTS_FOR_MEDICAL_LITERATURE_SERVICE_URL":       "https://insightsformedicalliteratureservicev1/api",
				"INSIGHTS_FOR_MEDICAL_LITERATURE_SERVICE_AUTH_TYPE": "someOtherAuth",
			}

			SetTestEnvironment(testEnvironment)
			testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1UsingExternalConfig(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
				Version: core.StringPtr(version),
			})

			It(`Instantiate service client with error`, func() {
				Expect(testService).To(BeNil())
				Expect(testServiceErr).ToNot(BeNil())
				ClearTestEnvironment(testEnvironment)
			})
		})
		Context(`Using external config, construct service client instances with error: Invalid URL`, func() {
			// Map containing environment variables used in testing.
			var testEnvironment = map[string]string{
				"INSIGHTS_FOR_MEDICAL_LITERATURE_SERVICE_AUTH_TYPE": "NOAuth",
			}

			SetTestEnvironment(testEnvironment)
			testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1UsingExternalConfig(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
				URL:     "{{BAD_URL_STRING",
				Version: core.StringPtr(version),
			})

			It(`Instantiate service client with error`, func() {
				Expect(testService).To(BeNil())
				Expect(testServiceErr).ToNot(BeNil())
				ClearTestEnvironment(testEnvironment)
			})
		})
	})
	Describe(`Tokenize(tokenizeOptions *TokenizeOptions)`, func() {
		version := "testString"
		tokenizePath := "/v1/corpora/testString/debug/analyze/testString"
		Context(`Using mock server endpoint`, func() {
			testServer := httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
				defer GinkgoRecover()

				// Verify the contents of the request
				Expect(req.URL.Path).To(Equal(tokenizePath))
				Expect(req.Method).To(Equal("POST"))
				Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))

				Expect(req.URL.Query()["max_words"]).To(Equal([]string{fmt.Sprint(int64(38))}))

				res.Header().Set("Content-type", "application/json")
				res.WriteHeader(200)
				fmt.Fprintf(res, `{"unstructured": [{"text": "Text", "data": {"concepts": [{"uniqueId": 8, "stickyIds": [9], "section": "Section", "type": "Type", "begin": 5, "end": 3, "coveredText": "CoveredText", "cui": "Cui", "preferredName": "PreferredName", "source": "Source", "negated": false, "hypothetical": true, "timestamp": 9, "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "features": {"mapKey": "Inner"}, "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "hits": 4}], "attributeValues": [{"uniqueId": 8, "stickyIds": [9], "section": "Section", "type": "Type", "begin": 5, "end": 3, "coveredText": "CoveredText", "cui": "Cui", "preferredName": "PreferredName", "source": "Source", "negated": false, "hypothetical": true, "timestamp": 9, "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "features": {"mapKey": "Inner"}, "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "hits": 4}], "relations": [{"relationId": "RelationID", "relation": "Relation", "source": {"section": "Section", "begin": 5, "end": 3, "coveredText": "CoveredText", "source": "Source", "type": "Type"}, "target": {"section": "Section", "begin": 5, "end": 3, "coveredText": "CoveredText", "source": "Source", "type": "Type"}}], "mesh": [{"uniqueId": 8, "stickyIds": [9], "section": "Section", "type": "Type", "begin": 5, "end": 3, "coveredText": "CoveredText", "cui": "Cui", "preferredName": "PreferredName", "source": "Source", "negated": false, "hypothetical": true, "timestamp": 9, "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "features": {"mapKey": "Inner"}, "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "hits": 4}], "text": [{"uniqueId": 8, "stickyIds": [9], "section": "Section", "type": "Type", "begin": 5, "end": 3, "coveredText": "CoveredText", "cui": "Cui", "preferredName": "PreferredName", "source": "Source", "negated": false, "hypothetical": true, "timestamp": 9, "attributeId": "AttributeID", "qualifiers": ["Qualifiers"], "unit": "Unit", "minValue": "MinValue", "maxValue": "MaxValue", "operator": "Operator", "features": {"mapKey": "Inner"}, "nluEntityIndex": "NluEntityIndex", "nluMentionIndex": "NluMentionIndex", "nluRelationId": "NluRelationID", "nluSide": "NluSide", "nluSourceType": "NluSourceType", "nluRelation": "NluRelation", "nluTargetType": "NluTargetType", "hits": 4}]}}]}`)
			}))
			It(`Invoke Tokenize successfully`, func() {
				defer testServer.Close()

				testService, testServiceErr := insightsformedicalliteratureservicev1.NewInsightsForMedicalLiteratureServiceV1(&insightsformedicalliteratureservicev1.InsightsForMedicalLiteratureServiceV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
					Version:       core.StringPtr(version),
				})
				Expect(testServiceErr).To(BeNil())
				Expect(testService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := testService.Tokenize(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the TokenizeOptions model
				tokenizeOptionsModel := new(insightsformedicalliteratureservicev1.TokenizeOptions)
				tokenizeOptionsModel.Corpus = core.StringPtr("testString")
				tokenizeOptionsModel.Flow = core.StringPtr("testString")
				tokenizeOptionsModel.Body = core.StringPtr("testString")
				tokenizeOptionsModel.Ontologies = []string{"mesh"}
				tokenizeOptionsModel.MaxWords = core.Int64Ptr(int64(38))

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = testService.Tokenize(tokenizeOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())
			})
		})
	})
	Describe(`Utility function tests`, func() {
		It(`Invoke CreateMockMap() successfully`, func() {
			mockMap := CreateMockMap()
			Expect(mockMap).ToNot(BeNil())
		})
		It(`Invoke CreateMockByteArray() successfully`, func() {
			mockByteArray := CreateMockByteArray("This is a test")
			Expect(mockByteArray).ToNot(BeNil())
		})
		It(`Invoke CreateMockUUID() successfully`, func() {
			mockUUID := CreateMockUUID("9fab83da-98cb-4f18-a7ba-b6f0435c9673")
			Expect(mockUUID).ToNot(BeNil())
		})
		It(`Invoke CreateMockReader() successfully`, func() {
			mockReader := CreateMockReader("This is a test.")
			Expect(mockReader).ToNot(BeNil())
		})
		It(`Invoke CreateMockDate() successfully`, func() {
			mockDate := CreateMockDate()
			Expect(mockDate).ToNot(BeNil())
		})
		It(`Invoke CreateMockDateTime() successfully`, func() {
			mockDateTime := CreateMockDateTime()
			Expect(mockDateTime).ToNot(BeNil())
		})
	})
})

//
// Utility functions used by the generated test code
//

func CreateMockMap() map[string]interface{} {
	m := make(map[string]interface{})
	return m
}

func CreateMockByteArray(mockData string) *[]byte {
	ba := make([]byte, len(mockData))
	ba = append(ba, mockData...)
	return &ba
}

func CreateMockUUID(mockData string) *strfmt.UUID {
	uuid := strfmt.UUID(mockData)
	return &uuid
}

func CreateMockReader(mockData string) io.ReadCloser {
	return ioutil.NopCloser(bytes.NewReader([]byte(mockData)))
}

func CreateMockDate() *strfmt.Date {
	d := strfmt.Date(time.Now())
	return &d
}

func CreateMockDateTime() *strfmt.DateTime {
	d := strfmt.DateTime(time.Now())
	return &d
}

func SetTestEnvironment(testEnvironment map[string]string) {
	for key, value := range testEnvironment {
		os.Setenv(key, value)
	}
}

func ClearTestEnvironment(testEnvironment map[string]string) {
	for key := range testEnvironment {
		os.Unsetenv(key)
	}
}

/**
 * (C) Copyright IBM Corp. 2020.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package insightsformedicalliteratureservicev1 : Operations and models for the InsightsForMedicalLiteratureServiceV1 service
package insightsformedicalliteratureservicev1

import (
	"encoding/json"
	"fmt"
	"github.com/IBM/go-sdk-core/v3/core"
	common "github.com/IBM/whcs-go-sdk/common"
	"strings"
)

// InsightsForMedicalLiteratureServiceV1 : For more information see the <a href='../../documentation'
// target='_blank'>extended documentation</a>.<p>Try the <a href='../../application'>Insights for Medical Literature
// demo application</a>.<h3>Service Overview</h3>The Insights for Medical Literature service provides APIs that enable
// you to derive insights from a corpus of medical documents. For example, the <a
// href='https://www.nlm.nih.gov/bsd/pmresources.html' target='_blank'>MEDLINE&reg;</a> corpus contains more than 26
// million references to medical journal articles.  An unstructured medical document corpus is ingested by IBM, enriched
// with the Unified Medical Language System (<a href='https://www.nlm.nih.gov/research/umls/'
// target='_blank'>UMLS&reg;</a>) and stored as structured data in an IBM managed database.  The UMLS enrichment enables
// a concept based search, in addition to a conventional text search.  Other unique features include concept matching,
// concept relationships, identifying co-occurring concepts and identifying disorders, drugs, genes and other medical
// terms mentioned in a medical document.<h3>National Library of Medicine&reg; (NLM&reg;) License</h3>The MEDLINE corpus
// is imported from <a href='https://www.nlm.nih.gov/databases/journal.html'
// target='_blank'>MEDLINE&reg;/PubMed&reg;</a>, a database of the U.S. National Library of Medicine. <P><P>The MEDLINE
// corpus is periodically updated to contain new and/or maintained records, and remove deleted records, at least once
// every thirty (30) days. The MEDLINE corpus may be updated on a weekly basis.<P><P>NLM represents that its data were
// formulated with a reasonable standard of care.  Except for this representation, NLM makes no representation or
// warranties, expressed or implied.  This includes, but is not limited to, any implied warranty of merchantability or
// fitness for a particular purpose, with respect to the NLM data, and NLM specifically disclaims any such warranties
// and representations.<P><P>All complete or parts of U.S. National Library of Medicine (NLM) records that are
// redistributed or retransmitted must be identified as being derived from NLM  data.<h3>API Overview</h3>The APIs are
// grouped into these categories:<UL><LI><B>Concepts</B> : Concept information</LI><P>Concept information includes a
// concept unique identifier (CUI), preferred name, alternative name (other surface forms), semantic group (category),
// semantic types, counts (hits, parents, children, siblings...) and, related concepts. <LI><B>Corpora</B> : Corpora
// information</LI><P>You can retrieve a list of corpus names.  For each corpus a unique list of semantic groups and
// semantic types is provided. <LI><B>Documents</B> : Document information</LI><P>These APIs enable full text documents
// and document annotations to be retreived.  Concepts mentioned in a medical document may also be categorized by
// semantic groups and types.  The best matching search concepts can also be identified in a medical
// document.<LI><B>Search</B> : Concept search</LI><P>These APIs perform typeahead concept searches, ranked document
// searches, and cohesive and co-occurring concept searches.  A search targets a single medical document
// corpus.<LI><B>Status</B> : Check the status of this service</LI></UL><h3>Terminology</h3><UL><LI><B>Concept Unique
// Identifier (cui)</B></LI>A UMLS CUI identifies a concept, and is specified as a path or query parameter to select a
// specific concept.  A CUI always begins with an uppercase letter 'C' followed by seven decimal digits (e.g.,
// C0446516).<LI><B>Document Identifiter</B></LI>A document ID uniquely identifies a document in a corpus, and is
// specified as a path or query parameter to select a specific medical document.<LI><B>Hit count</B></LI>A hit count
// specifies the number of times a specific concept is mentioned in a corpus.<LI><B>Preferred Name (pn)</B></LI>A
// preferred name is the common name for a concept.  A concept may also have other surface forms or alternative
// names.<LI><B>Semantic Group (group)</B></LI>A semantic group aggregates multiple semantic types, and is specified as
// a path or query parameter to filter or select concepts belonging to the same semantic group (e.g., Disorders or
// ChemicalsAndDrugs).<LI><B>Semantic Type (type)</B></LI>A semantic type is a camelcase string derived from a UMLS
// semantic type (e.g., ClinicalDrug or DiseaseOrSyndrome). It is specified as a path or query parameter to filter or
// select concepts belonging to the same category (semantic type).<LI><B>Surface form</B></LI>A surface form is an
// alternative name for a concept.  The surface forms identify text spans in a medical document, and the identified text
// spans are annotated with the matching CUI, preferred name and semantic type.</UL><h3>Typical Document Search
// Flow</h3><p>1. <b>GET /v1/corpora</b> - Get list of all available corpus names<p>2. <b>GET
// /v1/corpora/corpus_name/search/typeahead</b> - Use typeahead to select search concepts<p>3. <b>GET
// /v1/corpora/corpus_name/search/cooccurring_concepts</b> - Find additional co-occurring search concepts<p>4. <b>GET
// /v1/corpora/corpus_name/concepts/{cui}/matching_concepts</b> - Find additional matching search concepts<p>5. <b>GET
// /v1/corpora/corpus_name/concepts/{cui}/related_concepts</b> - Find additional related search concepts<p>6. <b>GET
// /v1/corpora/corpus_name/search/ranked_documents</b> - Search for ranked documents matching search concepts<p>7.
// <b>GET /v1/corpora/corpus_name/documents/{document_id}/search_matches</b> - Highlight matching search concepts in a
// ranked documents<p>8. <b>GET /v1/corpora/corpus_name/documents/{document_id}/categories</b> - Highlight diseases,
// drugs and genes in a ranked document
//
// Version: 1.0.0 2020-04-20T09:05:55Z
type InsightsForMedicalLiteratureServiceV1 struct {
	Service *core.BaseService

	// The release date of the version of the API you want to use. Specify dates in YYYY-MM-DD format.
	Version *string
}

// DefaultServiceURL is the default URL to make service requests to.
const DefaultServiceURL = "https://insights-for-medical-literature-service.cloud.ibm.com/services/medical_insights/api"

// DefaultServiceName is the default key used to find external configuration information.
const DefaultServiceName = "insights_for_medical_literature_service"

// InsightsForMedicalLiteratureServiceV1Options : Service options
type InsightsForMedicalLiteratureServiceV1Options struct {
	ServiceName   string
	URL           string
	Authenticator core.Authenticator

	// The release date of the version of the API you want to use. Specify dates in YYYY-MM-DD format.
	Version *string `validate:"required"`
}

// NewInsightsForMedicalLiteratureServiceV1UsingExternalConfig : constructs an instance of InsightsForMedicalLiteratureServiceV1 with passed in options and external configuration.
func NewInsightsForMedicalLiteratureServiceV1UsingExternalConfig(options *InsightsForMedicalLiteratureServiceV1Options) (insightsForMedicalLiteratureService *InsightsForMedicalLiteratureServiceV1, err error) {
	if options.ServiceName == "" {
		options.ServiceName = DefaultServiceName
	}

	if options.Authenticator == nil {
		options.Authenticator, err = core.GetAuthenticatorFromEnvironment(options.ServiceName)
		if err != nil {
			return
		}
	}

	insightsForMedicalLiteratureService, err = NewInsightsForMedicalLiteratureServiceV1(options)
	if err != nil {
		return
	}

	err = insightsForMedicalLiteratureService.Service.ConfigureService(options.ServiceName)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = insightsForMedicalLiteratureService.Service.SetServiceURL(options.URL)
	}
	return
}

// NewInsightsForMedicalLiteratureServiceV1 : constructs an instance of InsightsForMedicalLiteratureServiceV1 with passed in options.
func NewInsightsForMedicalLiteratureServiceV1(options *InsightsForMedicalLiteratureServiceV1Options) (service *InsightsForMedicalLiteratureServiceV1, err error) {
	serviceOptions := &core.ServiceOptions{
		URL:           DefaultServiceURL,
		Authenticator: options.Authenticator,
	}

	err = core.ValidateStruct(options, "options")
	if err != nil {
		return
	}

	baseService, err := core.NewBaseService(serviceOptions)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = baseService.SetServiceURL(options.URL)
		if err != nil {
			return
		}
	}

	service = &InsightsForMedicalLiteratureServiceV1{
		Service: baseService,
		Version: options.Version,
	}

	return
}

// SetServiceURL sets the service URL
func (insightsForMedicalLiteratureService *InsightsForMedicalLiteratureServiceV1) SetServiceURL(url string) error {
	return insightsForMedicalLiteratureService.Service.SetServiceURL(url)
}

// GetDocuments : Retrieves information about the documents in this corpus
// The response returns the following information: <ul><li>number of documents in the corpus</li><li>corpus
// provider</li></ul>.
func (insightsForMedicalLiteratureService *InsightsForMedicalLiteratureServiceV1) GetDocuments(getDocumentsOptions *GetDocumentsOptions) (result *CorpusInfoModel, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getDocumentsOptions, "getDocumentsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getDocumentsOptions, "getDocumentsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"v1/corpora", "documents"}
	pathParameters := []string{*getDocumentsOptions.Corpus}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(insightsForMedicalLiteratureService.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getDocumentsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("insights_for_medical_literature_service", "V1", "GetDocuments")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*insightsForMedicalLiteratureService.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = insightsForMedicalLiteratureService.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalCorpusInfoModel(m)
		response.Result = result
	}

	return
}

// AddCorpusDocument : Define enrichment document
// The response returns whether the document was properly added to the corpus.  <P>This API should be used for adding a
// document to a custom corpus.<P>Example POST body:<pre>{
//   "acdUrl" :
//   "acdApiKeyl" :
//   "flowId" :
//   "document" : {
//    "doc_id" :
//    "field[n]" : "value"
//   }
//   "otherAnnotators" : [   "{    "annotatorUrl    "annotatorApiKey    "containerName   "}  ]
// }
// </pre>.
func (insightsForMedicalLiteratureService *InsightsForMedicalLiteratureServiceV1) AddCorpusDocument(addCorpusDocumentOptions *AddCorpusDocumentOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(addCorpusDocumentOptions, "addCorpusDocumentOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(addCorpusDocumentOptions, "addCorpusDocumentOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"v1/corpora", "documents"}
	pathParameters := []string{*addCorpusDocumentOptions.Corpus}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(insightsForMedicalLiteratureService.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range addCorpusDocumentOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("insights_for_medical_literature_service", "V1", "AddCorpusDocument")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*insightsForMedicalLiteratureService.Version))

	body := make(map[string]interface{})
	if addCorpusDocumentOptions.Document != nil {
		body["document"] = addCorpusDocumentOptions.Document
	}
	if addCorpusDocumentOptions.AcdURL != nil {
		body["acdUrl"] = addCorpusDocumentOptions.AcdURL
	}
	if addCorpusDocumentOptions.ApiKey != nil {
		body["apiKey"] = addCorpusDocumentOptions.ApiKey
	}
	if addCorpusDocumentOptions.FlowID != nil {
		body["flowId"] = addCorpusDocumentOptions.FlowID
	}
	if addCorpusDocumentOptions.AccessToken != nil {
		body["accessToken"] = addCorpusDocumentOptions.AccessToken
	}
	if addCorpusDocumentOptions.OtherAnnotators != nil {
		body["otherAnnotators"] = addCorpusDocumentOptions.OtherAnnotators
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = insightsForMedicalLiteratureService.Service.Request(request, nil)

	return
}

// GetDocumentInfo : Retrieves the external ID, title, abstract and text for a document
// The response may return the following fields:<ul><li>external ID (e.g., PubMed
// ID)</li><li>title</li><li>abstract</li><li>body</li><li>pdfUrl</li><li>referenceUrl</li><li>other
// metadata</li></ul>Note, some documents may not have an abstract, or only the abstract may be available without the
// body text.
func (insightsForMedicalLiteratureService *InsightsForMedicalLiteratureServiceV1) GetDocumentInfo(getDocumentInfoOptions *GetDocumentInfoOptions) (result *GetDocumentInfoResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getDocumentInfoOptions, "getDocumentInfoOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getDocumentInfoOptions, "getDocumentInfoOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"v1/corpora", "documents"}
	pathParameters := []string{*getDocumentInfoOptions.Corpus, *getDocumentInfoOptions.DocumentID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(insightsForMedicalLiteratureService.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getDocumentInfoOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("insights_for_medical_literature_service", "V1", "GetDocumentInfo")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*insightsForMedicalLiteratureService.Version))
	if getDocumentInfoOptions.Verbose != nil {
		builder.AddQuery("verbose", fmt.Sprint(*getDocumentInfoOptions.Verbose))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = insightsForMedicalLiteratureService.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalGetDocumentInfoResponse(m)
		response.Result = result
	}

	return
}

// GetDocumentAnnotations : Retrieves annotations for a document
// The response returns a list of all the annotations contained in the document.
func (insightsForMedicalLiteratureService *InsightsForMedicalLiteratureServiceV1) GetDocumentAnnotations(getDocumentAnnotationsOptions *GetDocumentAnnotationsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getDocumentAnnotationsOptions, "getDocumentAnnotationsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getDocumentAnnotationsOptions, "getDocumentAnnotationsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"v1/corpora", "documents", "annotations"}
	pathParameters := []string{*getDocumentAnnotationsOptions.Corpus, *getDocumentAnnotationsOptions.DocumentID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(insightsForMedicalLiteratureService.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getDocumentAnnotationsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("insights_for_medical_literature_service", "V1", "GetDocumentAnnotations")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*insightsForMedicalLiteratureService.Version))
	builder.AddQuery("document_section", fmt.Sprint(*getDocumentAnnotationsOptions.DocumentSection))
	if getDocumentAnnotationsOptions.Cuis != nil {
		builder.AddQuery("cuis", strings.Join(getDocumentAnnotationsOptions.Cuis, ","))
	}
	if getDocumentAnnotationsOptions.IncludeText != nil {
		builder.AddQuery("include_text", fmt.Sprint(*getDocumentAnnotationsOptions.IncludeText))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = insightsForMedicalLiteratureService.Service.Request(request, nil)

	return
}

// GetDocumentCategories : Categorizes concepts in a document
// The response returns a categorized list of text passages in a document.  The sentences are grouped by concept with
// the matching concepts highlighted.
func (insightsForMedicalLiteratureService *InsightsForMedicalLiteratureServiceV1) GetDocumentCategories(getDocumentCategoriesOptions *GetDocumentCategoriesOptions) (result *CategoriesModel, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getDocumentCategoriesOptions, "getDocumentCategoriesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getDocumentCategoriesOptions, "getDocumentCategoriesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"v1/corpora", "documents", "categories"}
	pathParameters := []string{*getDocumentCategoriesOptions.Corpus, *getDocumentCategoriesOptions.DocumentID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(insightsForMedicalLiteratureService.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getDocumentCategoriesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("insights_for_medical_literature_service", "V1", "GetDocumentCategories")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*insightsForMedicalLiteratureService.Version))
	if getDocumentCategoriesOptions.HighlightTagBegin != nil {
		builder.AddQuery("highlight_tag_begin", fmt.Sprint(*getDocumentCategoriesOptions.HighlightTagBegin))
	}
	if getDocumentCategoriesOptions.HighlightTagEnd != nil {
		builder.AddQuery("highlight_tag_end", fmt.Sprint(*getDocumentCategoriesOptions.HighlightTagEnd))
	}
	if getDocumentCategoriesOptions.Types != nil {
		builder.AddQuery("types", strings.Join(getDocumentCategoriesOptions.Types, ","))
	}
	if getDocumentCategoriesOptions.Category != nil {
		builder.AddQuery("category", fmt.Sprint(*getDocumentCategoriesOptions.Category))
	}
	if getDocumentCategoriesOptions.OnlyNegatedConcepts != nil {
		builder.AddQuery("only_negated_concepts", fmt.Sprint(*getDocumentCategoriesOptions.OnlyNegatedConcepts))
	}
	if getDocumentCategoriesOptions.Fields != nil {
		builder.AddQuery("_fields", fmt.Sprint(*getDocumentCategoriesOptions.Fields))
	}
	if getDocumentCategoriesOptions.Limit != nil {
		builder.AddQuery("_limit", fmt.Sprint(*getDocumentCategoriesOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = insightsForMedicalLiteratureService.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalCategoriesModel(m)
		response.Result = result
	}

	return
}

// GetDocumentMultipleCategories : Categorizes concepts in a document
// The response returns multiple categorized lists of text passages in a document.  The sentences are grouped by concept
// with the matching concepts highlighted.<P>This API should be used to batch multiple categories in a single request to
// improve performance.<P>Example POST body:<pre>{
//  categories: [
//   {
//    name : 'disorders',
//    category : 'disorders'
//   },
//   {
//    name : 'drugs',
//    category : 'drugs'
//   },
//   {
//    name : 'genes',
//    category : 'genes'
//   },
//   {
//    name : 'negated',
//    category : 'negated'
//   },
//   {
//    name : 'finding','
//    types : ['Finding']
//   },
//  ]
// }
// </pre>.
func (insightsForMedicalLiteratureService *InsightsForMedicalLiteratureServiceV1) GetDocumentMultipleCategories(getDocumentMultipleCategoriesOptions *GetDocumentMultipleCategoriesOptions) (result *CategoriesModel, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getDocumentMultipleCategoriesOptions, "getDocumentMultipleCategoriesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getDocumentMultipleCategoriesOptions, "getDocumentMultipleCategoriesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"v1/corpora", "documents", "categories"}
	pathParameters := []string{*getDocumentMultipleCategoriesOptions.Corpus, *getDocumentMultipleCategoriesOptions.DocumentID}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(insightsForMedicalLiteratureService.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getDocumentMultipleCategoriesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("insights_for_medical_literature_service", "V1", "GetDocumentMultipleCategories")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*insightsForMedicalLiteratureService.Version))
	if getDocumentMultipleCategoriesOptions.HighlightTagBegin != nil {
		builder.AddQuery("highlight_tag_begin", fmt.Sprint(*getDocumentMultipleCategoriesOptions.HighlightTagBegin))
	}
	if getDocumentMultipleCategoriesOptions.HighlightTagEnd != nil {
		builder.AddQuery("highlight_tag_end", fmt.Sprint(*getDocumentMultipleCategoriesOptions.HighlightTagEnd))
	}
	if getDocumentMultipleCategoriesOptions.Fields != nil {
		builder.AddQuery("_fields", fmt.Sprint(*getDocumentMultipleCategoriesOptions.Fields))
	}
	if getDocumentMultipleCategoriesOptions.Limit != nil {
		builder.AddQuery("_limit", fmt.Sprint(*getDocumentMultipleCategoriesOptions.Limit))
	}

	body := make(map[string]interface{})
	category := make(map[string]interface{})
	category["name"] = "disorders"
	category["category"] = "disorders"
	body["categories"] = category

	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = insightsForMedicalLiteratureService.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalCategoriesModel(m)
		response.Result = result
	}

	return
}

// GetSearchMatches : Finds concepts in a document matching a set of search concepts
// Returns matching concepts and text passages. The sentences containing each concept are returned with the concept
// highlighted. <p>Extended annotations provide additional details for  each discrete search match detected in the
// document.  An iml-annotation-id attribute is added to each highlight tag which allows an application to easily show
// the annotation details when hovering over a text span.  The iml-annotation-id may also be used to color code the text
// spans.  The ibm_annotation-id is used as a key for the returned annotations. <p>For example, a search match on the
// concept "Breast Carcinoma" will have a class name "iml-breast-carcinoma" inserted in the highlight tag, and the
// returned annotations['umls-breast_carcinoma-hypothetical'] JSON field will contain the detailed annotation data:
// <pre>{
//  "cui": "C0678222"
//  "hypothetical": true
//  "preferredName": "Breast Carcinoma"
//  "semanticType": "umls.NeoplasticProcess"
//  "source": "umls"
//  "type": "umls.NeoplasticProcess"
// }
// </pre>.
func (insightsForMedicalLiteratureService *InsightsForMedicalLiteratureServiceV1) GetSearchMatches(getSearchMatchesOptions *GetSearchMatchesOptions) (result *SearchMatchesModel, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSearchMatchesOptions, "getSearchMatchesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSearchMatchesOptions, "getSearchMatchesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"v1/corpora", "documents", "search_matches"}
	pathParameters := []string{*getSearchMatchesOptions.Corpus, *getSearchMatchesOptions.DocumentID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(insightsForMedicalLiteratureService.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSearchMatchesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("insights_for_medical_literature_service", "V1", "GetSearchMatches")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*insightsForMedicalLiteratureService.Version))
	builder.AddQuery("min_score", fmt.Sprint(*getSearchMatchesOptions.MinScore))
	if getSearchMatchesOptions.Cuis != nil {
		builder.AddQuery("cuis", strings.Join(getSearchMatchesOptions.Cuis, ","))
	}
	if getSearchMatchesOptions.Text != nil {
		builder.AddQuery("text", strings.Join(getSearchMatchesOptions.Text, ","))
	}
	if getSearchMatchesOptions.Types != nil {
		builder.AddQuery("types", strings.Join(getSearchMatchesOptions.Types, ","))
	}
	if getSearchMatchesOptions.Attributes != nil {
		builder.AddQuery("attributes", strings.Join(getSearchMatchesOptions.Attributes, ","))
	}
	if getSearchMatchesOptions.Values != nil {
		builder.AddQuery("values", strings.Join(getSearchMatchesOptions.Values, ","))
	}
	if getSearchMatchesOptions.NluRelations != nil {
		builder.AddQuery("nlu_relations", strings.Join(getSearchMatchesOptions.NluRelations, ","))
	}
	if getSearchMatchesOptions.Limit != nil {
		builder.AddQuery("_limit", fmt.Sprint(*getSearchMatchesOptions.Limit))
	}
	if getSearchMatchesOptions.SearchTagBegin != nil {
		builder.AddQuery("search_tag_begin", fmt.Sprint(*getSearchMatchesOptions.SearchTagBegin))
	}
	if getSearchMatchesOptions.SearchTagEnd != nil {
		builder.AddQuery("search_tag_end", fmt.Sprint(*getSearchMatchesOptions.SearchTagEnd))
	}
	if getSearchMatchesOptions.RelatedTagBegin != nil {
		builder.AddQuery("related_tag_begin", fmt.Sprint(*getSearchMatchesOptions.RelatedTagBegin))
	}
	if getSearchMatchesOptions.RelatedTagEnd != nil {
		builder.AddQuery("related_tag_end", fmt.Sprint(*getSearchMatchesOptions.RelatedTagEnd))
	}
	if getSearchMatchesOptions.Fields != nil {
		builder.AddQuery("_fields", fmt.Sprint(*getSearchMatchesOptions.Fields))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = insightsForMedicalLiteratureService.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalSearchMatchesModel(m)
		response.Result = result
	}

	return
}

// GetCorporaConfig : Retrieves the available corpus names and configuration
// The response returns an array of available corpus names and optionally includes detailed configuation parameters.
func (insightsForMedicalLiteratureService *InsightsForMedicalLiteratureServiceV1) GetCorporaConfig(getCorporaConfigOptions *GetCorporaConfigOptions) (result *CorporaConfig, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(getCorporaConfigOptions, "getCorporaConfigOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"v1/corpora"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(insightsForMedicalLiteratureService.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getCorporaConfigOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("insights_for_medical_literature_service", "V1", "GetCorporaConfig")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*insightsForMedicalLiteratureService.Version))
	if getCorporaConfigOptions.Verbose != nil {
		builder.AddQuery("verbose", fmt.Sprint(*getCorporaConfigOptions.Verbose))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = insightsForMedicalLiteratureService.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalCorporaConfig(m)
		response.Result = result
	}

	return
}

// SetCorpusSchema : Define service repository data model
// The response returns whether the instance schema was properly created.  <P>This API should be used for defining a
// custom corpus schema.<P>Example POST body:<pre>{
//    corpusName : 'string'
//   "enrichmentTargets" : [
//    {
//     "contentField": 'string',
//     "enrichmentField : 'string'
//    }
//   ],
//   "metadataFields" : [
//    {
//     "fieldName": 'string',
//     "fieldType : 'string'
//    }
//   ],
//   "referenceIndices" : {
//    "dictionaryIndex" : "my_umls",
//    "attributeIndex" : "my_attributes",
//    "meshIndex" : "my_mesh",
//   }
// }
// </pre>.
func (insightsForMedicalLiteratureService *InsightsForMedicalLiteratureServiceV1) SetCorpusSchema(setCorpusSchemaOptions *SetCorpusSchemaOptions) (result *CorporaConfig, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(setCorpusSchemaOptions, "setCorpusSchemaOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(setCorpusSchemaOptions, "setCorpusSchemaOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"v1/corpora"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(insightsForMedicalLiteratureService.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range setCorpusSchemaOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("insights_for_medical_literature_service", "V1", "SetCorpusSchema")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*insightsForMedicalLiteratureService.Version))

	body := make(map[string]interface{})
	if setCorpusSchemaOptions.EnrichmentTargets != nil {
		body["enrichmentTargets"] = setCorpusSchemaOptions.EnrichmentTargets
	}
	if setCorpusSchemaOptions.MetadataFields != nil {
		body["metadataFields"] = setCorpusSchemaOptions.MetadataFields
	}
	if setCorpusSchemaOptions.CorpusName != nil {
		body["corpusName"] = setCorpusSchemaOptions.CorpusName
	}
	if setCorpusSchemaOptions.References != nil {
		body["references"] = setCorpusSchemaOptions.References
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = insightsForMedicalLiteratureService.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalCorporaConfig(m)
		response.Result = result
	}

	return
}

// DeleteCorpusSchema : Delete a corpus
// The response returns whether the instance schema was properly deleted.
func (insightsForMedicalLiteratureService *InsightsForMedicalLiteratureServiceV1) DeleteCorpusSchema(deleteCorpusSchemaOptions *DeleteCorpusSchemaOptions) (result *CorporaConfig, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteCorpusSchemaOptions, "deleteCorpusSchemaOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteCorpusSchemaOptions, "deleteCorpusSchemaOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"v1/corpora"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(insightsForMedicalLiteratureService.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteCorpusSchemaOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("insights_for_medical_literature_service", "V1", "DeleteCorpusSchema")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*insightsForMedicalLiteratureService.Version))
	builder.AddQuery("instance", fmt.Sprint(*deleteCorpusSchemaOptions.Instance))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = insightsForMedicalLiteratureService.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalCorporaConfig(m)
		response.Result = result
	}

	return
}

// SetCorpusConfig : Define service repository
// The response returns whether the service successfully connected to the specified repository.  <P>This API should be
// used for providing a custom enriched corpus.<P>Example POST body:<pre>{
//    userName : 'string',
//    password : 'string'
//    repositoryUri : 'uri'
// }
// </pre>.
func (insightsForMedicalLiteratureService *InsightsForMedicalLiteratureServiceV1) SetCorpusConfig(setCorpusConfigOptions *SetCorpusConfigOptions) (result *CorporaConfig, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(setCorpusConfigOptions, "setCorpusConfigOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(setCorpusConfigOptions, "setCorpusConfigOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"v1/corpora/configure"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(insightsForMedicalLiteratureService.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range setCorpusConfigOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("insights_for_medical_literature_service", "V1", "SetCorpusConfig")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*insightsForMedicalLiteratureService.Version))

	body := make(map[string]interface{})
	if setCorpusConfigOptions.UserName != nil {
		body["userName"] = setCorpusConfigOptions.UserName
	}
	if setCorpusConfigOptions.Password != nil {
		body["password"] = setCorpusConfigOptions.Password
	}
	if setCorpusConfigOptions.CorpusURI != nil {
		body["corpusURI"] = setCorpusConfigOptions.CorpusURI
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = insightsForMedicalLiteratureService.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalCorporaConfig(m)
		response.Result = result
	}

	return
}

// MonitorCorpus : Enable monitoring for a custom instance
// This API is meant to be used for IBM Cloud automated monitoring of custom plan instances.  A service api-key with
// read only role can be submitted to enable monitoring.
func (insightsForMedicalLiteratureService *InsightsForMedicalLiteratureServiceV1) MonitorCorpus(monitorCorpusOptions *MonitorCorpusOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(monitorCorpusOptions, "monitorCorpusOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(monitorCorpusOptions, "monitorCorpusOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"v1/corpora/monitor"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.PUT)
	_, err = builder.ConstructHTTPURL(insightsForMedicalLiteratureService.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range monitorCorpusOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("insights_for_medical_literature_service", "V1", "MonitorCorpus")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*insightsForMedicalLiteratureService.Version))
	builder.AddQuery("apikey", fmt.Sprint(*monitorCorpusOptions.Apikey))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = insightsForMedicalLiteratureService.Service.Request(request, nil)

	return
}

// EnableCorpusSearchTracking : Toggle Search Activity Tracking
// The response returns whether the tracking was enabled or disabled.
func (insightsForMedicalLiteratureService *InsightsForMedicalLiteratureServiceV1) EnableCorpusSearchTracking(enableCorpusSearchTrackingOptions *EnableCorpusSearchTrackingOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(enableCorpusSearchTrackingOptions, "enableCorpusSearchTrackingOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"v1/corpora/tracking"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.PUT)
	_, err = builder.ConstructHTTPURL(insightsForMedicalLiteratureService.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range enableCorpusSearchTrackingOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("insights_for_medical_literature_service", "V1", "EnableCorpusSearchTracking")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*insightsForMedicalLiteratureService.Version))
	if enableCorpusSearchTrackingOptions.EnableTracking != nil {
		builder.AddQuery("enable_tracking", fmt.Sprint(*enableCorpusSearchTrackingOptions.EnableTracking))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = insightsForMedicalLiteratureService.Service.Request(request, nil)

	return
}

// GetCorpusConfig : Retrieves the corpus configuration
// The response returns the corpus configuration.
func (insightsForMedicalLiteratureService *InsightsForMedicalLiteratureServiceV1) GetCorpusConfig(getCorpusConfigOptions *GetCorpusConfigOptions) (result *CorporaConfig, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getCorpusConfigOptions, "getCorpusConfigOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getCorpusConfigOptions, "getCorpusConfigOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"v1/corpora"}
	pathParameters := []string{*getCorpusConfigOptions.Corpus}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(insightsForMedicalLiteratureService.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getCorpusConfigOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("insights_for_medical_literature_service", "V1", "GetCorpusConfig")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*insightsForMedicalLiteratureService.Version))
	if getCorpusConfigOptions.Verbose != nil {
		builder.AddQuery("verbose", fmt.Sprint(*getCorpusConfigOptions.Verbose))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = insightsForMedicalLiteratureService.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalCorporaConfig(m)
		response.Result = result
	}

	return
}

// GetHealthCheckStatus : Determine if service is running correctly
// This resource differs from /status in that it will will always return a 500 error if the service state is not OK.
// This makes it simpler for service front ends (such as Datapower) to detect a failed service.
func (insightsForMedicalLiteratureService *InsightsForMedicalLiteratureServiceV1) GetHealthCheckStatus(getHealthCheckStatusOptions *GetHealthCheckStatusOptions) (result *ServiceStatus, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(getHealthCheckStatusOptions, "getHealthCheckStatusOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"v1/status/health_check"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(insightsForMedicalLiteratureService.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getHealthCheckStatusOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("insights_for_medical_literature_service", "V1", "GetHealthCheckStatus")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getHealthCheckStatusOptions.Accept != nil {
		builder.AddHeader("Accept", fmt.Sprint(*getHealthCheckStatusOptions.Accept))
	}

	if getHealthCheckStatusOptions.Format != nil {
		builder.AddQuery("format", fmt.Sprint(*getHealthCheckStatusOptions.Format))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = insightsForMedicalLiteratureService.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalServiceStatus(m)
		response.Result = result
	}

	return
}

// Search : Search for concepts, documents, and authors
// Features include:<ul><li>Concept search</li><li>Keyword search</li><li>Attributes search</li><li>Attributes
// typeahead</li><li>Regular expressions</li><li>Find passages</li><li>Selecting authors</li><li>Selecting
// providers</li><li>Date ranges: publish date</li><li>Pagination</li><li>Aggregation: authors, concepts, and
// documents</li><li>Document date histogram</li></ul>.
func (insightsForMedicalLiteratureService *InsightsForMedicalLiteratureServiceV1) Search(searchOptions *SearchOptions) (result *SearchModel, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(searchOptions, "searchOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(searchOptions, "searchOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"v1/corpora", "search"}
	pathParameters := []string{*searchOptions.Corpus}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(insightsForMedicalLiteratureService.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range searchOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("insights_for_medical_literature_service", "V1", "Search")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*insightsForMedicalLiteratureService.Version))
	if searchOptions.Verbose != nil {
		builder.AddQuery("verbose", fmt.Sprint(*searchOptions.Verbose))
	}

	_, err = builder.SetBodyContentJSON(searchOptions.Body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = insightsForMedicalLiteratureService.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalSearchModel(m)
		response.Result = result
	}

	return
}

// GetFields : Retrieves a list of metadata fields defined in the corpus
// The response returns a list of metadata field names that can be used by the POST search API.
func (insightsForMedicalLiteratureService *InsightsForMedicalLiteratureServiceV1) GetFields(getFieldsOptions *GetFieldsOptions) (result *MetadataModel, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getFieldsOptions, "getFieldsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getFieldsOptions, "getFieldsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"v1/corpora", "search/metadata"}
	pathParameters := []string{*getFieldsOptions.Corpus}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(insightsForMedicalLiteratureService.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getFieldsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("insights_for_medical_literature_service", "V1", "GetFields")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*insightsForMedicalLiteratureService.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = insightsForMedicalLiteratureService.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalMetadataModel(m)
		response.Result = result
	}

	return
}

// Typeahead : Find concepts matching the specified query string
// Searches concepts mentioned in the corpus looking for matches on the query string field. The comparison is not case
// sensitive. The main use of this method is to build query boxes that offer auto-complete, to allow users to select
// valid concepts.
func (insightsForMedicalLiteratureService *InsightsForMedicalLiteratureServiceV1) Typeahead(typeaheadOptions *TypeaheadOptions) (result *ConceptListModel, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(typeaheadOptions, "typeaheadOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(typeaheadOptions, "typeaheadOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"v1/corpora", "search/typeahead"}
	pathParameters := []string{*typeaheadOptions.Corpus}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(insightsForMedicalLiteratureService.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range typeaheadOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("insights_for_medical_literature_service", "V1", "Typeahead")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*insightsForMedicalLiteratureService.Version))
	builder.AddQuery("query", fmt.Sprint(*typeaheadOptions.Query))
	if typeaheadOptions.Ontologies != nil {
		builder.AddQuery("ontologies", strings.Join(typeaheadOptions.Ontologies, ","))
	}
	if typeaheadOptions.Types != nil {
		builder.AddQuery("types", strings.Join(typeaheadOptions.Types, ","))
	}
	if typeaheadOptions.Category != nil {
		builder.AddQuery("category", fmt.Sprint(*typeaheadOptions.Category))
	}
	if typeaheadOptions.Verbose != nil {
		builder.AddQuery("verbose", fmt.Sprint(*typeaheadOptions.Verbose))
	}
	if typeaheadOptions.Limit != nil {
		builder.AddQuery("_limit", fmt.Sprint(*typeaheadOptions.Limit))
	}
	if typeaheadOptions.MaxHitCount != nil {
		builder.AddQuery("max_hit_count", fmt.Sprint(*typeaheadOptions.MaxHitCount))
	}
	if typeaheadOptions.NoDuplicates != nil {
		builder.AddQuery("no_duplicates", fmt.Sprint(*typeaheadOptions.NoDuplicates))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = insightsForMedicalLiteratureService.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalConceptListModel(m)
		response.Result = result
	}

	return
}

// GetConcepts : Retrieves information for concepts mentioned in this corpus
// The response returns concepts mentioned in this corpus.  The returned concepts may be selected by CUI, preferred
// name, suface forms and attribute name.  All selected concepts are returned.
func (insightsForMedicalLiteratureService *InsightsForMedicalLiteratureServiceV1) GetConcepts(getConceptsOptions *GetConceptsOptions) (result *ConceptListModel, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getConceptsOptions, "getConceptsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getConceptsOptions, "getConceptsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"v1/corpora", "concepts"}
	pathParameters := []string{*getConceptsOptions.Corpus}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(insightsForMedicalLiteratureService.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getConceptsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("insights_for_medical_literature_service", "V1", "GetConcepts")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*insightsForMedicalLiteratureService.Version))
	if getConceptsOptions.Cuis != nil {
		builder.AddQuery("cuis", strings.Join(getConceptsOptions.Cuis, ","))
	}
	if getConceptsOptions.PreferredNames != nil {
		builder.AddQuery("preferred_names", strings.Join(getConceptsOptions.PreferredNames, ","))
	}
	if getConceptsOptions.SurfaceForms != nil {
		builder.AddQuery("surface_forms", strings.Join(getConceptsOptions.SurfaceForms, ","))
	}
	if getConceptsOptions.Attributes != nil {
		builder.AddQuery("attributes", strings.Join(getConceptsOptions.Attributes, ","))
	}
	if getConceptsOptions.Verbose != nil {
		builder.AddQuery("verbose", fmt.Sprint(*getConceptsOptions.Verbose))
	}
	if getConceptsOptions.Sort != nil {
		builder.AddQuery("_sort", fmt.Sprint(*getConceptsOptions.Sort))
	}
	if getConceptsOptions.Limit != nil {
		builder.AddQuery("_limit", fmt.Sprint(*getConceptsOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = insightsForMedicalLiteratureService.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalConceptListModel(m)
		response.Result = result
	}

	return
}

// AddArtifact : Add cartridge artifact
func (insightsForMedicalLiteratureService *InsightsForMedicalLiteratureServiceV1) AddArtifact(addArtifactOptions *AddArtifactOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(addArtifactOptions, "addArtifactOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(addArtifactOptions, "addArtifactOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"v1/corpora", "concepts/definitions"}
	pathParameters := []string{*addArtifactOptions.Corpus}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(insightsForMedicalLiteratureService.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range addArtifactOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("insights_for_medical_literature_service", "V1", "AddArtifact")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*insightsForMedicalLiteratureService.Version))

	body := make(map[string]interface{})
	if addArtifactOptions.DictionaryEntry != nil {
		body["dictionaryEntry"] = addArtifactOptions.DictionaryEntry
	}
	if addArtifactOptions.AttributeEntry != nil {
		body["attributeEntry"] = addArtifactOptions.AttributeEntry
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = insightsForMedicalLiteratureService.Service.Request(request, nil)

	return
}

// GetCuiInfo : Retrieve information for a concept
// The followning fields may be retrieved: <ul><li>Preferred name</li><li>Semantic types</li><li>Surface forms -
// Ontology Dictionary names for this concept</li><li>Definition - Concept definition (if available)</li><li>Related
// Concepts info</li></ul><P>The default is to return all fields.  Individual fields may be selected using the '_fields'
// query parameter.
func (insightsForMedicalLiteratureService *InsightsForMedicalLiteratureServiceV1) GetCuiInfo(getCuiInfoOptions *GetCuiInfoOptions) (result *ConceptInfoModel, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getCuiInfoOptions, "getCuiInfoOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getCuiInfoOptions, "getCuiInfoOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"v1/corpora", "concepts"}
	pathParameters := []string{*getCuiInfoOptions.Corpus, *getCuiInfoOptions.NameOrID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(insightsForMedicalLiteratureService.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getCuiInfoOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("insights_for_medical_literature_service", "V1", "GetCuiInfo")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*insightsForMedicalLiteratureService.Version))
	if getCuiInfoOptions.Ontology != nil {
		builder.AddQuery("ontology", fmt.Sprint(*getCuiInfoOptions.Ontology))
	}
	if getCuiInfoOptions.Fields != nil {
		builder.AddQuery("_fields", fmt.Sprint(*getCuiInfoOptions.Fields))
	}
	if getCuiInfoOptions.TreeLayout != nil {
		builder.AddQuery("tree_layout", fmt.Sprint(*getCuiInfoOptions.TreeLayout))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = insightsForMedicalLiteratureService.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalConceptInfoModel(m)
		response.Result = result
	}

	return
}

// GetHitCount : Retrieves a count of the number of times a concept is mentioned in the corpus
// The response returns the number of times a concept is mentioned (hit count) in the corpus.
func (insightsForMedicalLiteratureService *InsightsForMedicalLiteratureServiceV1) GetHitCount(getHitCountOptions *GetHitCountOptions) (result *HitCount, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getHitCountOptions, "getHitCountOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getHitCountOptions, "getHitCountOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"v1/corpora", "concepts", "hit_count"}
	pathParameters := []string{*getHitCountOptions.Corpus, *getHitCountOptions.NameOrID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(insightsForMedicalLiteratureService.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getHitCountOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("insights_for_medical_literature_service", "V1", "GetHitCount")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*insightsForMedicalLiteratureService.Version))
	if getHitCountOptions.Ontology != nil {
		builder.AddQuery("ontology", fmt.Sprint(*getHitCountOptions.Ontology))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = insightsForMedicalLiteratureService.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalHitCount(m)
		response.Result = result
	}

	return
}

// GetRelatedConcepts : Retrieve concepts related to a concept
// Returns a list of related concepts mentioned in the specified corpus. The following relationships are suppored:
// <ul><li><b>children</b> child concepts</li><li><b>parents</b> parent concepts</li><li><b>siblings</b> sibling
// concepts</li><li><b>synonyms</b> synonym concepts</li><li><b>qualified by</b> qualified by
// concepts</li><li><b>broader</b> broader concepts</li><li><b>narrower</b> narrower concepts</li><li><b>other</b> other
// than synonyms, narrower or broader</li><li><b>related</b> related and posibly synonymous concepts</li></ul><p>If the
// corpus path parameter can be set to 'umls' to look up relationship in the entire UMLS dictionary.  Otherwise, an
// actual corpus name may be specified to limit the output to only those concepts mentioned in a specific corpus.
func (insightsForMedicalLiteratureService *InsightsForMedicalLiteratureServiceV1) GetRelatedConcepts(getRelatedConceptsOptions *GetRelatedConceptsOptions) (result *RelatedConceptsModel, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getRelatedConceptsOptions, "getRelatedConceptsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getRelatedConceptsOptions, "getRelatedConceptsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"v1/corpora", "concepts", "related_concepts"}
	pathParameters := []string{*getRelatedConceptsOptions.Corpus, *getRelatedConceptsOptions.NameOrID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(insightsForMedicalLiteratureService.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getRelatedConceptsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("insights_for_medical_literature_service", "V1", "GetRelatedConcepts")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("relationship", fmt.Sprint(*getRelatedConceptsOptions.Relationship))
	builder.AddQuery("version", fmt.Sprint(*insightsForMedicalLiteratureService.Version))
	if getRelatedConceptsOptions.Ontology != nil {
		builder.AddQuery("ontology", fmt.Sprint(*getRelatedConceptsOptions.Ontology))
	}
	if getRelatedConceptsOptions.RelationshipAttributes != nil {
		builder.AddQuery("relationship_attributes", strings.Join(getRelatedConceptsOptions.RelationshipAttributes, ","))
	}
	if getRelatedConceptsOptions.Sources != nil {
		builder.AddQuery("sources", strings.Join(getRelatedConceptsOptions.Sources, ","))
	}
	if getRelatedConceptsOptions.Recursive != nil {
		builder.AddQuery("recursive", fmt.Sprint(*getRelatedConceptsOptions.Recursive))
	}
	if getRelatedConceptsOptions.TreeLayout != nil {
		builder.AddQuery("tree_layout", fmt.Sprint(*getRelatedConceptsOptions.TreeLayout))
	}
	if getRelatedConceptsOptions.MaxDepth != nil {
		builder.AddQuery("max_depth", fmt.Sprint(*getRelatedConceptsOptions.MaxDepth))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = insightsForMedicalLiteratureService.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalRelatedConceptsModel(m)
		response.Result = result
	}

	return
}

// GetSimilarConcepts : Find similar concepts
// The response returns a list of similar concepts.   All ontologies defined in the corpora are searched.  Similarity is
// determined by checking for overlapping surface forms.  The results are sorted in descending order by hit count.
func (insightsForMedicalLiteratureService *InsightsForMedicalLiteratureServiceV1) GetSimilarConcepts(getSimilarConceptsOptions *GetSimilarConceptsOptions) (result *ConceptListModel, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSimilarConceptsOptions, "getSimilarConceptsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSimilarConceptsOptions, "getSimilarConceptsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"v1/corpora", "concepts", "similar_concepts"}
	pathParameters := []string{*getSimilarConceptsOptions.Corpus, *getSimilarConceptsOptions.NameOrID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(insightsForMedicalLiteratureService.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSimilarConceptsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("insights_for_medical_literature_service", "V1", "GetSimilarConcepts")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*insightsForMedicalLiteratureService.Version))
	builder.AddQuery("return_ontologies", strings.Join(getSimilarConceptsOptions.ReturnOntologies, ","))
	if getSimilarConceptsOptions.Ontology != nil {
		builder.AddQuery("ontology", fmt.Sprint(*getSimilarConceptsOptions.Ontology))
	}
	if getSimilarConceptsOptions.Limit != nil {
		builder.AddQuery("_limit", fmt.Sprint(*getSimilarConceptsOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = insightsForMedicalLiteratureService.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalConceptListModel(m)
		response.Result = result
	}

	return
}

// Tokenize : Tokenize the input text into concepts
// The response returns a list of tokenized concepts for the specified ontologies.
func (insightsForMedicalLiteratureService *InsightsForMedicalLiteratureServiceV1) Tokenize(tokenizeOptions *TokenizeOptions) (result *CommonDataModel, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(tokenizeOptions, "tokenizeOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(tokenizeOptions, "tokenizeOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"v1/corpora", "debug/analyze"}
	pathParameters := []string{*tokenizeOptions.Corpus, *tokenizeOptions.Flow}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(insightsForMedicalLiteratureService.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range tokenizeOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("insights_for_medical_literature_service", "V1", "Tokenize")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*insightsForMedicalLiteratureService.Version))
	if tokenizeOptions.Ontologies != nil {
		builder.AddQuery("ontologies", strings.Join(tokenizeOptions.Ontologies, ","))
	}
	if tokenizeOptions.MaxWords != nil {
		builder.AddQuery("max_words", fmt.Sprint(*tokenizeOptions.MaxWords))
	}

	_, err = builder.SetBodyContentJSON(tokenizeOptions.Body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = insightsForMedicalLiteratureService.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalCommonDataModel(m)
		response.Result = result
	}

	return
}

// AddArtifactOptions : The AddArtifact options.
type AddArtifactOptions struct {
	// Corpus name.
	Corpus *string `json:"corpus" validate:"required"`

	DictionaryEntry *DictonaryEntry `json:"dictionaryEntry,omitempty"`

	AttributeEntry *AttributeEntry `json:"attributeEntry,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewAddArtifactOptions : Instantiate AddArtifactOptions
func (*InsightsForMedicalLiteratureServiceV1) NewAddArtifactOptions(corpus string) *AddArtifactOptions {
	return &AddArtifactOptions{
		Corpus: core.StringPtr(corpus),
	}
}

// SetCorpus : Allow user to set Corpus
func (options *AddArtifactOptions) SetCorpus(corpus string) *AddArtifactOptions {
	options.Corpus = core.StringPtr(corpus)
	return options
}

// SetDictionaryEntry : Allow user to set DictionaryEntry
func (options *AddArtifactOptions) SetDictionaryEntry(dictionaryEntry *DictonaryEntry) *AddArtifactOptions {
	options.DictionaryEntry = dictionaryEntry
	return options
}

// SetAttributeEntry : Allow user to set AttributeEntry
func (options *AddArtifactOptions) SetAttributeEntry(attributeEntry *AttributeEntry) *AddArtifactOptions {
	options.AttributeEntry = attributeEntry
	return options
}

// SetHeaders : Allow user to set Headers
func (options *AddArtifactOptions) SetHeaders(param map[string]string) *AddArtifactOptions {
	options.Headers = param
	return options
}

// AddCorpusDocumentOptions : The AddCorpusDocument options.
type AddCorpusDocumentOptions struct {
	// Corpus name.
	Corpus *string `json:"corpus" validate:"required"`

	// JSON based document for enrichment.
	Document map[string]interface{} `json:"document,omitempty"`

	// Annotator for clincial data url.
	AcdURL *string `json:"acdUrl,omitempty"`

	// Security key.
	ApiKey *string `json:"apiKey,omitempty"`

	// Enrichment flow identifier.
	FlowID *string `json:"flowId,omitempty"`

	// Cloud access token.
	AccessToken *string `json:"accessToken,omitempty"`

	// URLs and API keys for custom annotators.
	OtherAnnotators []interface{} `json:"otherAnnotators,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewAddCorpusDocumentOptions : Instantiate AddCorpusDocumentOptions
func (*InsightsForMedicalLiteratureServiceV1) NewAddCorpusDocumentOptions(corpus string) *AddCorpusDocumentOptions {
	return &AddCorpusDocumentOptions{
		Corpus: core.StringPtr(corpus),
	}
}

// SetCorpus : Allow user to set Corpus
func (options *AddCorpusDocumentOptions) SetCorpus(corpus string) *AddCorpusDocumentOptions {
	options.Corpus = core.StringPtr(corpus)
	return options
}

// SetDocument : Allow user to set Document
func (options *AddCorpusDocumentOptions) SetDocument(document map[string]interface{}) *AddCorpusDocumentOptions {
	options.Document = document
	return options
}

// SetAcdURL : Allow user to set AcdURL
func (options *AddCorpusDocumentOptions) SetAcdURL(acdURL string) *AddCorpusDocumentOptions {
	options.AcdURL = core.StringPtr(acdURL)
	return options
}

// SetApiKey : Allow user to set ApiKey
func (options *AddCorpusDocumentOptions) SetApiKey(apiKey string) *AddCorpusDocumentOptions {
	options.ApiKey = core.StringPtr(apiKey)
	return options
}

// SetFlowID : Allow user to set FlowID
func (options *AddCorpusDocumentOptions) SetFlowID(flowID string) *AddCorpusDocumentOptions {
	options.FlowID = core.StringPtr(flowID)
	return options
}

// SetAccessToken : Allow user to set AccessToken
func (options *AddCorpusDocumentOptions) SetAccessToken(accessToken string) *AddCorpusDocumentOptions {
	options.AccessToken = core.StringPtr(accessToken)
	return options
}

// SetOtherAnnotators : Allow user to set OtherAnnotators
func (options *AddCorpusDocumentOptions) SetOtherAnnotators(otherAnnotators []interface{}) *AddCorpusDocumentOptions {
	options.OtherAnnotators = otherAnnotators
	return options
}

// SetHeaders : Allow user to set Headers
func (options *AddCorpusDocumentOptions) SetHeaders(param map[string]string) *AddCorpusDocumentOptions {
	options.Headers = param
	return options
}

// AttributeEntry : AttributeEntry struct
type AttributeEntry struct {
	AttrName *string `json:"attr_name,omitempty"`

	DataType *string `json:"data_type,omitempty"`

	DefaultValue *string `json:"default_value,omitempty"`

	Description *string `json:"description,omitempty"`

	DisplayName *string `json:"display_name,omitempty"`

	DocID *string `json:"doc_id,omitempty"`

	FieldValues []string `json:"field_values,omitempty"`

	MaximumValue *string `json:"maximum_value,omitempty"`

	MinimumValue *string `json:"minimum_value,omitempty"`

	MultiValue *bool `json:"multi_value,omitempty"`

	Units *string `json:"units,omitempty"`

	ValueType *string `json:"valueType,omitempty"`

	PossibleValues []PossbileValues `json:"possible_values,omitempty"`
}

// UnmarshalAttributeEntry constructs an instance of AttributeEntry from the specified map.
func UnmarshalAttributeEntry(m map[string]interface{}) (result *AttributeEntry, err error) {
	obj := new(AttributeEntry)
	obj.AttrName, err = core.UnmarshalString(m, "attr_name")
	if err != nil {
		return
	}
	obj.DataType, err = core.UnmarshalString(m, "data_type")
	if err != nil {
		return
	}
	obj.DefaultValue, err = core.UnmarshalString(m, "default_value")
	if err != nil {
		return
	}
	obj.Description, err = core.UnmarshalString(m, "description")
	if err != nil {
		return
	}
	obj.DisplayName, err = core.UnmarshalString(m, "display_name")
	if err != nil {
		return
	}
	obj.DocID, err = core.UnmarshalString(m, "doc_id")
	if err != nil {
		return
	}
	obj.FieldValues, err = core.UnmarshalStringSlice(m, "field_values")
	if err != nil {
		return
	}
	obj.MaximumValue, err = core.UnmarshalString(m, "maximum_value")
	if err != nil {
		return
	}
	obj.MinimumValue, err = core.UnmarshalString(m, "minimum_value")
	if err != nil {
		return
	}
	obj.MultiValue, err = core.UnmarshalBool(m, "multi_value")
	if err != nil {
		return
	}
	obj.Units, err = core.UnmarshalString(m, "units")
	if err != nil {
		return
	}
	obj.ValueType, err = core.UnmarshalString(m, "valueType")
	if err != nil {
		return
	}
	obj.PossibleValues, err = UnmarshalPossbileValuesSliceAsProperty(m, "possible_values")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalAttributeEntrySlice unmarshals a slice of AttributeEntry instances from the specified list of maps.
func UnmarshalAttributeEntrySlice(s []interface{}) (slice []AttributeEntry, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'AttributeEntry'")
			return
		}
		obj, e := UnmarshalAttributeEntry(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalAttributeEntryAsProperty unmarshals an instance of AttributeEntry that is stored as a property
// within the specified map.
func UnmarshalAttributeEntryAsProperty(m map[string]interface{}, propertyName string) (result *AttributeEntry, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'AttributeEntry'", propertyName)
			return
		}
		result, err = UnmarshalAttributeEntry(objMap)
	}
	return
}

// UnmarshalAttributeEntrySliceAsProperty unmarshals a slice of AttributeEntry instances that are stored as a property
// within the specified map.
func UnmarshalAttributeEntrySliceAsProperty(m map[string]interface{}, propertyName string) (slice []AttributeEntry, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'AttributeEntry'", propertyName)
			return
		}
		slice, err = UnmarshalAttributeEntrySlice(vSlice)
	}
	return
}

// BoolOperand : BoolOperand struct
type BoolOperand struct {
	BoolOperand *string `json:"boolOperand,omitempty"`
}

// UnmarshalBoolOperand constructs an instance of BoolOperand from the specified map.
func UnmarshalBoolOperand(m map[string]interface{}) (result *BoolOperand, err error) {
	obj := new(BoolOperand)
	obj.BoolOperand, err = core.UnmarshalString(m, "boolOperand")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalBoolOperandSlice unmarshals a slice of BoolOperand instances from the specified list of maps.
func UnmarshalBoolOperandSlice(s []interface{}) (slice []BoolOperand, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'BoolOperand'")
			return
		}
		obj, e := UnmarshalBoolOperand(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalBoolOperandAsProperty unmarshals an instance of BoolOperand that is stored as a property
// within the specified map.
func UnmarshalBoolOperandAsProperty(m map[string]interface{}, propertyName string) (result *BoolOperand, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'BoolOperand'", propertyName)
			return
		}
		result, err = UnmarshalBoolOperand(objMap)
	}
	return
}

// UnmarshalBoolOperandSliceAsProperty unmarshals a slice of BoolOperand instances that are stored as a property
// within the specified map.
func UnmarshalBoolOperandSliceAsProperty(m map[string]interface{}, propertyName string) (slice []BoolOperand, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'BoolOperand'", propertyName)
			return
		}
		slice, err = UnmarshalBoolOperandSlice(vSlice)
	}
	return
}

// DeleteCorpusSchemaOptions : The DeleteCorpusSchema options.
type DeleteCorpusSchemaOptions struct {
	// corpus schema.
	Instance *string `json:"instance" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteCorpusSchemaOptions : Instantiate DeleteCorpusSchemaOptions
func (*InsightsForMedicalLiteratureServiceV1) NewDeleteCorpusSchemaOptions(instance string) *DeleteCorpusSchemaOptions {
	return &DeleteCorpusSchemaOptions{
		Instance: core.StringPtr(instance),
	}
}

// SetInstance : Allow user to set Instance
func (options *DeleteCorpusSchemaOptions) SetInstance(instance string) *DeleteCorpusSchemaOptions {
	options.Instance = core.StringPtr(instance)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteCorpusSchemaOptions) SetHeaders(param map[string]string) *DeleteCorpusSchemaOptions {
	options.Headers = param
	return options
}

// DictonaryEntry : DictonaryEntry struct
type DictonaryEntry struct {
	Children []string `json:"children,omitempty"`

	Cui *string `json:"cui,omitempty"`

	Definition []string `json:"definition,omitempty"`

	Parents []string `json:"parents,omitempty"`

	PreferredName *string `json:"preferredName,omitempty"`

	Semtypes []string `json:"semtypes,omitempty"`

	Siblings []string `json:"siblings,omitempty"`

	SurfaceForms []string `json:"surfaceForms,omitempty"`

	Variants []string `json:"variants,omitempty"`

	Vocab *string `json:"vocab,omitempty"`

	Related []string `json:"related,omitempty"`

	Source *string `json:"source,omitempty"`

	SourceVersion *string `json:"source_version,omitempty"`
}

// UnmarshalDictonaryEntry constructs an instance of DictonaryEntry from the specified map.
func UnmarshalDictonaryEntry(m map[string]interface{}) (result *DictonaryEntry, err error) {
	obj := new(DictonaryEntry)
	obj.Children, err = core.UnmarshalStringSlice(m, "children")
	if err != nil {
		return
	}
	obj.Cui, err = core.UnmarshalString(m, "cui")
	if err != nil {
		return
	}
	obj.Definition, err = core.UnmarshalStringSlice(m, "definition")
	if err != nil {
		return
	}
	obj.Parents, err = core.UnmarshalStringSlice(m, "parents")
	if err != nil {
		return
	}
	obj.PreferredName, err = core.UnmarshalString(m, "preferredName")
	if err != nil {
		return
	}
	obj.Semtypes, err = core.UnmarshalStringSlice(m, "semtypes")
	if err != nil {
		return
	}
	obj.Siblings, err = core.UnmarshalStringSlice(m, "siblings")
	if err != nil {
		return
	}
	obj.SurfaceForms, err = core.UnmarshalStringSlice(m, "surfaceForms")
	if err != nil {
		return
	}
	obj.Variants, err = core.UnmarshalStringSlice(m, "variants")
	if err != nil {
		return
	}
	obj.Vocab, err = core.UnmarshalString(m, "vocab")
	if err != nil {
		return
	}
	obj.Related, err = core.UnmarshalStringSlice(m, "related")
	if err != nil {
		return
	}
	obj.Source, err = core.UnmarshalString(m, "source")
	if err != nil {
		return
	}
	obj.SourceVersion, err = core.UnmarshalString(m, "source_version")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalDictonaryEntrySlice unmarshals a slice of DictonaryEntry instances from the specified list of maps.
func UnmarshalDictonaryEntrySlice(s []interface{}) (slice []DictonaryEntry, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'DictonaryEntry'")
			return
		}
		obj, e := UnmarshalDictonaryEntry(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalDictonaryEntryAsProperty unmarshals an instance of DictonaryEntry that is stored as a property
// within the specified map.
func UnmarshalDictonaryEntryAsProperty(m map[string]interface{}, propertyName string) (result *DictonaryEntry, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'DictonaryEntry'", propertyName)
			return
		}
		result, err = UnmarshalDictonaryEntry(objMap)
	}
	return
}

// UnmarshalDictonaryEntrySliceAsProperty unmarshals a slice of DictonaryEntry instances that are stored as a property
// within the specified map.
func UnmarshalDictonaryEntrySliceAsProperty(m map[string]interface{}, propertyName string) (slice []DictonaryEntry, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'DictonaryEntry'", propertyName)
			return
		}
		slice, err = UnmarshalDictonaryEntrySlice(vSlice)
	}
	return
}

// EnableCorpusSearchTrackingOptions : The EnableCorpusSearchTracking options.
type EnableCorpusSearchTrackingOptions struct {
	// Enable corpus read event tracking.  Default is false.
	EnableTracking *bool `json:"enable_tracking,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewEnableCorpusSearchTrackingOptions : Instantiate EnableCorpusSearchTrackingOptions
func (*InsightsForMedicalLiteratureServiceV1) NewEnableCorpusSearchTrackingOptions() *EnableCorpusSearchTrackingOptions {
	return &EnableCorpusSearchTrackingOptions{}
}

// SetEnableTracking : Allow user to set EnableTracking
func (options *EnableCorpusSearchTrackingOptions) SetEnableTracking(enableTracking bool) *EnableCorpusSearchTrackingOptions {
	options.EnableTracking = core.BoolPtr(enableTracking)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *EnableCorpusSearchTrackingOptions) SetHeaders(param map[string]string) *EnableCorpusSearchTrackingOptions {
	options.Headers = param
	return options
}

// GetConceptsOptions : The GetConcepts options.
type GetConceptsOptions struct {
	// Corpus name.
	Corpus *string `json:"corpus" validate:"required"`

	// Select concepts with the specified CUIs. Each cui is assumed to be from UMLS unless an ontology is explicitly
	// specified using the syntax [ontology:]cui, e.g., 'concepts:C0018787'.
	Cuis []string `json:"cuis,omitempty"`

	// Select concepts with the specified preferred names. Each preferred name is assumed to be from UMLS unless an
	// ontology is explicitly specified using the syntax [ontology:::]preferred_name, e.g., 'concepts:::HEART'.
	PreferredNames []string `json:"preferred_names,omitempty"`

	// Select all concepts having these surface forms. The match is case insensitive. Each surface form is matched against
	// UMLS unless an ontology is explicitly specified using the syntax [ontology:::]surface_form, e.g., 'concepts:::heart
	// attack'.
	SurfaceForms []string `json:"surface_forms,omitempty"`

	// Select all concepts having these attributes. The match is case insensitive.
	Attributes []string `json:"attributes,omitempty"`

	// Verbose output.  Default is false.
	Verbose *bool `json:"verbose,omitempty"`

	// Sort by hitCount (in document count).  Set to ascending order (_sort=+hitCount) or descending order
	// (_sort=-hitCount).
	Sort *string `json:"_sort,omitempty"`

	// Number of possible concepts to return. Default is 250.
	Limit *int64 `json:"_limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetConceptsOptions : Instantiate GetConceptsOptions
func (*InsightsForMedicalLiteratureServiceV1) NewGetConceptsOptions(corpus string) *GetConceptsOptions {
	return &GetConceptsOptions{
		Corpus: core.StringPtr(corpus),
	}
}

// SetCorpus : Allow user to set Corpus
func (options *GetConceptsOptions) SetCorpus(corpus string) *GetConceptsOptions {
	options.Corpus = core.StringPtr(corpus)
	return options
}

// SetCuis : Allow user to set Cuis
func (options *GetConceptsOptions) SetCuis(cuis []string) *GetConceptsOptions {
	options.Cuis = cuis
	return options
}

// SetPreferredNames : Allow user to set PreferredNames
func (options *GetConceptsOptions) SetPreferredNames(preferredNames []string) *GetConceptsOptions {
	options.PreferredNames = preferredNames
	return options
}

// SetSurfaceForms : Allow user to set SurfaceForms
func (options *GetConceptsOptions) SetSurfaceForms(surfaceForms []string) *GetConceptsOptions {
	options.SurfaceForms = surfaceForms
	return options
}

// SetAttributes : Allow user to set Attributes
func (options *GetConceptsOptions) SetAttributes(attributes []string) *GetConceptsOptions {
	options.Attributes = attributes
	return options
}

// SetVerbose : Allow user to set Verbose
func (options *GetConceptsOptions) SetVerbose(verbose bool) *GetConceptsOptions {
	options.Verbose = core.BoolPtr(verbose)
	return options
}

// SetSort : Allow user to set Sort
func (options *GetConceptsOptions) SetSort(sort string) *GetConceptsOptions {
	options.Sort = core.StringPtr(sort)
	return options
}

// SetLimit : Allow user to set Limit
func (options *GetConceptsOptions) SetLimit(limit int64) *GetConceptsOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetConceptsOptions) SetHeaders(param map[string]string) *GetConceptsOptions {
	options.Headers = param
	return options
}

// GetCorporaConfigOptions : The GetCorporaConfig options.
type GetCorporaConfigOptions struct {
	// Verbose output.  Default verbose = false.
	Verbose *bool `json:"verbose,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetCorporaConfigOptions : Instantiate GetCorporaConfigOptions
func (*InsightsForMedicalLiteratureServiceV1) NewGetCorporaConfigOptions() *GetCorporaConfigOptions {
	return &GetCorporaConfigOptions{}
}

// SetVerbose : Allow user to set Verbose
func (options *GetCorporaConfigOptions) SetVerbose(verbose bool) *GetCorporaConfigOptions {
	options.Verbose = core.BoolPtr(verbose)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetCorporaConfigOptions) SetHeaders(param map[string]string) *GetCorporaConfigOptions {
	options.Headers = param
	return options
}

// GetCorpusConfigOptions : The GetCorpusConfig options.
type GetCorpusConfigOptions struct {
	// Corpus name.
	Corpus *string `json:"corpus" validate:"required"`

	// Verbose output.  Default verbose = false.
	Verbose *bool `json:"verbose,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetCorpusConfigOptions : Instantiate GetCorpusConfigOptions
func (*InsightsForMedicalLiteratureServiceV1) NewGetCorpusConfigOptions(corpus string) *GetCorpusConfigOptions {
	return &GetCorpusConfigOptions{
		Corpus: core.StringPtr(corpus),
	}
}

// SetCorpus : Allow user to set Corpus
func (options *GetCorpusConfigOptions) SetCorpus(corpus string) *GetCorpusConfigOptions {
	options.Corpus = core.StringPtr(corpus)
	return options
}

// SetVerbose : Allow user to set Verbose
func (options *GetCorpusConfigOptions) SetVerbose(verbose bool) *GetCorpusConfigOptions {
	options.Verbose = core.BoolPtr(verbose)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetCorpusConfigOptions) SetHeaders(param map[string]string) *GetCorpusConfigOptions {
	options.Headers = param
	return options
}

// GetCuiInfoOptions : The GetCuiInfo options.
type GetCuiInfoOptions struct {
	// Corpus name.
	Corpus *string `json:"corpus" validate:"required"`

	// Preferred name or concept ID.
	NameOrID *string `json:"name_or_id" validate:"required"`

	// The ontology that defines the cui.
	Ontology *string `json:"ontology,omitempty"`

	// Comma separated list of fields to return: preferredName, semanticTypes, surfaceForms, typeahead, variants,
	// definition.  Defaults to all fields.
	Fields *string `json:"_fields,omitempty"`

	// Generate JSON output that is compatible with a d3 tree layout.  Default is false.
	TreeLayout *bool `json:"tree_layout,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetCuiInfoOptions : Instantiate GetCuiInfoOptions
func (*InsightsForMedicalLiteratureServiceV1) NewGetCuiInfoOptions(corpus string, nameOrID string) *GetCuiInfoOptions {
	return &GetCuiInfoOptions{
		Corpus:   core.StringPtr(corpus),
		NameOrID: core.StringPtr(nameOrID),
	}
}

// SetCorpus : Allow user to set Corpus
func (options *GetCuiInfoOptions) SetCorpus(corpus string) *GetCuiInfoOptions {
	options.Corpus = core.StringPtr(corpus)
	return options
}

// SetNameOrID : Allow user to set NameOrID
func (options *GetCuiInfoOptions) SetNameOrID(nameOrID string) *GetCuiInfoOptions {
	options.NameOrID = core.StringPtr(nameOrID)
	return options
}

// SetOntology : Allow user to set Ontology
func (options *GetCuiInfoOptions) SetOntology(ontology string) *GetCuiInfoOptions {
	options.Ontology = core.StringPtr(ontology)
	return options
}

// SetFields : Allow user to set Fields
func (options *GetCuiInfoOptions) SetFields(fields string) *GetCuiInfoOptions {
	options.Fields = core.StringPtr(fields)
	return options
}

// SetTreeLayout : Allow user to set TreeLayout
func (options *GetCuiInfoOptions) SetTreeLayout(treeLayout bool) *GetCuiInfoOptions {
	options.TreeLayout = core.BoolPtr(treeLayout)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetCuiInfoOptions) SetHeaders(param map[string]string) *GetCuiInfoOptions {
	options.Headers = param
	return options
}

// GetDocumentAnnotationsOptions : The GetDocumentAnnotations options.
type GetDocumentAnnotationsOptions struct {
	// Corpus name.
	Corpus *string `json:"corpus" validate:"required"`

	// Document ID.
	DocumentID *string `json:"document_id" validate:"required"`

	// Document section to annotate. (e.g., title, abstract, body...
	DocumentSection *string `json:"document_section" validate:"required"`

	// Concepts to show.  Defaults to all concepts.
	Cuis []string `json:"cuis,omitempty"`

	// Include document text.
	IncludeText *bool `json:"include_text,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetDocumentAnnotationsOptions : Instantiate GetDocumentAnnotationsOptions
func (*InsightsForMedicalLiteratureServiceV1) NewGetDocumentAnnotationsOptions(corpus string, documentID string, documentSection string) *GetDocumentAnnotationsOptions {
	return &GetDocumentAnnotationsOptions{
		Corpus:          core.StringPtr(corpus),
		DocumentID:      core.StringPtr(documentID),
		DocumentSection: core.StringPtr(documentSection),
	}
}

// SetCorpus : Allow user to set Corpus
func (options *GetDocumentAnnotationsOptions) SetCorpus(corpus string) *GetDocumentAnnotationsOptions {
	options.Corpus = core.StringPtr(corpus)
	return options
}

// SetDocumentID : Allow user to set DocumentID
func (options *GetDocumentAnnotationsOptions) SetDocumentID(documentID string) *GetDocumentAnnotationsOptions {
	options.DocumentID = core.StringPtr(documentID)
	return options
}

// SetDocumentSection : Allow user to set DocumentSection
func (options *GetDocumentAnnotationsOptions) SetDocumentSection(documentSection string) *GetDocumentAnnotationsOptions {
	options.DocumentSection = core.StringPtr(documentSection)
	return options
}

// SetCuis : Allow user to set Cuis
func (options *GetDocumentAnnotationsOptions) SetCuis(cuis []string) *GetDocumentAnnotationsOptions {
	options.Cuis = cuis
	return options
}

// SetIncludeText : Allow user to set IncludeText
func (options *GetDocumentAnnotationsOptions) SetIncludeText(includeText bool) *GetDocumentAnnotationsOptions {
	options.IncludeText = core.BoolPtr(includeText)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetDocumentAnnotationsOptions) SetHeaders(param map[string]string) *GetDocumentAnnotationsOptions {
	options.Headers = param
	return options
}

// GetDocumentCategoriesOptions : The GetDocumentCategories options.
type GetDocumentCategoriesOptions struct {
	// Corpus name.
	Corpus *string `json:"corpus" validate:"required"`

	// Document ID.
	DocumentID *string `json:"document_id" validate:"required"`

	// HTML tag used to highlight concepts found in the text.  Default is '&ltb&gt'.
	HighlightTagBegin *string `json:"highlight_tag_begin,omitempty"`

	// HTML tag used to highlight concepts found in the text.  Default is '&lt/b&gt'.
	HighlightTagEnd *string `json:"highlight_tag_end,omitempty"`

	// Select concepts belonging to these semantic types to return. Semantic types for the corpus can be found using the
	// /v1/corpora/{corpus}/types method.Defaults to 'all'.
	Types []string `json:"types,omitempty"`

	// Select concepts belonging to disorders, drugs or genes.
	Category *string `json:"category,omitempty"`

	// Only return negated concepts?.
	OnlyNegatedConcepts *bool `json:"only_negated_concepts,omitempty"`

	// Comma separated list of fields to return:  passages, annotations, highlightedTitle, highlightedAbstract,
	// highlightedBody, highlightedSections.
	Fields *string `json:"_fields,omitempty"`

	// Limit the number of passages per search concept (1 to 250).  Default is 50.
	Limit *int64 `json:"_limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the GetDocumentCategoriesOptions.Category property.
// Select concepts belonging to disorders, drugs or genes.
const (
	GetDocumentCategoriesOptions_Category_Disorders = "disorders"
	GetDocumentCategoriesOptions_Category_Drugs     = "drugs"
	GetDocumentCategoriesOptions_Category_Genes     = "genes"
)

// NewGetDocumentCategoriesOptions : Instantiate GetDocumentCategoriesOptions
func (*InsightsForMedicalLiteratureServiceV1) NewGetDocumentCategoriesOptions(corpus string, documentID string) *GetDocumentCategoriesOptions {
	return &GetDocumentCategoriesOptions{
		Corpus:     core.StringPtr(corpus),
		DocumentID: core.StringPtr(documentID),
	}
}

// SetCorpus : Allow user to set Corpus
func (options *GetDocumentCategoriesOptions) SetCorpus(corpus string) *GetDocumentCategoriesOptions {
	options.Corpus = core.StringPtr(corpus)
	return options
}

// SetDocumentID : Allow user to set DocumentID
func (options *GetDocumentCategoriesOptions) SetDocumentID(documentID string) *GetDocumentCategoriesOptions {
	options.DocumentID = core.StringPtr(documentID)
	return options
}

// SetHighlightTagBegin : Allow user to set HighlightTagBegin
func (options *GetDocumentCategoriesOptions) SetHighlightTagBegin(highlightTagBegin string) *GetDocumentCategoriesOptions {
	options.HighlightTagBegin = core.StringPtr(highlightTagBegin)
	return options
}

// SetHighlightTagEnd : Allow user to set HighlightTagEnd
func (options *GetDocumentCategoriesOptions) SetHighlightTagEnd(highlightTagEnd string) *GetDocumentCategoriesOptions {
	options.HighlightTagEnd = core.StringPtr(highlightTagEnd)
	return options
}

// SetTypes : Allow user to set Types
func (options *GetDocumentCategoriesOptions) SetTypes(types []string) *GetDocumentCategoriesOptions {
	options.Types = types
	return options
}

// SetCategory : Allow user to set Category
func (options *GetDocumentCategoriesOptions) SetCategory(category string) *GetDocumentCategoriesOptions {
	options.Category = core.StringPtr(category)
	return options
}

// SetOnlyNegatedConcepts : Allow user to set OnlyNegatedConcepts
func (options *GetDocumentCategoriesOptions) SetOnlyNegatedConcepts(onlyNegatedConcepts bool) *GetDocumentCategoriesOptions {
	options.OnlyNegatedConcepts = core.BoolPtr(onlyNegatedConcepts)
	return options
}

// SetFields : Allow user to set Fields
func (options *GetDocumentCategoriesOptions) SetFields(fields string) *GetDocumentCategoriesOptions {
	options.Fields = core.StringPtr(fields)
	return options
}

// SetLimit : Allow user to set Limit
func (options *GetDocumentCategoriesOptions) SetLimit(limit int64) *GetDocumentCategoriesOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetDocumentCategoriesOptions) SetHeaders(param map[string]string) *GetDocumentCategoriesOptions {
	options.Headers = param
	return options
}

// GetDocumentInfoOptions : The GetDocumentInfo options.
type GetDocumentInfoOptions struct {
	// Corpus name.
	Corpus *string `json:"corpus" validate:"required"`

	// Document ID.
	DocumentID *string `json:"document_id" validate:"required"`

	// Verbose output. If true, text for all document sections is returned.
	Verbose *bool `json:"verbose,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetDocumentInfoOptions : Instantiate GetDocumentInfoOptions
func (*InsightsForMedicalLiteratureServiceV1) NewGetDocumentInfoOptions(corpus string, documentID string) *GetDocumentInfoOptions {
	return &GetDocumentInfoOptions{
		Corpus:     core.StringPtr(corpus),
		DocumentID: core.StringPtr(documentID),
	}
}

// SetCorpus : Allow user to set Corpus
func (options *GetDocumentInfoOptions) SetCorpus(corpus string) *GetDocumentInfoOptions {
	options.Corpus = core.StringPtr(corpus)
	return options
}

// SetDocumentID : Allow user to set DocumentID
func (options *GetDocumentInfoOptions) SetDocumentID(documentID string) *GetDocumentInfoOptions {
	options.DocumentID = core.StringPtr(documentID)
	return options
}

// SetVerbose : Allow user to set Verbose
func (options *GetDocumentInfoOptions) SetVerbose(verbose bool) *GetDocumentInfoOptions {
	options.Verbose = core.BoolPtr(verbose)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetDocumentInfoOptions) SetHeaders(param map[string]string) *GetDocumentInfoOptions {
	options.Headers = param
	return options
}

// GetDocumentInfoResponse : GetDocumentInfoResponse struct
type GetDocumentInfoResponse struct {

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

// SetProperty allows the user to set an arbitrary property on an instance of GetDocumentInfoResponse
func (o *GetDocumentInfoResponse) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of GetDocumentInfoResponse
func (o *GetDocumentInfoResponse) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of GetDocumentInfoResponse
func (o *GetDocumentInfoResponse) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of GetDocumentInfoResponse
func (o *GetDocumentInfoResponse) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalGetDocumentInfoResponse constructs an instance of GetDocumentInfoResponse from the specified map.
func UnmarshalGetDocumentInfoResponse(m map[string]interface{}) (result *GetDocumentInfoResponse, err error) {
	m = core.CopyMap(m)
	obj := new(GetDocumentInfoResponse)
	for k := range m {
		v, e := core.UnmarshalAny(m, k)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	result = obj
	return
}

// UnmarshalGetDocumentInfoResponseSlice unmarshals a slice of GetDocumentInfoResponse instances from the specified list of maps.
func UnmarshalGetDocumentInfoResponseSlice(s []interface{}) (slice []GetDocumentInfoResponse, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'GetDocumentInfoResponse'")
			return
		}
		obj, e := UnmarshalGetDocumentInfoResponse(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalGetDocumentInfoResponseAsProperty unmarshals an instance of GetDocumentInfoResponse that is stored as a property
// within the specified map.
func UnmarshalGetDocumentInfoResponseAsProperty(m map[string]interface{}, propertyName string) (result *GetDocumentInfoResponse, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'GetDocumentInfoResponse'", propertyName)
			return
		}
		result, err = UnmarshalGetDocumentInfoResponse(objMap)
	}
	return
}

// UnmarshalGetDocumentInfoResponseSliceAsProperty unmarshals a slice of GetDocumentInfoResponse instances that are stored as a property
// within the specified map.
func UnmarshalGetDocumentInfoResponseSliceAsProperty(m map[string]interface{}, propertyName string) (slice []GetDocumentInfoResponse, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'GetDocumentInfoResponse'", propertyName)
			return
		}
		slice, err = UnmarshalGetDocumentInfoResponseSlice(vSlice)
	}
	return
}

// Category : Model object representing a semantic category.
type Category struct {
	// Category name.
	Name *string `json:"name" validate:"required"`

	// Category label.
	Category *string `json:"category,omitempty"`

	// Semantic types array.
	Types []string `json:"types,omitempty"`
}

// UnmarshalCateogry constructs an instance of Category from the specified map.
func UnmarshalCategory(m map[string]interface{}) (result *Category, err error) {
	obj := new(Category)
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Category, err = core.UnmarshalString(m, "categoy")
	if err != nil {
		return
	}
	obj.Types, err = core.UnmarshalStringSlice(m, "types")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalMetadataFieldsSlice unmarshals a slice of Category instances from the specified list of maps.
func UnmarshalCategorySlice(s []interface{}) (slice []Category, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'Category'")
			return
		}
		obj, e := UnmarshalCategory(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalCateogyAsProperty unmarshals an instance of Category that is stored as a property
// within the specified map.
func UnmarshalCategoryAsProperty(m map[string]interface{}, propertyName string) (result *Category, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'Category'", propertyName)
			return
		}
		result, err = UnmarshalCategory(objMap)
	}
	return
}

// UnmarshalMetadataFieldsSliceAsProperty unmarshals a slice of Category instances that are stored as a property
// within the specified map.
func UnmarshalCateegorySliceAsProperty(m map[string]interface{}, propertyName string) (slice []Category, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'Category'", propertyName)
			return
		}
		slice, err = UnmarshalCategorySlice(vSlice)
	}
	return
}

// GetDocumentMultipleCategoriesOptions : The GetDocumentMultipleCategories options.
type GetDocumentMultipleCategoriesOptions struct {
	// Corpus name.
	Corpus *string `json:"corpus" validate:"required"`

	// Document ID.
	DocumentID *string `json:"document_id" validate:"required"`

	// HTML tag used to highlight concepts found in the text.  Default is '&ltb&gt'.
	HighlightTagBegin *string `json:"highlight_tag_begin,omitempty"`

	// HTML tag used to highlight concepts found in the text.  Default is '&lt/b&gt'.
	HighlightTagEnd *string `json:"highlight_tag_end,omitempty"`

	// Comma separated list of fields to return:  passages, annotations, highlightedTitle, highlightedAbstract,
	// highlightedBody, highlightedSections.
	Fields *string `json:"_fields,omitempty"`

	// Limit the number of passages per search concept (1 to 250).  Default is 50.
	Limit *int64 `json:"_limit,omitempty"`

	// List of Category objects.
	Categories []Category `json:"categories" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetDocumentMultipleCategoriesOptions : Instantiate GetDocumentMultipleCategoriesOptions
func (*InsightsForMedicalLiteratureServiceV1) NewGetDocumentMultipleCategoriesOptions(corpus string,
	documentID string, categories []Category) *GetDocumentMultipleCategoriesOptions {
	return &GetDocumentMultipleCategoriesOptions{
		Corpus:     core.StringPtr(corpus),
		DocumentID: core.StringPtr(documentID),
		Categories: categories,
	}
}

// SetCategories : Allow user to set Categories
func (options *GetDocumentMultipleCategoriesOptions) SetCategories(categories []Category) *GetDocumentMultipleCategoriesOptions {
	options.Categories = categories
	return options
}

// SetCorpus : Allow user to set Corpus
func (options *GetDocumentMultipleCategoriesOptions) SetCorpus(corpus string) *GetDocumentMultipleCategoriesOptions {
	options.Corpus = core.StringPtr(corpus)
	return options
}

// SetDocumentID : Allow user to set DocumentID
func (options *GetDocumentMultipleCategoriesOptions) SetDocumentID(documentID string) *GetDocumentMultipleCategoriesOptions {
	options.DocumentID = core.StringPtr(documentID)
	return options
}

// SetHighlightTagBegin : Allow user to set HighlightTagBegin
func (options *GetDocumentMultipleCategoriesOptions) SetHighlightTagBegin(highlightTagBegin string) *GetDocumentMultipleCategoriesOptions {
	options.HighlightTagBegin = core.StringPtr(highlightTagBegin)
	return options
}

// SetHighlightTagEnd : Allow user to set HighlightTagEnd
func (options *GetDocumentMultipleCategoriesOptions) SetHighlightTagEnd(highlightTagEnd string) *GetDocumentMultipleCategoriesOptions {
	options.HighlightTagEnd = core.StringPtr(highlightTagEnd)
	return options
}

// SetFields : Allow user to set Fields
func (options *GetDocumentMultipleCategoriesOptions) SetFields(fields string) *GetDocumentMultipleCategoriesOptions {
	options.Fields = core.StringPtr(fields)
	return options
}

// SetLimit : Allow user to set Limit
func (options *GetDocumentMultipleCategoriesOptions) SetLimit(limit int64) *GetDocumentMultipleCategoriesOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetDocumentMultipleCategoriesOptions) SetHeaders(param map[string]string) *GetDocumentMultipleCategoriesOptions {
	options.Headers = param
	return options
}

// GetDocumentsOptions : The GetDocuments options.
type GetDocumentsOptions struct {
	// Corpus name.
	Corpus *string `json:"corpus" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetDocumentsOptions : Instantiate GetDocumentsOptions
func (*InsightsForMedicalLiteratureServiceV1) NewGetDocumentsOptions(corpus string) *GetDocumentsOptions {
	return &GetDocumentsOptions{
		Corpus: core.StringPtr(corpus),
	}
}

// SetCorpus : Allow user to set Corpus
func (options *GetDocumentsOptions) SetCorpus(corpus string) *GetDocumentsOptions {
	options.Corpus = core.StringPtr(corpus)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetDocumentsOptions) SetHeaders(param map[string]string) *GetDocumentsOptions {
	options.Headers = param
	return options
}

// GetFieldsOptions : The GetFields options.
type GetFieldsOptions struct {
	// Corpus name.
	Corpus *string `json:"corpus" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetFieldsOptions : Instantiate GetFieldsOptions
func (*InsightsForMedicalLiteratureServiceV1) NewGetFieldsOptions(corpus string) *GetFieldsOptions {
	return &GetFieldsOptions{
		Corpus: core.StringPtr(corpus),
	}
}

// SetCorpus : Allow user to set Corpus
func (options *GetFieldsOptions) SetCorpus(corpus string) *GetFieldsOptions {
	options.Corpus = core.StringPtr(corpus)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetFieldsOptions) SetHeaders(param map[string]string) *GetFieldsOptions {
	options.Headers = param
	return options
}

// GetHealthCheckStatusOptions : The GetHealthCheckStatus options.
type GetHealthCheckStatusOptions struct {
	// The type of the response: application/json or application/xml.
	Accept *string `json:"Accept,omitempty"`

	// Override response format.
	Format *string `json:"format,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the GetHealthCheckStatusOptions.Format property.
// Override response format.
const (
	GetHealthCheckStatusOptions_Format_JSON = "json"
	GetHealthCheckStatusOptions_Format_Xml  = "xml"
)

// NewGetHealthCheckStatusOptions : Instantiate GetHealthCheckStatusOptions
func (*InsightsForMedicalLiteratureServiceV1) NewGetHealthCheckStatusOptions() *GetHealthCheckStatusOptions {
	return &GetHealthCheckStatusOptions{}
}

// SetAccept : Allow user to set Accept
func (options *GetHealthCheckStatusOptions) SetAccept(accept string) *GetHealthCheckStatusOptions {
	options.Accept = core.StringPtr(accept)
	return options
}

// SetFormat : Allow user to set Format
func (options *GetHealthCheckStatusOptions) SetFormat(format string) *GetHealthCheckStatusOptions {
	options.Format = core.StringPtr(format)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetHealthCheckStatusOptions) SetHeaders(param map[string]string) *GetHealthCheckStatusOptions {
	options.Headers = param
	return options
}

// GetHitCountOptions : The GetHitCount options.
type GetHitCountOptions struct {
	// Corpus name.
	Corpus *string `json:"corpus" validate:"required"`

	// Preferred name or concept ID.
	NameOrID *string `json:"name_or_id" validate:"required"`

	// The ontology that defines the cui.
	Ontology *string `json:"ontology,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetHitCountOptions : Instantiate GetHitCountOptions
func (*InsightsForMedicalLiteratureServiceV1) NewGetHitCountOptions(corpus string, nameOrID string) *GetHitCountOptions {
	return &GetHitCountOptions{
		Corpus:   core.StringPtr(corpus),
		NameOrID: core.StringPtr(nameOrID),
	}
}

// SetCorpus : Allow user to set Corpus
func (options *GetHitCountOptions) SetCorpus(corpus string) *GetHitCountOptions {
	options.Corpus = core.StringPtr(corpus)
	return options
}

// SetNameOrID : Allow user to set NameOrID
func (options *GetHitCountOptions) SetNameOrID(nameOrID string) *GetHitCountOptions {
	options.NameOrID = core.StringPtr(nameOrID)
	return options
}

// SetOntology : Allow user to set Ontology
func (options *GetHitCountOptions) SetOntology(ontology string) *GetHitCountOptions {
	options.Ontology = core.StringPtr(ontology)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetHitCountOptions) SetHeaders(param map[string]string) *GetHitCountOptions {
	options.Headers = param
	return options
}

// GetRelatedConceptsOptions : The GetRelatedConcepts options.
type GetRelatedConceptsOptions struct {
	// Corpus name or null to show all ontology relationships.
	Corpus *string `json:"corpus" validate:"required"`

	// Preferred name or concept ID.
	NameOrID *string `json:"name_or_id" validate:"required"`

	// Select the relationship to retrieve.
	Relationship *string `json:"relationship" validate:"required"`

	// The ontology that defines the cui.
	Ontology *string `json:"ontology,omitempty"`

	// Select UMLS relationship attributes.  If null, all relationship attributes are returned.
	RelationshipAttributes []string `json:"relationship_attributes,omitempty"`

	// Select source vocabularies.  If null, concepts for all source vocabularies are returned.
	Sources []string `json:"sources,omitempty"`

	// Recursively return parents, children, broader and narrower relations.  Default is false.
	Recursive *bool `json:"recursive,omitempty"`

	// Generate JSON output that is compatible with a d3 tree layout.  Default is true.
	TreeLayout *bool `json:"tree_layout,omitempty"`

	// Maximum depth.  Default is 3.
	MaxDepth *int64 `json:"max_depth,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the GetRelatedConceptsOptions.Relationship property.
// Select the relationship to retrieve.
const (
	GetRelatedConceptsOptions_Relationship_Alike              = "alike"
	GetRelatedConceptsOptions_Relationship_Allowedqualifier   = "allowedQualifier"
	GetRelatedConceptsOptions_Relationship_Aq                 = "aq"
	GetRelatedConceptsOptions_Relationship_Broader            = "broader"
	GetRelatedConceptsOptions_Relationship_Chd                = "chd"
	GetRelatedConceptsOptions_Relationship_Children           = "children"
	GetRelatedConceptsOptions_Relationship_Narrower           = "narrower"
	GetRelatedConceptsOptions_Relationship_Notrelated         = "notRelated"
	GetRelatedConceptsOptions_Relationship_Other              = "other"
	GetRelatedConceptsOptions_Relationship_Par                = "par"
	GetRelatedConceptsOptions_Relationship_Parents            = "parents"
	GetRelatedConceptsOptions_Relationship_Qb                 = "qb"
	GetRelatedConceptsOptions_Relationship_Qualifiedby        = "qualifiedBy"
	GetRelatedConceptsOptions_Relationship_Rb                 = "rb"
	GetRelatedConceptsOptions_Relationship_Related            = "related"
	GetRelatedConceptsOptions_Relationship_Relatedunspecified = "relatedUnspecified"
	GetRelatedConceptsOptions_Relationship_Rl                 = "rl"
	GetRelatedConceptsOptions_Relationship_Rn                 = "rn"
	GetRelatedConceptsOptions_Relationship_Ro                 = "ro"
	GetRelatedConceptsOptions_Relationship_Rq                 = "rq"
	GetRelatedConceptsOptions_Relationship_Ru                 = "ru"
	GetRelatedConceptsOptions_Relationship_Sib                = "sib"
	GetRelatedConceptsOptions_Relationship_Siblings           = "siblings"
	GetRelatedConceptsOptions_Relationship_Sy                 = "sy"
	GetRelatedConceptsOptions_Relationship_Synonym            = "synonym"
	GetRelatedConceptsOptions_Relationship_Xr                 = "xr"
)

// NewGetRelatedConceptsOptions : Instantiate GetRelatedConceptsOptions
func (*InsightsForMedicalLiteratureServiceV1) NewGetRelatedConceptsOptions(corpus string, nameOrID string, relationship string) *GetRelatedConceptsOptions {
	return &GetRelatedConceptsOptions{
		Corpus:       core.StringPtr(corpus),
		NameOrID:     core.StringPtr(nameOrID),
		Relationship: core.StringPtr(relationship),
	}
}

// SetCorpus : Allow user to set Corpus
func (options *GetRelatedConceptsOptions) SetCorpus(corpus string) *GetRelatedConceptsOptions {
	options.Corpus = core.StringPtr(corpus)
	return options
}

// SetNameOrID : Allow user to set NameOrID
func (options *GetRelatedConceptsOptions) SetNameOrID(nameOrID string) *GetRelatedConceptsOptions {
	options.NameOrID = core.StringPtr(nameOrID)
	return options
}

// SetRelationship : Allow user to set Relationship
func (options *GetRelatedConceptsOptions) SetRelationship(relationship string) *GetRelatedConceptsOptions {
	options.Relationship = core.StringPtr(relationship)
	return options
}

// SetOntology : Allow user to set Ontology
func (options *GetRelatedConceptsOptions) SetOntology(ontology string) *GetRelatedConceptsOptions {
	options.Ontology = core.StringPtr(ontology)
	return options
}

// SetRelationshipAttributes : Allow user to set RelationshipAttributes
func (options *GetRelatedConceptsOptions) SetRelationshipAttributes(relationshipAttributes []string) *GetRelatedConceptsOptions {
	options.RelationshipAttributes = relationshipAttributes
	return options
}

// SetSources : Allow user to set Sources
func (options *GetRelatedConceptsOptions) SetSources(sources []string) *GetRelatedConceptsOptions {
	options.Sources = sources
	return options
}

// SetRecursive : Allow user to set Recursive
func (options *GetRelatedConceptsOptions) SetRecursive(recursive bool) *GetRelatedConceptsOptions {
	options.Recursive = core.BoolPtr(recursive)
	return options
}

// SetTreeLayout : Allow user to set TreeLayout
func (options *GetRelatedConceptsOptions) SetTreeLayout(treeLayout bool) *GetRelatedConceptsOptions {
	options.TreeLayout = core.BoolPtr(treeLayout)
	return options
}

// SetMaxDepth : Allow user to set MaxDepth
func (options *GetRelatedConceptsOptions) SetMaxDepth(maxDepth int64) *GetRelatedConceptsOptions {
	options.MaxDepth = core.Int64Ptr(maxDepth)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetRelatedConceptsOptions) SetHeaders(param map[string]string) *GetRelatedConceptsOptions {
	options.Headers = param
	return options
}

// GetSearchMatchesOptions : The GetSearchMatches options.
type GetSearchMatchesOptions struct {
	// Corpus name.
	Corpus *string `json:"corpus" validate:"required"`

	// Document ID (e.g, 7014026).
	DocumentID *string `json:"document_id" validate:"required"`

	// Minimum score .0 to 1.0.
	MinScore *float32 `json:"min_score" validate:"required"`

	// cui[,rank,[type]] - Example: "C0030567,10". The rank is an optional value from 0 to 10 (defalut is 10). Special rank
	// values: 0=omit, 10=require. Related concepts can also be included by appending, '-PAR' (parents), '-CHD' (children),
	// or '-SIB' (siblings) to the CUI (eg., to include all children of C0030567: 'C0030567-CHD')).  The type may
	// explicitly select a semanic type for a concept.  If no type is specified, a default type is selected.
	Cuis []string `json:"cuis,omitempty"`

	// Case insensitive text searches.
	Text []string `json:"text,omitempty"`

	// Highlight all text spans matching these semantic types.  Semantic types for the corpus can be found using the
	// /v1/corpora/{corpus}/types method.
	Types []string `json:"types,omitempty"`

	// Highlight all text spans matching these attributes.  An attribute may also specify a range value (e.g.,
	// age:years:65-100) or  a string value (e.g., gender:female).  The attribute may be qualified with one or more
	// qualifiers (e.g., Treated,Severe>>diabetes)  An attribute may target a specific CUI.  (e.g., C0003864::disease).
	Attributes []string `json:"attributes,omitempty"`

	// Highlight all text spans matching these values.  e.g., age:years:within:65-100 or gender:female  a string value
	// (e.g., gender:female).
	Values []string `json:"values,omitempty"`

	// Highlight all text spans matching these NLU relations.  e.g., druggroup,treat,indication.
	NluRelations []string `json:"nlu_relations,omitempty"`

	// Limit the number of matching passages per search concept/search term (1 to 250).  Default is 50.
	Limit *int64 `json:"_limit,omitempty"`

	// HTML tag used to highlight search concepts found in the text.  Default is '&ltb&gt'.
	SearchTagBegin *string `json:"search_tag_begin,omitempty"`

	// HTML tag used to highlight search concepts found in the text.  Default is '&lt/b&gt'.
	SearchTagEnd *string `json:"search_tag_end,omitempty"`

	// HTML tag used to highlight related concepts found in the text.
	RelatedTagBegin *string `json:"related_tag_begin,omitempty"`

	// HTML tag used to highlight related concepts found in the text.
	RelatedTagEnd *string `json:"related_tag_end,omitempty"`

	// Comma separated list of fields to return:  passages, annotations, highlightedTitle, highlightedAbstract,
	// highlightedBody, highlightedSections.
	Fields *string `json:"_fields,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSearchMatchesOptions : Instantiate GetSearchMatchesOptions
func (*InsightsForMedicalLiteratureServiceV1) NewGetSearchMatchesOptions(corpus string, documentID string, minScore float32) *GetSearchMatchesOptions {
	return &GetSearchMatchesOptions{
		Corpus:     core.StringPtr(corpus),
		DocumentID: core.StringPtr(documentID),
		MinScore:   core.Float32Ptr(minScore),
	}
}

// SetCorpus : Allow user to set Corpus
func (options *GetSearchMatchesOptions) SetCorpus(corpus string) *GetSearchMatchesOptions {
	options.Corpus = core.StringPtr(corpus)
	return options
}

// SetDocumentID : Allow user to set DocumentID
func (options *GetSearchMatchesOptions) SetDocumentID(documentID string) *GetSearchMatchesOptions {
	options.DocumentID = core.StringPtr(documentID)
	return options
}

// SetMinScore : Allow user to set MinScore
func (options *GetSearchMatchesOptions) SetMinScore(minScore float32) *GetSearchMatchesOptions {
	options.MinScore = core.Float32Ptr(minScore)
	return options
}

// SetCuis : Allow user to set Cuis
func (options *GetSearchMatchesOptions) SetCuis(cuis []string) *GetSearchMatchesOptions {
	options.Cuis = cuis
	return options
}

// SetText : Allow user to set Text
func (options *GetSearchMatchesOptions) SetText(text []string) *GetSearchMatchesOptions {
	options.Text = text
	return options
}

// SetTypes : Allow user to set Types
func (options *GetSearchMatchesOptions) SetTypes(types []string) *GetSearchMatchesOptions {
	options.Types = types
	return options
}

// SetAttributes : Allow user to set Attributes
func (options *GetSearchMatchesOptions) SetAttributes(attributes []string) *GetSearchMatchesOptions {
	options.Attributes = attributes
	return options
}

// SetValues : Allow user to set Values
func (options *GetSearchMatchesOptions) SetValues(values []string) *GetSearchMatchesOptions {
	options.Values = values
	return options
}

// SetNluRelations : Allow user to set NluRelations
func (options *GetSearchMatchesOptions) SetNluRelations(nluRelations []string) *GetSearchMatchesOptions {
	options.NluRelations = nluRelations
	return options
}

// SetLimit : Allow user to set Limit
func (options *GetSearchMatchesOptions) SetLimit(limit int64) *GetSearchMatchesOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetSearchTagBegin : Allow user to set SearchTagBegin
func (options *GetSearchMatchesOptions) SetSearchTagBegin(searchTagBegin string) *GetSearchMatchesOptions {
	options.SearchTagBegin = core.StringPtr(searchTagBegin)
	return options
}

// SetSearchTagEnd : Allow user to set SearchTagEnd
func (options *GetSearchMatchesOptions) SetSearchTagEnd(searchTagEnd string) *GetSearchMatchesOptions {
	options.SearchTagEnd = core.StringPtr(searchTagEnd)
	return options
}

// SetRelatedTagBegin : Allow user to set RelatedTagBegin
func (options *GetSearchMatchesOptions) SetRelatedTagBegin(relatedTagBegin string) *GetSearchMatchesOptions {
	options.RelatedTagBegin = core.StringPtr(relatedTagBegin)
	return options
}

// SetRelatedTagEnd : Allow user to set RelatedTagEnd
func (options *GetSearchMatchesOptions) SetRelatedTagEnd(relatedTagEnd string) *GetSearchMatchesOptions {
	options.RelatedTagEnd = core.StringPtr(relatedTagEnd)
	return options
}

// SetFields : Allow user to set Fields
func (options *GetSearchMatchesOptions) SetFields(fields string) *GetSearchMatchesOptions {
	options.Fields = core.StringPtr(fields)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetSearchMatchesOptions) SetHeaders(param map[string]string) *GetSearchMatchesOptions {
	options.Headers = param
	return options
}

// GetServiceStatusOptions : The GetServiceStatus options.
type GetServiceStatusOptions struct {
	// The type of the response: application/json or application/xml.
	Accept *string `json:"Accept,omitempty"`

	// Override response format.
	Format *string `json:"format,omitempty"`

	// Perform a shallow liveness check.
	LivenessCheck *string `json:"liveness_check,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the GetServiceStatusOptions.Format property.
// Override response format.
const (
	GetServiceStatusOptions_Format_JSON = "json"
	GetServiceStatusOptions_Format_Xml  = "xml"
)

// Constants associated with the GetServiceStatusOptions.LivenessCheck property.
// Perform a shallow liveness check.
const (
	GetServiceStatusOptions_LivenessCheck_False = "false"
	GetServiceStatusOptions_LivenessCheck_True  = "true"
)

// NewGetServiceStatusOptions : Instantiate GetServiceStatusOptions
func (*InsightsForMedicalLiteratureServiceV1) NewGetServiceStatusOptions() *GetServiceStatusOptions {
	return &GetServiceStatusOptions{}
}

// SetAccept : Allow user to set Accept
func (options *GetServiceStatusOptions) SetAccept(accept string) *GetServiceStatusOptions {
	options.Accept = core.StringPtr(accept)
	return options
}

// SetFormat : Allow user to set Format
func (options *GetServiceStatusOptions) SetFormat(format string) *GetServiceStatusOptions {
	options.Format = core.StringPtr(format)
	return options
}

// SetLivenessCheck : Allow user to set LivenessCheck
func (options *GetServiceStatusOptions) SetLivenessCheck(livenessCheck string) *GetServiceStatusOptions {
	options.LivenessCheck = core.StringPtr(livenessCheck)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetServiceStatusOptions) SetHeaders(param map[string]string) *GetServiceStatusOptions {
	options.Headers = param
	return options
}

// GetSimilarConceptsOptions : The GetSimilarConcepts options.
type GetSimilarConceptsOptions struct {
	// Corpus name.
	Corpus *string `json:"corpus" validate:"required"`

	// Preferred name or concept ID.
	NameOrID *string `json:"name_or_id" validate:"required"`

	// Return similar concepts from any of these ontologites.
	ReturnOntologies []string `json:"return_ontologies" validate:"required"`

	// The ontology that defines the cui.
	Ontology *string `json:"ontology,omitempty"`

	// Number of possible concepts to return. Default is 250.
	Limit *int64 `json:"_limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSimilarConceptsOptions : Instantiate GetSimilarConceptsOptions
func (*InsightsForMedicalLiteratureServiceV1) NewGetSimilarConceptsOptions(corpus string, nameOrID string, returnOntologies []string) *GetSimilarConceptsOptions {
	return &GetSimilarConceptsOptions{
		Corpus:           core.StringPtr(corpus),
		NameOrID:         core.StringPtr(nameOrID),
		ReturnOntologies: returnOntologies,
	}
}

// SetCorpus : Allow user to set Corpus
func (options *GetSimilarConceptsOptions) SetCorpus(corpus string) *GetSimilarConceptsOptions {
	options.Corpus = core.StringPtr(corpus)
	return options
}

// SetNameOrID : Allow user to set NameOrID
func (options *GetSimilarConceptsOptions) SetNameOrID(nameOrID string) *GetSimilarConceptsOptions {
	options.NameOrID = core.StringPtr(nameOrID)
	return options
}

// SetReturnOntologies : Allow user to set ReturnOntologies
func (options *GetSimilarConceptsOptions) SetReturnOntologies(returnOntologies []string) *GetSimilarConceptsOptions {
	options.ReturnOntologies = returnOntologies
	return options
}

// SetOntology : Allow user to set Ontology
func (options *GetSimilarConceptsOptions) SetOntology(ontology string) *GetSimilarConceptsOptions {
	options.Ontology = core.StringPtr(ontology)
	return options
}

// SetLimit : Allow user to set Limit
func (options *GetSimilarConceptsOptions) SetLimit(limit int64) *GetSimilarConceptsOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetSimilarConceptsOptions) SetHeaders(param map[string]string) *GetSimilarConceptsOptions {
	options.Headers = param
	return options
}

// GetStatisticsOptions : The GetStatistics options.
type GetStatisticsOptions struct {
	// Corpus name.
	Corpus *string `json:"corpus" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetStatisticsOptions : Instantiate GetStatisticsOptions
func (*InsightsForMedicalLiteratureServiceV1) NewGetStatisticsOptions(corpus string) *GetStatisticsOptions {
	return &GetStatisticsOptions{
		Corpus: core.StringPtr(corpus),
	}
}

// SetCorpus : Allow user to set Corpus
func (options *GetStatisticsOptions) SetCorpus(corpus string) *GetStatisticsOptions {
	options.Corpus = core.StringPtr(corpus)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetStatisticsOptions) SetHeaders(param map[string]string) *GetStatisticsOptions {
	options.Headers = param
	return options
}

// Message : Object representing repository message.
type Message struct {
	// Message semantic type.
	MessageType *string `json:"messageType,omitempty"`

	// Message link.
	URL *string `json:"url,omitempty"`

	// Message request.
	Request interface{} `json:"request,omitempty"`

	// Request headers.
	Headers []string `json:"headers,omitempty"`

	// Message status.
	Status *int64 `json:"status,omitempty"`

	// Message response.
	Response interface{} `json:"response,omitempty"`
}

// Constants associated with the Message.MessageType property.
// Message semantic type.
const (
	Message_MessageType_ElasticSearch   = "elastic_search"
	Message_MessageType_ExpandedRequest = "expanded_request"
)

// UnmarshalMessage constructs an instance of Message from the specified map.
func UnmarshalMessage(m map[string]interface{}) (result *Message, err error) {
	obj := new(Message)
	obj.MessageType, err = core.UnmarshalString(m, "messageType")
	if err != nil {
		return
	}
	obj.URL, err = core.UnmarshalString(m, "url")
	if err != nil {
		return
	}
	obj.Request, err = core.UnmarshalAny(m, "request")
	if err != nil {
		return
	}
	obj.Headers, err = core.UnmarshalStringSlice(m, "headers")
	if err != nil {
		return
	}
	obj.Status, err = core.UnmarshalInt64(m, "status")
	if err != nil {
		return
	}
	obj.Response, err = core.UnmarshalAny(m, "response")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalMessageSlice unmarshals a slice of Message instances from the specified list of maps.
func UnmarshalMessageSlice(s []interface{}) (slice []Message, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'Message'")
			return
		}
		obj, e := UnmarshalMessage(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalMessageAsProperty unmarshals an instance of Message that is stored as a property
// within the specified map.
func UnmarshalMessageAsProperty(m map[string]interface{}, propertyName string) (result *Message, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'Message'", propertyName)
			return
		}
		result, err = UnmarshalMessage(objMap)
	}
	return
}

// UnmarshalMessageSliceAsProperty unmarshals a slice of Message instances that are stored as a property
// within the specified map.
func UnmarshalMessageSliceAsProperty(m map[string]interface{}, propertyName string) (slice []Message, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'Message'", propertyName)
			return
		}
		slice, err = UnmarshalMessageSlice(vSlice)
	}
	return
}

// MetadataFields : MetadataFields struct
type MetadataFields struct {
	// Corpus name.
	Corpus *string `json:"corpus,omitempty"`

	// Corpus description.
	CorpusDescription *string `json:"corpusDescription,omitempty"`

	// Metadata fields.
	Fields map[string][]string `json:"fields,omitempty"`
}

// UnmarshalMetadataFields constructs an instance of MetadataFields from the specified map.
func UnmarshalMetadataFields(m map[string]interface{}) (result *MetadataFields, err error) {
	obj := new(MetadataFields)
	obj.Corpus, err = core.UnmarshalString(m, "corpus")
	if err != nil {
		return
	}
	obj.CorpusDescription, err = core.UnmarshalString(m, "corpusDescription")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalMetadataFieldsSlice unmarshals a slice of MetadataFields instances from the specified list of maps.
func UnmarshalMetadataFieldsSlice(s []interface{}) (slice []MetadataFields, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'MetadataFields'")
			return
		}
		obj, e := UnmarshalMetadataFields(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalMetadataFieldsAsProperty unmarshals an instance of MetadataFields that is stored as a property
// within the specified map.
func UnmarshalMetadataFieldsAsProperty(m map[string]interface{}, propertyName string) (result *MetadataFields, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'MetadataFields'", propertyName)
			return
		}
		result, err = UnmarshalMetadataFields(objMap)
	}
	return
}

// UnmarshalMetadataFieldsSliceAsProperty unmarshals a slice of MetadataFields instances that are stored as a property
// within the specified map.
func UnmarshalMetadataFieldsSliceAsProperty(m map[string]interface{}, propertyName string) (slice []MetadataFields, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'MetadataFields'", propertyName)
			return
		}
		slice, err = UnmarshalMetadataFieldsSlice(vSlice)
	}
	return
}

// MonitorCorpusOptions : The MonitorCorpus options.
type MonitorCorpusOptions struct {
	// Apikey with read only permissions for monitoring.
	Apikey *string `json:"apikey" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewMonitorCorpusOptions : Instantiate MonitorCorpusOptions
func (*InsightsForMedicalLiteratureServiceV1) NewMonitorCorpusOptions(apikey string) *MonitorCorpusOptions {
	return &MonitorCorpusOptions{
		Apikey: core.StringPtr(apikey),
	}
}

// SetApikey : Allow user to set Apikey
func (options *MonitorCorpusOptions) SetApikey(apikey string) *MonitorCorpusOptions {
	options.Apikey = core.StringPtr(apikey)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *MonitorCorpusOptions) SetHeaders(param map[string]string) *MonitorCorpusOptions {
	options.Headers = param
	return options
}

// PassagesModel : PassagesModel struct
type PassagesModel struct {
	// Document passages.
	AllPassages []Passage `json:"allPassages,omitempty"`

	// Search term to passages.
	SearchTermToPassages map[string][]Passage `json:"searchTermToPassages,omitempty"`
}

// UnmarshalPassagesModel constructs an instance of PassagesModel from the specified map.
func UnmarshalPassagesModel(m map[string]interface{}) (result *PassagesModel, err error) {
	obj := new(PassagesModel)
	obj.AllPassages, err = UnmarshalPassageSliceAsProperty(m, "allPassages")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalPassagesModelSlice unmarshals a slice of PassagesModel instances from the specified list of maps.
func UnmarshalPassagesModelSlice(s []interface{}) (slice []PassagesModel, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'PassagesModel'")
			return
		}
		obj, e := UnmarshalPassagesModel(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalPassagesModelAsProperty unmarshals an instance of PassagesModel that is stored as a property
// within the specified map.
func UnmarshalPassagesModelAsProperty(m map[string]interface{}, propertyName string) (result *PassagesModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'PassagesModel'", propertyName)
			return
		}
		result, err = UnmarshalPassagesModel(objMap)
	}
	return
}

// UnmarshalPassagesModelSliceAsProperty unmarshals a slice of PassagesModel instances that are stored as a property
// within the specified map.
func UnmarshalPassagesModelSliceAsProperty(m map[string]interface{}, propertyName string) (slice []PassagesModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'PassagesModel'", propertyName)
			return
		}
		slice, err = UnmarshalPassagesModelSlice(vSlice)
	}
	return
}

// PossbileValues : PossbileValues struct
type PossbileValues struct {
	DisplayValue *string `json:"displayValue,omitempty"`

	Value *string `json:"value,omitempty"`
}

// UnmarshalPossbileValues constructs an instance of PossbileValues from the specified map.
func UnmarshalPossbileValues(m map[string]interface{}) (result *PossbileValues, err error) {
	obj := new(PossbileValues)
	obj.DisplayValue, err = core.UnmarshalString(m, "displayValue")
	if err != nil {
		return
	}
	obj.Value, err = core.UnmarshalString(m, "value")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalPossbileValuesSlice unmarshals a slice of PossbileValues instances from the specified list of maps.
func UnmarshalPossbileValuesSlice(s []interface{}) (slice []PossbileValues, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'PossbileValues'")
			return
		}
		obj, e := UnmarshalPossbileValues(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalPossbileValuesAsProperty unmarshals an instance of PossbileValues that is stored as a property
// within the specified map.
func UnmarshalPossbileValuesAsProperty(m map[string]interface{}, propertyName string) (result *PossbileValues, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'PossbileValues'", propertyName)
			return
		}
		result, err = UnmarshalPossbileValues(objMap)
	}
	return
}

// UnmarshalPossbileValuesSliceAsProperty unmarshals a slice of PossbileValues instances that are stored as a property
// within the specified map.
func UnmarshalPossbileValuesSliceAsProperty(m map[string]interface{}, propertyName string) (slice []PossbileValues, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'PossbileValues'", propertyName)
			return
		}
		slice, err = UnmarshalPossbileValuesSlice(vSlice)
	}
	return
}

// RankedDocLinks : RankedDocLinks struct
type RankedDocLinks struct {
	// Links for search matches.
	HrefSearchMatches *string `json:"hrefSearchMatches,omitempty"`

	// Links for categorized search matches.
	HrefCategories *string `json:"hrefCategories,omitempty"`
}

// UnmarshalRankedDocLinks constructs an instance of RankedDocLinks from the specified map.
func UnmarshalRankedDocLinks(m map[string]interface{}) (result *RankedDocLinks, err error) {
	obj := new(RankedDocLinks)
	obj.HrefSearchMatches, err = core.UnmarshalString(m, "hrefSearchMatches")
	if err != nil {
		return
	}
	obj.HrefCategories, err = core.UnmarshalString(m, "hrefCategories")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalRankedDocLinksSlice unmarshals a slice of RankedDocLinks instances from the specified list of maps.
func UnmarshalRankedDocLinksSlice(s []interface{}) (slice []RankedDocLinks, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'RankedDocLinks'")
			return
		}
		obj, e := UnmarshalRankedDocLinks(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalRankedDocLinksAsProperty unmarshals an instance of RankedDocLinks that is stored as a property
// within the specified map.
func UnmarshalRankedDocLinksAsProperty(m map[string]interface{}, propertyName string) (result *RankedDocLinks, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'RankedDocLinks'", propertyName)
			return
		}
		result, err = UnmarshalRankedDocLinks(objMap)
	}
	return
}

// UnmarshalRankedDocLinksSliceAsProperty unmarshals a slice of RankedDocLinks instances that are stored as a property
// within the specified map.
func UnmarshalRankedDocLinksSliceAsProperty(m map[string]interface{}, propertyName string) (slice []RankedDocLinks, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'RankedDocLinks'", propertyName)
			return
		}
		slice, err = UnmarshalRankedDocLinksSlice(vSlice)
	}
	return
}

// SearchOptions : The Search options.
type SearchOptions struct {
	// Corpus name.
	Corpus *string `json:"corpus" validate:"required"`

	// Define the query using JSON.<script>function setSearchApiBody(e,file) {$.get(file).done(function(text) {
	// $(e.target).closest('td').prev('td').find('textarea').val(text);})}</script><p>Try sample queries:<ul
	// style='margin-top: 0; list-style:none; padding-left:0;'><li><span style='text-decoration: underline; cursor:
	// pointer;' onclick='setSearchApiBody(event, "conceptSearch.json")'><a>Concept Search</a></span></li><li><span
	// style='text-decoration: underline; cursor: pointer;' onclick='setSearchApiBody(event,
	// "conceptsAggregation.json")'><a>Concepts Aggregation</a></span></li><li><span style='text-decoration: underline;
	// cursor: pointer;' onclick='setSearchApiBody(event, "keywordSearch.json")'><a>Keyword Search</a></span></li><li><span
	// style='text-decoration: underline; cursor: pointer;' onclick='setSearchApiBody(event,
	// "attributeSearch.json")'><a>Attribute Search</a></span></li><li><span style='text-decoration: underline; cursor:
	// pointer;' onclick='setSearchApiBody(event, "types.json")'><a>Get Semantic Types</a></span></li><li><span
	// style='text-decoration: underline; cursor: pointer;' onclick='setSearchApiBody(event,
	// "attributes.json")'><a>Attributes</a></span></li><li><span style='text-decoration: underline; cursor: pointer;'
	// onclick='setSearchApiBody(event, "attributeTypeahead.json")'><a>Attribute Typeahead</a></span></li><li><span
	// style='text-decoration: underline; cursor: pointer;' onclick='setSearchApiBody(event,
	// "conceptTypeahead.json")'><a>Concept Typeahead</a></span></li><li><span style='text-decoration: underline; cursor:
	// pointer;' onclick='setSearchApiBody(event, "passages.json")'><a>Passages</a></span></li><li><span
	// style='text-decoration: underline; cursor: pointer;' onclick='setSearchApiBody(event,
	// "authorSearch.json")'><a>Author Search</a></span></li><li><span style='text-decoration: underline; cursor: pointer;'
	// onclick='setSearchApiBody(event, "authorsAggregation.json")'><a>Author Aggregation</a></span></li><li><span
	// style='text-decoration: underline; cursor: pointer;' onclick='setSearchApiBody(event,
	// "authorTypeahead.json")'><a>Author Typeahead</a></span></li><li><span style='text-decoration: underline; cursor:
	// pointer;' onclick='setSearchApiBody(event, "titleTypeahead.json")'><a>Title Typeahead</a></span></li><li><span
	// style='text-decoration: underline; cursor: pointer;' onclick='setSearchApiBody(event, "dateHistogram.json")'><a>Date
	// Histogram</a></span></li><li><span style='text-decoration: underline; cursor: pointer;'
	// onclick='setSearchApiBody(event, "dateRange.json")'><a>Date Range</a></span></li><li><span style='text-decoration:
	// underline; cursor: pointer;' onclick='setSearchApiBody(event, "advancedSearch.json")'><a>Advanced
	// Search</a></span></li></ul>.
	Body *string `json:"body" validate:"required"`

	// Verbose output.
	Verbose *bool `json:"verbose,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewSearchOptions : Instantiate SearchOptions
func (*InsightsForMedicalLiteratureServiceV1) NewSearchOptions(corpus string, body string) *SearchOptions {
	return &SearchOptions{
		Corpus: core.StringPtr(corpus),
		Body:   core.StringPtr(body),
	}
}

// SetCorpus : Allow user to set Corpus
func (options *SearchOptions) SetCorpus(corpus string) *SearchOptions {
	options.Corpus = core.StringPtr(corpus)
	return options
}

// SetBody : Allow user to set Body
func (options *SearchOptions) SetBody(body string) *SearchOptions {
	options.Body = core.StringPtr(body)
	return options
}

// SetVerbose : Allow user to set Verbose
func (options *SearchOptions) SetVerbose(verbose bool) *SearchOptions {
	options.Verbose = core.BoolPtr(verbose)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *SearchOptions) SetHeaders(param map[string]string) *SearchOptions {
	options.Headers = param
	return options
}

// SetCorpusConfigOptions : The SetCorpusConfig options.
type SetCorpusConfigOptions struct {
	// Repository connection userid.
	UserName *string `json:"userName,omitempty"`

	// Repository connection password.
	Password *string `json:"password,omitempty"`

	// Repository connection URI.
	CorpusURI *string `json:"corpusURI,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewSetCorpusConfigOptions : Instantiate SetCorpusConfigOptions
func (*InsightsForMedicalLiteratureServiceV1) NewSetCorpusConfigOptions() *SetCorpusConfigOptions {
	return &SetCorpusConfigOptions{}
}

// SetUserName : Allow user to set UserName
func (options *SetCorpusConfigOptions) SetUserName(userName string) *SetCorpusConfigOptions {
	options.UserName = core.StringPtr(userName)
	return options
}

// SetPassword : Allow user to set Password
func (options *SetCorpusConfigOptions) SetPassword(password string) *SetCorpusConfigOptions {
	options.Password = core.StringPtr(password)
	return options
}

// SetCorpusURI : Allow user to set CorpusURI
func (options *SetCorpusConfigOptions) SetCorpusURI(corpusURI string) *SetCorpusConfigOptions {
	options.CorpusURI = core.StringPtr(corpusURI)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *SetCorpusConfigOptions) SetHeaders(param map[string]string) *SetCorpusConfigOptions {
	options.Headers = param
	return options
}

// SetCorpusSchemaOptions : The SetCorpusSchema options.
type SetCorpusSchemaOptions struct {
	// Input and Output field names.
	EnrichmentTargets []interface{} `json:"enrichmentTargets,omitempty"`

	// Metadata field names.
	MetadataFields []interface{} `json:"metadataFields,omitempty"`

	// Corpus name.
	CorpusName *string `json:"corpusName,omitempty"`

	// Reference indices.
	References map[string]interface{} `json:"references,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewSetCorpusSchemaOptions : Instantiate SetCorpusSchemaOptions
func (*InsightsForMedicalLiteratureServiceV1) NewSetCorpusSchemaOptions() *SetCorpusSchemaOptions {
	return &SetCorpusSchemaOptions{}
}

// SetEnrichmentTargets : Allow user to set EnrichmentTargets
func (options *SetCorpusSchemaOptions) SetEnrichmentTargets(enrichmentTargets []interface{}) *SetCorpusSchemaOptions {
	options.EnrichmentTargets = enrichmentTargets
	return options
}

// SetMetadataFields : Allow user to set MetadataFields
func (options *SetCorpusSchemaOptions) SetMetadataFields(metadataFields []interface{}) *SetCorpusSchemaOptions {
	options.MetadataFields = metadataFields
	return options
}

// SetCorpusName : Allow user to set CorpusName
func (options *SetCorpusSchemaOptions) SetCorpusName(corpusName string) *SetCorpusSchemaOptions {
	options.CorpusName = core.StringPtr(corpusName)
	return options
}

// SetReferences : Allow user to set References
func (options *SetCorpusSchemaOptions) SetReferences(references map[string]interface{}) *SetCorpusSchemaOptions {
	options.References = references
	return options
}

// SetHeaders : Allow user to set Headers
func (options *SetCorpusSchemaOptions) SetHeaders(param map[string]string) *SetCorpusSchemaOptions {
	options.Headers = param
	return options
}

// StringBuilder : StringBuilder struct
type StringBuilder struct {
}

// UnmarshalStringBuilder constructs an instance of StringBuilder from the specified map.
func UnmarshalStringBuilder(m map[string]interface{}) (result *StringBuilder, err error) {
	obj := new(StringBuilder)
	result = obj
	return
}

// UnmarshalStringBuilderSlice unmarshals a slice of StringBuilder instances from the specified list of maps.
func UnmarshalStringBuilderSlice(s []interface{}) (slice []StringBuilder, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'StringBuilder'")
			return
		}
		obj, e := UnmarshalStringBuilder(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalStringBuilderAsProperty unmarshals an instance of StringBuilder that is stored as a property
// within the specified map.
func UnmarshalStringBuilderAsProperty(m map[string]interface{}, propertyName string) (result *StringBuilder, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'StringBuilder'", propertyName)
			return
		}
		result, err = UnmarshalStringBuilder(objMap)
	}
	return
}

// UnmarshalStringBuilderSliceAsProperty unmarshals a slice of StringBuilder instances that are stored as a property
// within the specified map.
func UnmarshalStringBuilderSliceAsProperty(m map[string]interface{}, propertyName string) (slice []StringBuilder, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'StringBuilder'", propertyName)
			return
		}
		slice, err = UnmarshalStringBuilderSlice(vSlice)
	}
	return
}

// TokenizeOptions : The Tokenize options.
type TokenizeOptions struct {
	// Corpus name.
	Corpus *string `json:"corpus" validate:"required"`

	// Flow name (not used).
	Flow *string `json:"flow" validate:"required"`

	// Text.
	Body *string `json:"body" validate:"required"`

	// Detect artifacts in the selected ontology(ies).
	Ontologies []string `json:"ontologies,omitempty"`

	// Maximum number of words per detected surface form. Default is 4.
	MaxWords *int64 `json:"max_words,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the TokenizeOptions.Ontologies property.
const (
	TokenizeOptions_Ontologies_Concepts = "concepts"
	TokenizeOptions_Ontologies_Mesh     = "mesh"
)

// NewTokenizeOptions : Instantiate TokenizeOptions
func (*InsightsForMedicalLiteratureServiceV1) NewTokenizeOptions(corpus string, flow string, body string) *TokenizeOptions {
	return &TokenizeOptions{
		Corpus: core.StringPtr(corpus),
		Flow:   core.StringPtr(flow),
		Body:   core.StringPtr(body),
	}
}

// SetCorpus : Allow user to set Corpus
func (options *TokenizeOptions) SetCorpus(corpus string) *TokenizeOptions {
	options.Corpus = core.StringPtr(corpus)
	return options
}

// SetFlow : Allow user to set Flow
func (options *TokenizeOptions) SetFlow(flow string) *TokenizeOptions {
	options.Flow = core.StringPtr(flow)
	return options
}

// SetBody : Allow user to set Body
func (options *TokenizeOptions) SetBody(body string) *TokenizeOptions {
	options.Body = core.StringPtr(body)
	return options
}

// SetOntologies : Allow user to set Ontologies
func (options *TokenizeOptions) SetOntologies(ontologies []string) *TokenizeOptions {
	options.Ontologies = ontologies
	return options
}

// SetMaxWords : Allow user to set MaxWords
func (options *TokenizeOptions) SetMaxWords(maxWords int64) *TokenizeOptions {
	options.MaxWords = core.Int64Ptr(maxWords)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *TokenizeOptions) SetHeaders(param map[string]string) *TokenizeOptions {
	options.Headers = param
	return options
}

// TypeaheadOptions : The Typeahead options.
type TypeaheadOptions struct {
	// Comma-separated corpora names.
	Corpus *string `json:"corpus" validate:"required"`

	// Query string.
	Query *string `json:"query" validate:"required"`

	// Include suggestions belonging to the selected ontology(ies).
	Ontologies []string `json:"ontologies,omitempty"`

	// Include or exclude suggestions belonging to one of these types.  Types can be found using /v1/corpora/{corpus}/types
	// method.  Defaults to all.
	Types []string `json:"types,omitempty"`

	// Select concepts belonging to disorders, drugs or genes.
	Category *string `json:"category,omitempty"`

	// Verbose output.  Include hit counts and relationship counts for each concept.
	Verbose *bool `json:"verbose,omitempty"`

	// Maximum number of suggestions to return.
	Limit *int64 `json:"_limit,omitempty"`

	// Maximum hit (document) count for suggested concepts. Default is 500000.  High hit count concepts tend to be very
	// broad (e.g, Disease) and result in longer search times.
	MaxHitCount *int64 `json:"max_hit_count,omitempty"`

	// Remove duplicate concepts.
	NoDuplicates *bool `json:"no_duplicates,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the TypeaheadOptions.Ontologies property.
const (
	TypeaheadOptions_Ontologies_Concepts = "concepts"
	TypeaheadOptions_Ontologies_Mesh     = "mesh"
)

// Constants associated with the TypeaheadOptions.Category property.
// Select concepts belonging to disorders, drugs or genes.
const (
	TypeaheadOptions_Category_Disorders = "disorders"
	TypeaheadOptions_Category_Drugs     = "drugs"
	TypeaheadOptions_Category_Genes     = "genes"
)

// NewTypeaheadOptions : Instantiate TypeaheadOptions
func (*InsightsForMedicalLiteratureServiceV1) NewTypeaheadOptions(corpus string, query string) *TypeaheadOptions {
	return &TypeaheadOptions{
		Corpus: core.StringPtr(corpus),
		Query:  core.StringPtr(query),
	}
}

// SetCorpus : Allow user to set Corpus
func (options *TypeaheadOptions) SetCorpus(corpus string) *TypeaheadOptions {
	options.Corpus = core.StringPtr(corpus)
	return options
}

// SetQuery : Allow user to set Query
func (options *TypeaheadOptions) SetQuery(query string) *TypeaheadOptions {
	options.Query = core.StringPtr(query)
	return options
}

// SetOntologies : Allow user to set Ontologies
func (options *TypeaheadOptions) SetOntologies(ontologies []string) *TypeaheadOptions {
	options.Ontologies = ontologies
	return options
}

// SetTypes : Allow user to set Types
func (options *TypeaheadOptions) SetTypes(types []string) *TypeaheadOptions {
	options.Types = types
	return options
}

// SetCategory : Allow user to set Category
func (options *TypeaheadOptions) SetCategory(category string) *TypeaheadOptions {
	options.Category = core.StringPtr(category)
	return options
}

// SetVerbose : Allow user to set Verbose
func (options *TypeaheadOptions) SetVerbose(verbose bool) *TypeaheadOptions {
	options.Verbose = core.BoolPtr(verbose)
	return options
}

// SetLimit : Allow user to set Limit
func (options *TypeaheadOptions) SetLimit(limit int64) *TypeaheadOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetMaxHitCount : Allow user to set MaxHitCount
func (options *TypeaheadOptions) SetMaxHitCount(maxHitCount int64) *TypeaheadOptions {
	options.MaxHitCount = core.Int64Ptr(maxHitCount)
	return options
}

// SetNoDuplicates : Allow user to set NoDuplicates
func (options *TypeaheadOptions) SetNoDuplicates(noDuplicates bool) *TypeaheadOptions {
	options.NoDuplicates = core.BoolPtr(noDuplicates)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *TypeaheadOptions) SetHeaders(param map[string]string) *TypeaheadOptions {
	options.Headers = param
	return options
}

// AggregationModel : Model for field aggregations.
type AggregationModel struct {
	// Name of the aggregation.
	Name *string `json:"name,omitempty"`

	// Corpus frequency of the aggregation.
	DocumentCount *int64 `json:"documentCount,omitempty"`
}

// UnmarshalAggregationModel constructs an instance of AggregationModel from the specified map.
func UnmarshalAggregationModel(m map[string]interface{}) (result *AggregationModel, err error) {
	obj := new(AggregationModel)
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.DocumentCount, err = core.UnmarshalInt64(m, "documentCount")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalAggregationModelSlice unmarshals a slice of AggregationModel instances from the specified list of maps.
func UnmarshalAggregationModelSlice(s []interface{}) (slice []AggregationModel, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'AggregationModel'")
			return
		}
		obj, e := UnmarshalAggregationModel(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalAggregationModelAsProperty unmarshals an instance of AggregationModel that is stored as a property
// within the specified map.
func UnmarshalAggregationModelAsProperty(m map[string]interface{}, propertyName string) (result *AggregationModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'AggregationModel'", propertyName)
			return
		}
		result, err = UnmarshalAggregationModel(objMap)
	}
	return
}

// UnmarshalAggregationModelSliceAsProperty unmarshals a slice of AggregationModel instances that are stored as a property
// within the specified map.
func UnmarshalAggregationModelSliceAsProperty(m map[string]interface{}, propertyName string) (slice []AggregationModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'AggregationModel'", propertyName)
			return
		}
		slice, err = UnmarshalAggregationModelSlice(vSlice)
	}
	return
}

// AnnotationModel : Model for congntive asset annotations.
type AnnotationModel struct {
	// Unique identifer of annotation.
	UniqueID *int64 `json:"uniqueId,omitempty"`

	// List of identifiers associated with annotation.
	StickyIds []int64 `json:"stickyIds,omitempty"`

	// Source ontology of annotation.
	Ontology *string `json:"ontology,omitempty"`

	// Document section for annotation.
	Section *string `json:"section,omitempty"`

	// Ontology provide normalized name of annotation.
	PreferredName *string `json:"preferredName,omitempty"`

	// Ontology provided unique identifier of annotation.
	Cui *string `json:"cui,omitempty"`

	// Attribute identifier of annotation.
	AttributeID *string `json:"attributeId,omitempty"`

	// Qualifier for attribute annotation.
	Qualifiers []string `json:"qualifiers,omitempty"`

	// Ontology provided semantic type of annotation.
	Type *string `json:"type,omitempty"`

	// Whether the annotation is a negated span.
	Negated *bool `json:"negated,omitempty"`

	// Whether the annotation is a hypothetical span.
	Hypothetical *bool `json:"hypothetical,omitempty"`

	// Unit of measure for attribute value annotation.
	Unit *string `json:"unit,omitempty"`

	// Minumum value for attribute value annotation.
	MinValue *string `json:"minValue,omitempty"`

	// Maximum value for attribute value annotation.
	MaxValue *string `json:"maxValue,omitempty"`

	// Mathematical operator for attribute value annotation.
	Operator *string `json:"operator,omitempty"`

	// Ontology type of source relation annotation.
	NluSourceType *string `json:"nluSourceType,omitempty"`

	// Relation name for annotation.
	NluRelation *string `json:"nluRelation,omitempty"`

	// Ontology type of target relation annotation.
	NluTargetType *string `json:"nluTargetType,omitempty"`

	NluEntityIndex *string `json:"nluEntityIndex,omitempty"`

	NluMentionIndex *string `json:"nluMentionIndex,omitempty"`

	NluRelationID *string `json:"nluRelationId,omitempty"`

	NluSide *string `json:"nluSide,omitempty"`

	// Starting offset of annotation.
	Begin *int64 `json:"begin,omitempty"`

	// Ending offset of annotation.
	End *int64 `json:"end,omitempty"`

	// Relevancy score of annotation.
	Score *float32 `json:"score,omitempty"`

	Timestamp *int64 `json:"timestamp,omitempty"`

	Features map[string]string `json:"features,omitempty"`

	// Number of times artifact is mentioned in the corpus.
	Hits *int64 `json:"hits,omitempty"`
}

// UnmarshalAnnotationModel constructs an instance of AnnotationModel from the specified map.
func UnmarshalAnnotationModel(m map[string]interface{}) (result *AnnotationModel, err error) {
	obj := new(AnnotationModel)
	obj.UniqueID, err = core.UnmarshalInt64(m, "uniqueId")
	if err != nil {
		return
	}
	obj.StickyIds, err = core.UnmarshalInt64Slice(m, "stickyIds")
	if err != nil {
		return
	}
	obj.Ontology, err = core.UnmarshalString(m, "ontology")
	if err != nil {
		return
	}
	obj.Section, err = core.UnmarshalString(m, "section")
	if err != nil {
		return
	}
	obj.PreferredName, err = core.UnmarshalString(m, "preferredName")
	if err != nil {
		return
	}
	obj.Cui, err = core.UnmarshalString(m, "cui")
	if err != nil {
		return
	}
	obj.AttributeID, err = core.UnmarshalString(m, "attributeId")
	if err != nil {
		return
	}
	obj.Qualifiers, err = core.UnmarshalStringSlice(m, "qualifiers")
	if err != nil {
		return
	}
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	obj.Negated, err = core.UnmarshalBool(m, "negated")
	if err != nil {
		return
	}
	obj.Hypothetical, err = core.UnmarshalBool(m, "hypothetical")
	if err != nil {
		return
	}
	obj.Unit, err = core.UnmarshalString(m, "unit")
	if err != nil {
		return
	}
	obj.MinValue, err = core.UnmarshalString(m, "minValue")
	if err != nil {
		return
	}
	obj.MaxValue, err = core.UnmarshalString(m, "maxValue")
	if err != nil {
		return
	}
	obj.Operator, err = core.UnmarshalString(m, "operator")
	if err != nil {
		return
	}
	obj.NluSourceType, err = core.UnmarshalString(m, "nluSourceType")
	if err != nil {
		return
	}
	obj.NluRelation, err = core.UnmarshalString(m, "nluRelation")
	if err != nil {
		return
	}
	obj.NluTargetType, err = core.UnmarshalString(m, "nluTargetType")
	if err != nil {
		return
	}
	obj.NluEntityIndex, err = core.UnmarshalString(m, "nluEntityIndex")
	if err != nil {
		return
	}
	obj.NluMentionIndex, err = core.UnmarshalString(m, "nluMentionIndex")
	if err != nil {
		return
	}
	obj.NluRelationID, err = core.UnmarshalString(m, "nluRelationId")
	if err != nil {
		return
	}
	obj.NluSide, err = core.UnmarshalString(m, "nluSide")
	if err != nil {
		return
	}
	obj.Begin, err = core.UnmarshalInt64(m, "begin")
	if err != nil {
		return
	}
	obj.End, err = core.UnmarshalInt64(m, "end")
	if err != nil {
		return
	}
	obj.Score, err = core.UnmarshalFloat32(m, "score")
	if err != nil {
		return
	}
	obj.Timestamp, err = core.UnmarshalInt64(m, "timestamp")
	if err != nil {
		return
	}
	obj.Hits, err = core.UnmarshalInt64(m, "hits")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalAnnotationModelSlice unmarshals a slice of AnnotationModel instances from the specified list of maps.
func UnmarshalAnnotationModelSlice(s []interface{}) (slice []AnnotationModel, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'AnnotationModel'")
			return
		}
		obj, e := UnmarshalAnnotationModel(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalAnnotationModelAsProperty unmarshals an instance of AnnotationModel that is stored as a property
// within the specified map.
func UnmarshalAnnotationModelAsProperty(m map[string]interface{}, propertyName string) (result *AnnotationModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'AnnotationModel'", propertyName)
			return
		}
		result, err = UnmarshalAnnotationModel(objMap)
	}
	return
}

// UnmarshalAnnotationModelSliceAsProperty unmarshals a slice of AnnotationModel instances that are stored as a property
// within the specified map.
func UnmarshalAnnotationModelSliceAsProperty(m map[string]interface{}, propertyName string) (slice []AnnotationModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'AnnotationModel'", propertyName)
			return
		}
		slice, err = UnmarshalAnnotationModelSlice(vSlice)
	}
	return
}

// ArtifactModel : Model for ontology artifact.
type ArtifactModel struct {
	// Ontology provided unique identifier for artifact.
	Cui *string `json:"cui,omitempty"`

	// Source ontology for artifact.
	Ontology *string `json:"ontology,omitempty"`

	// Ontology provided normalized name for artifact.
	PreferredName *string `json:"preferredName,omitempty"`

	// Ontology provided alternative name for artifact.
	AlternativeName *string `json:"alternativeName,omitempty"`

	// Ontology semantic type for artifact.
	SemanticType *string `json:"semanticType,omitempty"`

	// Search weight assigned to artifact.
	Rank *int64 `json:"rank,omitempty"`

	// Number of corpus documents artifact was found in.
	HitCount *int64 `json:"hitCount,omitempty"`

	// Relevance score for artifact.
	Score *float32 `json:"score,omitempty"`

	// List of artifact synonyms.
	SurfaceForms []string `json:"surfaceForms,omitempty"`
}

// UnmarshalArtifactModel constructs an instance of ArtifactModel from the specified map.
func UnmarshalArtifactModel(m map[string]interface{}) (result *ArtifactModel, err error) {
	obj := new(ArtifactModel)
	obj.Cui, err = core.UnmarshalString(m, "cui")
	if err != nil {
		return
	}
	obj.Ontology, err = core.UnmarshalString(m, "ontology")
	if err != nil {
		return
	}
	obj.PreferredName, err = core.UnmarshalString(m, "preferredName")
	if err != nil {
		return
	}
	obj.AlternativeName, err = core.UnmarshalString(m, "alternativeName")
	if err != nil {
		return
	}
	obj.SemanticType, err = core.UnmarshalString(m, "semanticType")
	if err != nil {
		return
	}
	obj.Rank, err = core.UnmarshalInt64(m, "rank")
	if err != nil {
		return
	}
	obj.HitCount, err = core.UnmarshalInt64(m, "hitCount")
	if err != nil {
		return
	}
	obj.Score, err = core.UnmarshalFloat32(m, "score")
	if err != nil {
		return
	}
	obj.SurfaceForms, err = core.UnmarshalStringSlice(m, "surfaceForms")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalArtifactModelSlice unmarshals a slice of ArtifactModel instances from the specified list of maps.
func UnmarshalArtifactModelSlice(s []interface{}) (slice []ArtifactModel, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'ArtifactModel'")
			return
		}
		obj, e := UnmarshalArtifactModel(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalArtifactModelAsProperty unmarshals an instance of ArtifactModel that is stored as a property
// within the specified map.
func UnmarshalArtifactModelAsProperty(m map[string]interface{}, propertyName string) (result *ArtifactModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'ArtifactModel'", propertyName)
			return
		}
		result, err = UnmarshalArtifactModel(objMap)
	}
	return
}

// UnmarshalArtifactModelSliceAsProperty unmarshals a slice of ArtifactModel instances that are stored as a property
// within the specified map.
func UnmarshalArtifactModelSliceAsProperty(m map[string]interface{}, propertyName string) (slice []ArtifactModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'ArtifactModel'", propertyName)
			return
		}
		slice, err = UnmarshalArtifactModelSlice(vSlice)
	}
	return
}

// Attribute : Object representing an attribute artifact.
type Attribute struct {
	// Unique identifier for attribute artifact.
	AttributeID *string `json:"attributeId,omitempty"`

	// Display name for attribute artifact.
	DisplayName *string `json:"displayName,omitempty"`

	// Corpus frequency for attribute artifact.
	Count *int64 `json:"count,omitempty"`
}

// UnmarshalAttribute constructs an instance of Attribute from the specified map.
func UnmarshalAttribute(m map[string]interface{}) (result *Attribute, err error) {
	obj := new(Attribute)
	obj.AttributeID, err = core.UnmarshalString(m, "attributeId")
	if err != nil {
		return
	}
	obj.DisplayName, err = core.UnmarshalString(m, "displayName")
	if err != nil {
		return
	}
	obj.Count, err = core.UnmarshalInt64(m, "count")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalAttributeSlice unmarshals a slice of Attribute instances from the specified list of maps.
func UnmarshalAttributeSlice(s []interface{}) (slice []Attribute, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'Attribute'")
			return
		}
		obj, e := UnmarshalAttribute(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalAttributeAsProperty unmarshals an instance of Attribute that is stored as a property
// within the specified map.
func UnmarshalAttributeAsProperty(m map[string]interface{}, propertyName string) (result *Attribute, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'Attribute'", propertyName)
			return
		}
		result, err = UnmarshalAttribute(objMap)
	}
	return
}

// UnmarshalAttributeSliceAsProperty unmarshals a slice of Attribute instances that are stored as a property
// within the specified map.
func UnmarshalAttributeSliceAsProperty(m map[string]interface{}, propertyName string) (slice []Attribute, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'Attribute'", propertyName)
			return
		}
		slice, err = UnmarshalAttributeSlice(vSlice)
	}
	return
}

// Backend : Object representing repository response.
type Backend struct {
	// Repository messages.
	Messages []Message `json:"messages,omitempty"`
}

// UnmarshalBackend constructs an instance of Backend from the specified map.
func UnmarshalBackend(m map[string]interface{}) (result *Backend, err error) {
	obj := new(Backend)
	obj.Messages, err = UnmarshalMessageSliceAsProperty(m, "messages")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalBackendSlice unmarshals a slice of Backend instances from the specified list of maps.
func UnmarshalBackendSlice(s []interface{}) (slice []Backend, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'Backend'")
			return
		}
		obj, e := UnmarshalBackend(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalBackendAsProperty unmarshals an instance of Backend that is stored as a property
// within the specified map.
func UnmarshalBackendAsProperty(m map[string]interface{}, propertyName string) (result *Backend, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'Backend'", propertyName)
			return
		}
		result, err = UnmarshalBackend(objMap)
	}
	return
}

// UnmarshalBackendSliceAsProperty unmarshals a slice of Backend instances that are stored as a property
// within the specified map.
func UnmarshalBackendSliceAsProperty(m map[string]interface{}, propertyName string) (slice []Backend, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'Backend'", propertyName)
			return
		}
		slice, err = UnmarshalBackendSlice(vSlice)
	}
	return
}

// BooleanOperands : Object representingn boolean operands search criteria.
type BooleanOperands struct {
	// Boolean search condition.
	BoolExpression *string `json:"boolExpression,omitempty"`

	// Ontology artifacts supporing boolean search condition.
	BoolOperands []BoolOperand `json:"boolOperands,omitempty"`
}

// UnmarshalBooleanOperands constructs an instance of BooleanOperands from the specified map.
func UnmarshalBooleanOperands(m map[string]interface{}) (result *BooleanOperands, err error) {
	obj := new(BooleanOperands)
	obj.BoolExpression, err = core.UnmarshalString(m, "boolExpression")
	if err != nil {
		return
	}
	obj.BoolOperands, err = UnmarshalBoolOperandSliceAsProperty(m, "boolOperands")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalBooleanOperandsSlice unmarshals a slice of BooleanOperands instances from the specified list of maps.
func UnmarshalBooleanOperandsSlice(s []interface{}) (slice []BooleanOperands, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'BooleanOperands'")
			return
		}
		obj, e := UnmarshalBooleanOperands(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalBooleanOperandsAsProperty unmarshals an instance of BooleanOperands that is stored as a property
// within the specified map.
func UnmarshalBooleanOperandsAsProperty(m map[string]interface{}, propertyName string) (result *BooleanOperands, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'BooleanOperands'", propertyName)
			return
		}
		result, err = UnmarshalBooleanOperands(objMap)
	}
	return
}

// UnmarshalBooleanOperandsSliceAsProperty unmarshals a slice of BooleanOperands instances that are stored as a property
// within the specified map.
func UnmarshalBooleanOperandsSliceAsProperty(m map[string]interface{}, propertyName string) (slice []BooleanOperands, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'BooleanOperands'", propertyName)
			return
		}
		slice, err = UnmarshalBooleanOperandsSlice(vSlice)
	}
	return
}

// CategoriesModel : Model representing ontology categories.
type CategoriesModel struct {
	// License for corpus.
	ModelLicense *string `json:"modelLicense,omitempty"`

	HighlightedTitle *string `json:"highlightedTitle,omitempty"`

	HighlightedAbstract *string `json:"highlightedAbstract,omitempty"`

	HighlightedBody *string `json:"highlightedBody,omitempty"`

	// Document sections with annotation tags.
	HighlightedSections map[string]string `json:"highlightedSections,omitempty"`

	// Document passages with annotation tags.
	Passages map[string]map[string]EntryModel `json:"passages,omitempty"`

	// List of document annotations.
	Annotations map[string]AnnotationModel `json:"annotations,omitempty"`
}

// UnmarshalCategoriesModel constructs an instance of CategoriesModel from the specified map.
func UnmarshalCategoriesModel(m map[string]interface{}) (result *CategoriesModel, err error) {
	obj := new(CategoriesModel)
	obj.ModelLicense, err = core.UnmarshalString(m, "modelLicense")
	if err != nil {
		return
	}
	obj.HighlightedTitle, err = core.UnmarshalString(m, "highlightedTitle")
	if err != nil {
		return
	}
	obj.HighlightedAbstract, err = core.UnmarshalString(m, "highlightedAbstract")
	if err != nil {
		return
	}
	obj.HighlightedBody, err = core.UnmarshalString(m, "highlightedBody")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalCategoriesModelSlice unmarshals a slice of CategoriesModel instances from the specified list of maps.
func UnmarshalCategoriesModelSlice(s []interface{}) (slice []CategoriesModel, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'CategoriesModel'")
			return
		}
		obj, e := UnmarshalCategoriesModel(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalCategoriesModelAsProperty unmarshals an instance of CategoriesModel that is stored as a property
// within the specified map.
func UnmarshalCategoriesModelAsProperty(m map[string]interface{}, propertyName string) (result *CategoriesModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'CategoriesModel'", propertyName)
			return
		}
		result, err = UnmarshalCategoriesModel(objMap)
	}
	return
}

// UnmarshalCategoriesModelSliceAsProperty unmarshals a slice of CategoriesModel instances that are stored as a property
// within the specified map.
func UnmarshalCategoriesModelSliceAsProperty(m map[string]interface{}, propertyName string) (slice []CategoriesModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'CategoriesModel'", propertyName)
			return
		}
		slice, err = UnmarshalCategoriesModelSlice(vSlice)
	}
	return
}

// CommonDataModel : Model representing common data across annotations.
type CommonDataModel struct {
	// Object of all ontology artifacts found in the document.
	Unstructured []UnstructuredModel `json:"unstructured,omitempty"`
}

// UnmarshalCommonDataModel constructs an instance of CommonDataModel from the specified map.
func UnmarshalCommonDataModel(m map[string]interface{}) (result *CommonDataModel, err error) {
	obj := new(CommonDataModel)
	obj.Unstructured, err = UnmarshalUnstructuredModelSliceAsProperty(m, "unstructured")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalCommonDataModelSlice unmarshals a slice of CommonDataModel instances from the specified list of maps.
func UnmarshalCommonDataModelSlice(s []interface{}) (slice []CommonDataModel, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'CommonDataModel'")
			return
		}
		obj, e := UnmarshalCommonDataModel(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalCommonDataModelAsProperty unmarshals an instance of CommonDataModel that is stored as a property
// within the specified map.
func UnmarshalCommonDataModelAsProperty(m map[string]interface{}, propertyName string) (result *CommonDataModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'CommonDataModel'", propertyName)
			return
		}
		result, err = UnmarshalCommonDataModel(objMap)
	}
	return
}

// UnmarshalCommonDataModelSliceAsProperty unmarshals a slice of CommonDataModel instances that are stored as a property
// within the specified map.
func UnmarshalCommonDataModelSliceAsProperty(m map[string]interface{}, propertyName string) (slice []CommonDataModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'CommonDataModel'", propertyName)
			return
		}
		slice, err = UnmarshalCommonDataModelSlice(vSlice)
	}
	return
}

// Concept : Object reprensting an ontology artifact.
type Concept struct {
	// Ontology for artifact in search results.
	Ontology *string `json:"ontology,omitempty"`

	// Unique identifier for ontolgoy artifact in search results.
	Cui *string `json:"cui,omitempty"`

	// Ontology defined semantic type for artifact in search results.
	PreferredName *string `json:"preferredName,omitempty"`

	// Ontology defined normalized name for artifact in search results.
	AlternativeName *string `json:"alternativeName,omitempty"`

	// Ontology defined alternative name for artifact in search results.
	SemanticType *string `json:"semanticType,omitempty"`

	// Corpus frequency of artifact.
	Count *int64 `json:"count,omitempty"`

	// Corpus frequency of artifact.
	HitCount *int64 `json:"hitCount,omitempty"`

	// Relevancy score of artifact in search results.
	Score *float32 `json:"score,omitempty"`

	// Corpus frequency count.
	Parents *Count `json:"parents,omitempty"`

	// Corpus frequency count.
	Children *Count `json:"children,omitempty"`

	// Corpus frequency count.
	Siblings *Count `json:"siblings,omitempty"`

	// Corpus frequency count.
	Related *Count `json:"related,omitempty"`

	// Document identifiers for artifacts in search results.
	DocumentIds []string `json:"documentIds,omitempty"`

	// attribute data type for artifact in search results.
	DataType *string `json:"dataType,omitempty"`

	// Attribute value unit for artifact.
	Unit *string `json:"unit,omitempty"`

	// Attribute value operator for artifact.
	Operator *string `json:"operator,omitempty"`

	// Minimum value for attribute artifact.
	MinValue *string `json:"minValue,omitempty"`

	// Maximum value for attribute artifact.
	MaxValue *string `json:"maxValue,omitempty"`

	// Source vocabulary of arttifact.
	Vocab *string `json:"vocab,omitempty"`

	// Artifact properties.
	Properties []string `json:"properties,omitempty"`
}

// UnmarshalConcept constructs an instance of Concept from the specified map.
func UnmarshalConcept(m map[string]interface{}) (result *Concept, err error) {
	obj := new(Concept)
	obj.Ontology, err = core.UnmarshalString(m, "ontology")
	if err != nil {
		return
	}
	obj.Cui, err = core.UnmarshalString(m, "cui")
	if err != nil {
		return
	}
	obj.PreferredName, err = core.UnmarshalString(m, "preferredName")
	if err != nil {
		return
	}
	obj.AlternativeName, err = core.UnmarshalString(m, "alternativeName")
	if err != nil {
		return
	}
	obj.SemanticType, err = core.UnmarshalString(m, "semanticType")
	if err != nil {
		return
	}
	obj.Count, err = core.UnmarshalInt64(m, "count")
	if err != nil {
		return
	}
	obj.HitCount, err = core.UnmarshalInt64(m, "hitCount")
	if err != nil {
		return
	}
	obj.Score, err = core.UnmarshalFloat32(m, "score")
	if err != nil {
		return
	}
	obj.Parents, err = UnmarshalCountAsProperty(m, "parents")
	if err != nil {
		return
	}
	obj.Children, err = UnmarshalCountAsProperty(m, "children")
	if err != nil {
		return
	}
	obj.Siblings, err = UnmarshalCountAsProperty(m, "siblings")
	if err != nil {
		return
	}
	obj.Related, err = UnmarshalCountAsProperty(m, "related")
	if err != nil {
		return
	}
	obj.DocumentIds, err = core.UnmarshalStringSlice(m, "documentIds")
	if err != nil {
		return
	}
	obj.DataType, err = core.UnmarshalString(m, "dataType")
	if err != nil {
		return
	}
	obj.Unit, err = core.UnmarshalString(m, "unit")
	if err != nil {
		return
	}
	obj.Operator, err = core.UnmarshalString(m, "operator")
	if err != nil {
		return
	}
	obj.MinValue, err = core.UnmarshalString(m, "minValue")
	if err != nil {
		return
	}
	obj.MaxValue, err = core.UnmarshalString(m, "maxValue")
	if err != nil {
		return
	}
	obj.Vocab, err = core.UnmarshalString(m, "vocab")
	if err != nil {
		return
	}
	obj.Properties, err = core.UnmarshalStringSlice(m, "properties")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalConceptSlice unmarshals a slice of Concept instances from the specified list of maps.
func UnmarshalConceptSlice(s []interface{}) (slice []Concept, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'Concept'")
			return
		}
		obj, e := UnmarshalConcept(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalConceptAsProperty unmarshals an instance of Concept that is stored as a property
// within the specified map.
func UnmarshalConceptAsProperty(m map[string]interface{}, propertyName string) (result *Concept, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'Concept'", propertyName)
			return
		}
		result, err = UnmarshalConcept(objMap)
	}
	return
}

// UnmarshalConceptSliceAsProperty unmarshals a slice of Concept instances that are stored as a property
// within the specified map.
func UnmarshalConceptSliceAsProperty(m map[string]interface{}, propertyName string) (slice []Concept, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'Concept'", propertyName)
			return
		}
		slice, err = UnmarshalConceptSlice(vSlice)
	}
	return
}

// ConceptInfoModel : Model representing ontology annotations.
type ConceptInfoModel struct {
	// Ontology provided unique identifier for artifact.
	Cui *string `json:"cui,omitempty"`

	// Source onology of artifact.
	Ontology *string `json:"ontology,omitempty"`

	// Ontology defined normalized name for artifact.
	PreferredName *string `json:"preferredName,omitempty"`

	// Ontology defined semanic types for artifact.
	SemanticTypes []string `json:"semanticTypes,omitempty"`

	// Ontology defined synonyms for artifact.
	SurfaceForms []string `json:"surfaceForms,omitempty"`

	// Ontology provided definition for artifact.
	Definition *string `json:"definition,omitempty"`

	// Whether the artifact has parent artifacts in the ontology.
	HasParents *bool `json:"hasParents,omitempty"`

	// Whether the artifact has child artifacts in the ontology.
	HasChildren *bool `json:"hasChildren,omitempty"`

	// Whether the artifact has sibling artifacts in the ontology.
	HasSiblings *bool `json:"hasSiblings,omitempty"`
}

// UnmarshalConceptInfoModel constructs an instance of ConceptInfoModel from the specified map.
func UnmarshalConceptInfoModel(m map[string]interface{}) (result *ConceptInfoModel, err error) {
	obj := new(ConceptInfoModel)
	obj.Cui, err = core.UnmarshalString(m, "cui")
	if err != nil {
		return
	}
	obj.Ontology, err = core.UnmarshalString(m, "ontology")
	if err != nil {
		return
	}
	obj.PreferredName, err = core.UnmarshalString(m, "preferredName")
	if err != nil {
		return
	}
	obj.SemanticTypes, err = core.UnmarshalStringSlice(m, "semanticTypes")
	if err != nil {
		return
	}
	obj.SurfaceForms, err = core.UnmarshalStringSlice(m, "surfaceForms")
	if err != nil {
		return
	}
	obj.Definition, err = core.UnmarshalString(m, "definition")
	if err != nil {
		return
	}
	obj.HasParents, err = core.UnmarshalBool(m, "hasParents")
	if err != nil {
		return
	}
	obj.HasChildren, err = core.UnmarshalBool(m, "hasChildren")
	if err != nil {
		return
	}
	obj.HasSiblings, err = core.UnmarshalBool(m, "hasSiblings")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalConceptInfoModelSlice unmarshals a slice of ConceptInfoModel instances from the specified list of maps.
func UnmarshalConceptInfoModelSlice(s []interface{}) (slice []ConceptInfoModel, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'ConceptInfoModel'")
			return
		}
		obj, e := UnmarshalConceptInfoModel(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalConceptInfoModelAsProperty unmarshals an instance of ConceptInfoModel that is stored as a property
// within the specified map.
func UnmarshalConceptInfoModelAsProperty(m map[string]interface{}, propertyName string) (result *ConceptInfoModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'ConceptInfoModel'", propertyName)
			return
		}
		result, err = UnmarshalConceptInfoModel(objMap)
	}
	return
}

// UnmarshalConceptInfoModelSliceAsProperty unmarshals a slice of ConceptInfoModel instances that are stored as a property
// within the specified map.
func UnmarshalConceptInfoModelSliceAsProperty(m map[string]interface{}, propertyName string) (slice []ConceptInfoModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'ConceptInfoModel'", propertyName)
			return
		}
		slice, err = UnmarshalConceptInfoModelSlice(vSlice)
	}
	return
}

// ConceptListModel : List of ontolgoy artifacts.
type ConceptListModel struct {
	// List of ontology artifacts.
	Concepts []ArtifactModel `json:"concepts,omitempty"`
}

// UnmarshalConceptListModel constructs an instance of ConceptListModel from the specified map.
func UnmarshalConceptListModel(m map[string]interface{}) (result *ConceptListModel, err error) {
	obj := new(ConceptListModel)
	obj.Concepts, err = UnmarshalArtifactModelSliceAsProperty(m, "concepts")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalConceptListModelSlice unmarshals a slice of ConceptListModel instances from the specified list of maps.
func UnmarshalConceptListModelSlice(s []interface{}) (slice []ConceptListModel, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'ConceptListModel'")
			return
		}
		obj, e := UnmarshalConceptListModel(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalConceptListModelAsProperty unmarshals an instance of ConceptListModel that is stored as a property
// within the specified map.
func UnmarshalConceptListModelAsProperty(m map[string]interface{}, propertyName string) (result *ConceptListModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'ConceptListModel'", propertyName)
			return
		}
		result, err = UnmarshalConceptListModel(objMap)
	}
	return
}

// UnmarshalConceptListModelSliceAsProperty unmarshals a slice of ConceptListModel instances that are stored as a property
// within the specified map.
func UnmarshalConceptListModelSliceAsProperty(m map[string]interface{}, propertyName string) (slice []ConceptListModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'ConceptListModel'", propertyName)
			return
		}
		slice, err = UnmarshalConceptListModelSlice(vSlice)
	}
	return
}

// ConceptModel : Model representing an ontology annotation.
type ConceptModel struct {
	// Service generated unique identifier of ontology artifact.
	UniqueID *int64 `json:"uniqueId,omitempty"`

	// Identifiers associated with artifact unique identifier.
	StickyIds []int64 `json:"stickyIds,omitempty"`

	// Document section where artifact was found.
	Section *string `json:"section,omitempty"`

	// Ontology semantic type for artifact (if applicable).
	Type *string `json:"type,omitempty"`

	// Staring offset of artifact in document section.
	Begin *int64 `json:"begin,omitempty"`

	// Ending offset of artifact in document section.
	End *int64 `json:"end,omitempty"`

	// Actual document section text artifact represents.
	CoveredText *string `json:"coveredText,omitempty"`

	// Ontology defined unique identifier of artifact.
	Cui *string `json:"cui,omitempty"`

	// Ontology defined normalized name of artifact.
	PreferredName *string `json:"preferredName,omitempty"`

	// Ontology providing the artifact.
	Source *string `json:"source,omitempty"`

	// Whether span represented by artifact is negated.
	Negated *bool `json:"negated,omitempty"`

	// Whether span represented by artifact is hypothetical.
	Hypothetical *bool `json:"hypothetical,omitempty"`

	// Time based offset of artifact in a video transcript (if applicable).
	Timestamp *int64 `json:"timestamp,omitempty"`

	// Identifier of attribute where artifact is defined (if applicable).
	AttributeID *string `json:"attributeId,omitempty"`

	// List of qualifers defined for an attribute artifact.
	Qualifiers []string `json:"qualifiers,omitempty"`

	// Unit of measure for attribute defined artifact (if applicable).
	Unit *string `json:"unit,omitempty"`

	// Starting range value for attribute artifact (if applicable).
	MinValue *string `json:"minValue,omitempty"`

	// Ending range value for attribute artifact (if applicable).
	MaxValue *string `json:"maxValue,omitempty"`

	// Mathmatical operator for attribute artifact (if applicable).
	Operator *string `json:"operator,omitempty"`

	// List of additional artifact features.
	Features map[string]string `json:"features,omitempty"`

	// Model coreference chain to which artifact belongs.
	NluEntityIndex *string `json:"nluEntityIndex,omitempty"`

	// Artifact position in Model coreference chain.
	NluMentionIndex *string `json:"nluMentionIndex,omitempty"`

	// Relation unique identifier artifact is associated with.
	NluRelationID *string `json:"nluRelationId,omitempty"`

	// Whether artifact is a source or target of a relationship.
	NluSide *string `json:"nluSide,omitempty"`

	// Model type for artifact when the source of a relationship.
	NluSourceType *string `json:"nluSourceType,omitempty"`

	// Name of the realtion an artifact is associated with.
	NluRelation *string `json:"nluRelation,omitempty"`

	// Model type for artifact when the target of a relationship.
	NluTargetType *string `json:"nluTargetType,omitempty"`

	// Number of times artifact is mentioned in the corpus.
	Hits *int64 `json:"hits,omitempty"`
}

// UnmarshalConceptModel constructs an instance of ConceptModel from the specified map.
func UnmarshalConceptModel(m map[string]interface{}) (result *ConceptModel, err error) {
	obj := new(ConceptModel)
	obj.UniqueID, err = core.UnmarshalInt64(m, "uniqueId")
	if err != nil {
		return
	}
	obj.StickyIds, err = core.UnmarshalInt64Slice(m, "stickyIds")
	if err != nil {
		return
	}
	obj.Section, err = core.UnmarshalString(m, "section")
	if err != nil {
		return
	}
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	obj.Begin, err = core.UnmarshalInt64(m, "begin")
	if err != nil {
		return
	}
	obj.End, err = core.UnmarshalInt64(m, "end")
	if err != nil {
		return
	}
	obj.CoveredText, err = core.UnmarshalString(m, "coveredText")
	if err != nil {
		return
	}
	obj.Cui, err = core.UnmarshalString(m, "cui")
	if err != nil {
		return
	}
	obj.PreferredName, err = core.UnmarshalString(m, "preferredName")
	if err != nil {
		return
	}
	obj.Source, err = core.UnmarshalString(m, "source")
	if err != nil {
		return
	}
	obj.Negated, err = core.UnmarshalBool(m, "negated")
	if err != nil {
		return
	}
	obj.Hypothetical, err = core.UnmarshalBool(m, "hypothetical")
	if err != nil {
		return
	}
	obj.Timestamp, err = core.UnmarshalInt64(m, "timestamp")
	if err != nil {
		return
	}
	obj.AttributeID, err = core.UnmarshalString(m, "attributeId")
	if err != nil {
		return
	}
	obj.Qualifiers, err = core.UnmarshalStringSlice(m, "qualifiers")
	if err != nil {
		return
	}
	obj.Unit, err = core.UnmarshalString(m, "unit")
	if err != nil {
		return
	}
	obj.MinValue, err = core.UnmarshalString(m, "minValue")
	if err != nil {
		return
	}
	obj.MaxValue, err = core.UnmarshalString(m, "maxValue")
	if err != nil {
		return
	}
	obj.Operator, err = core.UnmarshalString(m, "operator")
	if err != nil {
		return
	}
	obj.NluEntityIndex, err = core.UnmarshalString(m, "nluEntityIndex")
	if err != nil {
		return
	}
	obj.NluMentionIndex, err = core.UnmarshalString(m, "nluMentionIndex")
	if err != nil {
		return
	}
	obj.NluRelationID, err = core.UnmarshalString(m, "nluRelationId")
	if err != nil {
		return
	}
	obj.NluSide, err = core.UnmarshalString(m, "nluSide")
	if err != nil {
		return
	}
	obj.NluSourceType, err = core.UnmarshalString(m, "nluSourceType")
	if err != nil {
		return
	}
	obj.NluRelation, err = core.UnmarshalString(m, "nluRelation")
	if err != nil {
		return
	}
	obj.NluTargetType, err = core.UnmarshalString(m, "nluTargetType")
	if err != nil {
		return
	}
	obj.Hits, err = core.UnmarshalInt64(m, "hits")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalConceptModelSlice unmarshals a slice of ConceptModel instances from the specified list of maps.
func UnmarshalConceptModelSlice(s []interface{}) (slice []ConceptModel, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'ConceptModel'")
			return
		}
		obj, e := UnmarshalConceptModel(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalConceptModelAsProperty unmarshals an instance of ConceptModel that is stored as a property
// within the specified map.
func UnmarshalConceptModelAsProperty(m map[string]interface{}, propertyName string) (result *ConceptModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'ConceptModel'", propertyName)
			return
		}
		result, err = UnmarshalConceptModel(objMap)
	}
	return
}

// UnmarshalConceptModelSliceAsProperty unmarshals a slice of ConceptModel instances that are stored as a property
// within the specified map.
func UnmarshalConceptModelSliceAsProperty(m map[string]interface{}, propertyName string) (slice []ConceptModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'ConceptModel'", propertyName)
			return
		}
		slice, err = UnmarshalConceptModelSlice(vSlice)
	}
	return
}

// CorporaConfig : Model respresenting configured corpora.
type CorporaConfig struct {
	// List of corpora found in the instance.
	Corpora []CorpusModel `json:"corpora,omitempty"`
}

// UnmarshalCorporaConfig constructs an instance of CorporaConfig from the specified map.
func UnmarshalCorporaConfig(m map[string]interface{}) (result *CorporaConfig, err error) {
	obj := new(CorporaConfig)
	obj.Corpora, err = UnmarshalCorpusModelSliceAsProperty(m, "corpora")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalCorporaConfigSlice unmarshals a slice of CorporaConfig instances from the specified list of maps.
func UnmarshalCorporaConfigSlice(s []interface{}) (slice []CorporaConfig, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'CorporaConfig'")
			return
		}
		obj, e := UnmarshalCorporaConfig(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalCorporaConfigAsProperty unmarshals an instance of CorporaConfig that is stored as a property
// within the specified map.
func UnmarshalCorporaConfigAsProperty(m map[string]interface{}, propertyName string) (result *CorporaConfig, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'CorporaConfig'", propertyName)
			return
		}
		result, err = UnmarshalCorporaConfig(objMap)
	}
	return
}

// UnmarshalCorporaConfigSliceAsProperty unmarshals a slice of CorporaConfig instances that are stored as a property
// within the specified map.
func UnmarshalCorporaConfigSliceAsProperty(m map[string]interface{}, propertyName string) (slice []CorporaConfig, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'CorporaConfig'", propertyName)
			return
		}
		slice, err = UnmarshalCorporaConfigSlice(vSlice)
	}
	return
}

// CorpusInfoModel : Object representing a configured corpus with documents.
type CorpusInfoModel struct {
	// Number of documents in the corpus.
	DocumentCount *int64 `json:"corpusName,omitempty"`

	// Providers found in the corpus.
	Providers []CorpusProvider `json:"ontologies,omitempty"`
}

// UnmarshalCorpusInfoModel constructs an instance of CorpusInfoModel from the specified map.
func UnmarshalCorpusInfoModel(m map[string]interface{}) (result *CorpusInfoModel, err error) {
	obj := new(CorpusInfoModel)
	obj.DocumentCount, err = core.UnmarshalInt64(m, "documentCount")
	if err != nil {
		return
	}
	obj.Providers, err = UnmarshalCorpusProviderSliceAsProperty(m, "providers")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalCorpusInfoModelSlice unmarshals a slice of CorpusInfoModel instances from the specified list of maps.
func UnmarshalCorpusInfoModelSlice(s []interface{}) (slice []CorpusInfoModel, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'CorpusInfoModel'")
			return
		}
		obj, e := UnmarshalCorpusInfoModel(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalCorpusInfoModelAsProperty unmarshals an instance of Count that is stored as a property
// within the specified map.
func UnmarshalCorpusInfoModelAsProperty(m map[string]interface{}, propertyName string) (result *CorpusInfoModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'CorpusInfoModel'", propertyName)
			return
		}
		result, err = UnmarshalCorpusInfoModel(objMap)
	}
	return
}

// UnmarshalCorpusInfoModelSliceAsProperty unmarshals a slice of Count instances that are stored as a property
// within the specified map.
func UnmarshalCorpusInfoModelSliceAsProperty(m map[string]interface{}, propertyName string) (slice []CorpusInfoModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'CorpusInfoModel'", propertyName)
			return
		}
		slice, err = UnmarshalCorpusInfoModelSlice(vSlice)
	}
	return
}

// CorpusModel : Object representing a configured corpus.
type CorpusModel struct {
	// Name of the corpus.
	CorpusName *string `json:"corpusName,omitempty"`

	// Ontologies found in the corpus.
	Ontologies []string `json:"ontologies,omitempty"`

	// Descriptive name of the corpus.
	DescriptiveName *string `json:"descriptiveName,omitempty"`

	// BVT status of the corpus.
	Bvt *bool `json:"bvt,omitempty"`

	// Repository location of the corpus.
	ElasticsearchIndex *string `json:"elasticsearchIndex,omitempty"`
}

// UnmarshalCorpusModel constructs an instance of CorpusModel from the specified map.
func UnmarshalCorpusModel(m map[string]interface{}) (result *CorpusModel, err error) {
	obj := new(CorpusModel)
	obj.CorpusName, err = core.UnmarshalString(m, "corpusName")
	if err != nil {
		return
	}
	obj.Ontologies, err = core.UnmarshalStringSlice(m, "ontologies")
	if err != nil {
		return
	}
	obj.DescriptiveName, err = core.UnmarshalString(m, "descriptiveName")
	if err != nil {
		return
	}
	obj.Bvt, err = core.UnmarshalBool(m, "bvt")
	if err != nil {
		return
	}
	obj.ElasticsearchIndex, err = core.UnmarshalString(m, "elasticsearchIndex")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalCorpusModelSlice unmarshals a slice of CorpusModel instances from the specified list of maps.
func UnmarshalCorpusModelSlice(s []interface{}) (slice []CorpusModel, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'CorpusModel'")
			return
		}
		obj, e := UnmarshalCorpusModel(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalCorpusModelAsProperty unmarshals an instance of CorpusModel that is stored as a property
// within the specified map.
func UnmarshalCorpusModelAsProperty(m map[string]interface{}, propertyName string) (result *CorpusModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'CorpusModel'", propertyName)
			return
		}
		result, err = UnmarshalCorpusModel(objMap)
	}
	return
}

// UnmarshalCorpusModelSliceAsProperty unmarshals a slice of CorpusModel instances that are stored as a property
// within the specified map.
func UnmarshalCorpusModelSliceAsProperty(m map[string]interface{}, propertyName string) (slice []CorpusModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'CorpusModel'", propertyName)
			return
		}
		slice, err = UnmarshalCorpusModelSlice(vSlice)
	}
	return
}

// CorpusProvider : Object representing a provider within aconfigured corpus.
type CorpusProvider struct {
	// Number of documents for the provider.
	DocumentCount *int64 `json:"corpusName,omitempty"`

	// Providers name.
	Name *string `json:"ontologies,omitempty"`
}

// UnmarshalCorpusInfoModel constructs an instance of CorpusInfoModel from the specified map.
func UnmarshalCorpusProvider(m map[string]interface{}) (result *CorpusProvider, err error) {
	obj := new(CorpusProvider)
	obj.DocumentCount, err = core.UnmarshalInt64(m, "documentCount")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalCorpusProviderSlice unmarshals a slice of CorpusProvider instances from the specified list of maps.
func UnmarshalCorpusProviderSlice(s []interface{}) (slice []CorpusProvider, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'CorpusProvider'")
			return
		}
		obj, e := UnmarshalCorpusProvider(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalCorpusProviderAsProperty unmarshals an instance of CorpusProvider that is stored as a property
// within the specified map.
func UnmarshalCorpusProviderAsProperty(m map[string]interface{}, propertyName string) (result *CorpusProvider, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'CorpusProvider'", propertyName)
			return
		}
		result, err = UnmarshalCorpusProvider(objMap)
	}
	return
}

// UnmarshalCorpusProviderSliceAsProperty unmarshals a slice of CorpusProvider instances that are stored as a property
// within the specified map.
func UnmarshalCorpusProviderSliceAsProperty(m map[string]interface{}, propertyName string) (slice []CorpusProvider, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'CorpusProvider'", propertyName)
			return
		}
		slice, err = UnmarshalCorpusProviderSlice(vSlice)
	}
	return
}

// Count : Corpus frequency count.
type Count struct {
	// Number of documents for artifact result.
	Count *int64 `json:"count,omitempty"`

	// Number of documents for artifact result.
	Hits *int64 `json:"hits,omitempty"`
}

// UnmarshalCount constructs an instance of Count from the specified map.
func UnmarshalCount(m map[string]interface{}) (result *Count, err error) {
	obj := new(Count)
	obj.Count, err = core.UnmarshalInt64(m, "count")
	if err != nil {
		return
	}
	obj.Hits, err = core.UnmarshalInt64(m, "hits")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalCountSlice unmarshals a slice of Count instances from the specified list of maps.
func UnmarshalCountSlice(s []interface{}) (slice []Count, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'Count'")
			return
		}
		obj, e := UnmarshalCount(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalCountAsProperty unmarshals an instance of Count that is stored as a property
// within the specified map.
func UnmarshalCountAsProperty(m map[string]interface{}, propertyName string) (result *Count, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'Count'", propertyName)
			return
		}
		result, err = UnmarshalCount(objMap)
	}
	return
}

// UnmarshalCountSliceAsProperty unmarshals a slice of Count instances that are stored as a property
// within the specified map.
func UnmarshalCountSliceAsProperty(m map[string]interface{}, propertyName string) (slice []Count, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'Count'", propertyName)
			return
		}
		slice, err = UnmarshalCountSlice(vSlice)
	}
	return
}

// DataModel : Model representing ontology artifacts.
type DataModel struct {
	// List of ontolgy artifacts found in the document.
	Concepts []ConceptModel `json:"concepts,omitempty"`

	// List of ontolgy attribute value artifacts found in the document.
	AttributeValues []ConceptModel `json:"attributeValues,omitempty"`

	// List of ontology relations found in the document.
	Relations []RelationModel `json:"relations,omitempty"`

	Mesh []ConceptModel `json:"mesh,omitempty"`

	Text []ConceptModel `json:"text,omitempty"`
}

// UnmarshalDataModel constructs an instance of DataModel from the specified map.
func UnmarshalDataModel(m map[string]interface{}) (result *DataModel, err error) {
	obj := new(DataModel)
	obj.Concepts, err = UnmarshalConceptModelSliceAsProperty(m, "concepts")
	if err != nil {
		return
	}
	obj.AttributeValues, err = UnmarshalConceptModelSliceAsProperty(m, "attributeValues")
	if err != nil {
		return
	}
	obj.Relations, err = UnmarshalRelationModelSliceAsProperty(m, "relations")
	if err != nil {
		return
	}
	obj.Mesh, err = UnmarshalConceptModelSliceAsProperty(m, "mesh")
	if err != nil {
		return
	}
	obj.Text, err = UnmarshalConceptModelSliceAsProperty(m, "text")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalDataModelSlice unmarshals a slice of DataModel instances from the specified list of maps.
func UnmarshalDataModelSlice(s []interface{}) (slice []DataModel, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'DataModel'")
			return
		}
		obj, e := UnmarshalDataModel(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalDataModelAsProperty unmarshals an instance of DataModel that is stored as a property
// within the specified map.
func UnmarshalDataModelAsProperty(m map[string]interface{}, propertyName string) (result *DataModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'DataModel'", propertyName)
			return
		}
		result, err = UnmarshalDataModel(objMap)
	}
	return
}

// UnmarshalDataModelSliceAsProperty unmarshals a slice of DataModel instances that are stored as a property
// within the specified map.
func UnmarshalDataModelSliceAsProperty(m map[string]interface{}, propertyName string) (slice []DataModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'DataModel'", propertyName)
			return
		}
		slice, err = UnmarshalDataModelSlice(vSlice)
	}
	return
}

// EntryModel : Object representing a passage.
type EntryModel struct {
	// Unique identifier of passage.
	ID *string `json:"id,omitempty"`

	// Whether passage is a negated span.
	Negated *bool `json:"negated,omitempty"`

	// List of sentences within passage.
	Sentences []SentenceModel `json:"sentences,omitempty"`
}

// UnmarshalEntryModel constructs an instance of EntryModel from the specified map.
func UnmarshalEntryModel(m map[string]interface{}) (result *EntryModel, err error) {
	obj := new(EntryModel)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Negated, err = core.UnmarshalBool(m, "negated")
	if err != nil {
		return
	}
	obj.Sentences, err = UnmarshalSentenceModelSliceAsProperty(m, "sentences")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalEntryModelSlice unmarshals a slice of EntryModel instances from the specified list of maps.
func UnmarshalEntryModelSlice(s []interface{}) (slice []EntryModel, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'EntryModel'")
			return
		}
		obj, e := UnmarshalEntryModel(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalEntryModelAsProperty unmarshals an instance of EntryModel that is stored as a property
// within the specified map.
func UnmarshalEntryModelAsProperty(m map[string]interface{}, propertyName string) (result *EntryModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'EntryModel'", propertyName)
			return
		}
		result, err = UnmarshalEntryModel(objMap)
	}
	return
}

// UnmarshalEntryModelSliceAsProperty unmarshals a slice of EntryModel instances that are stored as a property
// within the specified map.
func UnmarshalEntryModelSliceAsProperty(m map[string]interface{}, propertyName string) (slice []EntryModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'EntryModel'", propertyName)
			return
		}
		slice, err = UnmarshalEntryModelSlice(vSlice)
	}
	return
}

// FieldOptions : Supported options for the field.
type FieldOptions struct {
	// List of supported options.
	Supports []string `json:"supports,omitempty"`
}

// UnmarshalFieldOptions constructs an instance of FieldOptions from the specified map.
func UnmarshalFieldOptions(m map[string]interface{}) (result *FieldOptions, err error) {
	obj := new(FieldOptions)
	obj.Supports, err = core.UnmarshalStringSlice(m, "supports")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalFieldOptionsSlice unmarshals a slice of FieldOptions instances from the specified list of maps.
func UnmarshalFieldOptionsSlice(s []interface{}) (slice []FieldOptions, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'FieldOptions'")
			return
		}
		obj, e := UnmarshalFieldOptions(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalFieldOptionsAsProperty unmarshals an instance of FieldOptions that is stored as a property
// within the specified map.
func UnmarshalFieldOptionsAsProperty(m map[string]interface{}, propertyName string) (result *FieldOptions, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'FieldOptions'", propertyName)
			return
		}
		result, err = UnmarshalFieldOptions(objMap)
	}
	return
}

// UnmarshalFieldOptionsSliceAsProperty unmarshals a slice of FieldOptions instances that are stored as a property
// within the specified map.
func UnmarshalFieldOptionsSliceAsProperty(m map[string]interface{}, propertyName string) (slice []FieldOptions, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'FieldOptions'", propertyName)
			return
		}
		slice, err = UnmarshalFieldOptionsSlice(vSlice)
	}
	return
}

// HistogramData : histogram data.
type HistogramData struct {
	// Date associated with result.
	Date *string `json:"date,omitempty"`

	// Number of documents for date range result.
	Hits *int64 `json:"hits,omitempty"`
}

// UnmarshalHistogramData constructs an instance of HistogramData from the specified map.
func UnmarshalHistogramData(m map[string]interface{}) (result *HistogramData, err error) {
	obj := new(HistogramData)
	obj.Date, err = core.UnmarshalString(m, "date")
	if err != nil {
		return
	}
	obj.Hits, err = core.UnmarshalInt64(m, "hits")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalHistogramDataSlice unmarshals a slice of HistogramData instances from the specified list of maps.
func UnmarshalHistogramDataSlice(s []interface{}) (slice []HistogramData, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'HistogramData'")
			return
		}
		obj, e := UnmarshalHistogramData(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalHistogramDataAsProperty unmarshals an instance of HistogramData that is stored as a property
// within the specified map.
func UnmarshalHistogramDataAsProperty(m map[string]interface{}, propertyName string) (result *HistogramData, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'HistogramData'", propertyName)
			return
		}
		result, err = UnmarshalHistogramData(objMap)
	}
	return
}

// UnmarshalHistogramDataSliceAsProperty unmarshals a slice of HistogramData instances that are stored as a property
// within the specified map.
func UnmarshalHistogramDataSliceAsProperty(m map[string]interface{}, propertyName string) (slice []HistogramData, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'HistogramData'", propertyName)
			return
		}
		slice, err = UnmarshalHistogramDataSlice(vSlice)
	}
	return
}

// HitCount : Corpus frequency of artifact.
type HitCount struct {
	// Corpus frequency of artifact.
	HitCount *int64 `json:"hitCount,omitempty"`
}

// UnmarshalHitCount constructs an instance of HitCount from the specified map.
func UnmarshalHitCount(m map[string]interface{}) (result *HitCount, err error) {
	obj := new(HitCount)
	obj.HitCount, err = core.UnmarshalInt64(m, "hitCount")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalHitCountSlice unmarshals a slice of HitCount instances from the specified list of maps.
func UnmarshalHitCountSlice(s []interface{}) (slice []HitCount, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'HitCount'")
			return
		}
		obj, e := UnmarshalHitCount(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalHitCountAsProperty unmarshals an instance of HitCount that is stored as a property
// within the specified map.
func UnmarshalHitCountAsProperty(m map[string]interface{}, propertyName string) (result *HitCount, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'HitCount'", propertyName)
			return
		}
		result, err = UnmarshalHitCount(objMap)
	}
	return
}

// UnmarshalHitCountSliceAsProperty unmarshals a slice of HitCount instances that are stored as a property
// within the specified map.
func UnmarshalHitCountSliceAsProperty(m map[string]interface{}, propertyName string) (slice []HitCount, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'HitCount'", propertyName)
			return
		}
		slice, err = UnmarshalHitCountSlice(vSlice)
	}
	return
}

// MatchEntry : Object representing a match entry.
type MatchEntry struct {
	// Whether match is a negated span.
	Negated *bool `json:"negated,omitempty"`

	// Relevancy score of the match.
	Score *float32 `json:"score,omitempty"`

	// List of sentences within the matched text.
	Sentences []SentenceModel `json:"sentences,omitempty"`

	// Unique identifier of the match.
	ID *string `json:"id,omitempty"`
}

// UnmarshalMatchEntry constructs an instance of MatchEntry from the specified map.
func UnmarshalMatchEntry(m map[string]interface{}) (result *MatchEntry, err error) {
	obj := new(MatchEntry)
	obj.Negated, err = core.UnmarshalBool(m, "negated")
	if err != nil {
		return
	}
	obj.Score, err = core.UnmarshalFloat32(m, "score")
	if err != nil {
		return
	}
	obj.Sentences, err = UnmarshalSentenceModelSliceAsProperty(m, "sentences")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalMatchEntrySlice unmarshals a slice of MatchEntry instances from the specified list of maps.
func UnmarshalMatchEntrySlice(s []interface{}) (slice []MatchEntry, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'MatchEntry'")
			return
		}
		obj, e := UnmarshalMatchEntry(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalMatchEntryAsProperty unmarshals an instance of MatchEntry that is stored as a property
// within the specified map.
func UnmarshalMatchEntryAsProperty(m map[string]interface{}, propertyName string) (result *MatchEntry, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'MatchEntry'", propertyName)
			return
		}
		result, err = UnmarshalMatchEntry(objMap)
	}
	return
}

// UnmarshalMatchEntrySliceAsProperty unmarshals a slice of MatchEntry instances that are stored as a property
// within the specified map.
func UnmarshalMatchEntrySliceAsProperty(m map[string]interface{}, propertyName string) (slice []MatchEntry, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'MatchEntry'", propertyName)
			return
		}
		slice, err = UnmarshalMatchEntrySlice(vSlice)
	}
	return
}

// MetadataModel : Model for document metadata.
type MetadataModel struct {
	// List of document fields in the corpus.
	Fields map[string]FieldOptions `json:"fields,omitempty"`

	// List of fields that where enriched.
	SectionFieldNames []string `json:"sectionFieldNames,omitempty"`

	// List of fields enriched with attributes.
	AttrSectionFieldNames []string `json:"attrSectionFieldNames,omitempty"`

	// List of fields enriched with attribute qualifiers.
	QualifierSectionFieldNames []string `json:"qualifierSectionFieldNames,omitempty"`

	// List of fields with MeSH annotations.
	MeshSectionFieldNames []string `json:"meshSectionFieldNames,omitempty"`

	FieldIndexMap map[string]string `json:"fieldIndexMap,omitempty"`
}

// UnmarshalMetadataModel constructs an instance of MetadataModel from the specified map.
func UnmarshalMetadataModel(m map[string]interface{}) (result *MetadataModel, err error) {
	obj := new(MetadataModel)
	obj.SectionFieldNames, err = core.UnmarshalStringSlice(m, "sectionFieldNames")
	if err != nil {
		return
	}
	obj.AttrSectionFieldNames, err = core.UnmarshalStringSlice(m, "attrSectionFieldNames")
	if err != nil {
		return
	}
	obj.QualifierSectionFieldNames, err = core.UnmarshalStringSlice(m, "qualifierSectionFieldNames")
	if err != nil {
		return
	}
	obj.MeshSectionFieldNames, err = core.UnmarshalStringSlice(m, "meshSectionFieldNames")
	if err != nil {
		return
	}
	var fieldOptionMap map[string]FieldOptions

	obj.Fields = fieldOptionMap
	result = obj
	return
}

// UnmarshalMetadataModelSlice unmarshals a slice of MetadataModel instances from the specified list of maps.
func UnmarshalMetadataModelSlice(s []interface{}) (slice []MetadataModel, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'MetadataModel'")
			return
		}
		obj, e := UnmarshalMetadataModel(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalMetadataModelAsProperty unmarshals an instance of MetadataModel that is stored as a property
// within the specified map.
func UnmarshalMetadataModelAsProperty(m map[string]interface{}, propertyName string) (result *MetadataModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'MetadataModel'", propertyName)
			return
		}
		result, err = UnmarshalMetadataModel(objMap)
	}
	return
}

// UnmarshalMetadataModelSliceAsProperty unmarshals a slice of MetadataModel instances that are stored as a property
// within the specified map.
func UnmarshalMetadataModelSliceAsProperty(m map[string]interface{}, propertyName string) (slice []MetadataModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'MetadataModel'", propertyName)
			return
		}
		slice, err = UnmarshalMetadataModelSlice(vSlice)
	}
	return
}

// Passage : Object representing a document passage.
type Passage struct {
	// Document section for passage.
	DocumentSection *string `json:"documentSection,omitempty"`

	Text *StringBuilder `json:"text,omitempty"`

	// Timestamp of passage in video transcript.
	Timestamp *int64 `json:"timestamp,omitempty"`

	// Preferred name for highlighted text span.
	PreferredName *string `json:"preferredName,omitempty"`
}

// UnmarshalPassage constructs an instance of Passage from the specified map.
func UnmarshalPassage(m map[string]interface{}) (result *Passage, err error) {
	obj := new(Passage)
	obj.DocumentSection, err = core.UnmarshalString(m, "documentSection")
	if err != nil {
		return
	}
	obj.Text, err = UnmarshalStringBuilderAsProperty(m, "text")
	if err != nil {
		return
	}
	obj.Timestamp, err = core.UnmarshalInt64(m, "timestamp")
	if err != nil {
		return
	}
	obj.PreferredName, err = core.UnmarshalString(m, "preferredName")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalPassageSlice unmarshals a slice of Passage instances from the specified list of maps.
func UnmarshalPassageSlice(s []interface{}) (slice []Passage, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'Passage'")
			return
		}
		obj, e := UnmarshalPassage(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalPassageAsProperty unmarshals an instance of Passage that is stored as a property
// within the specified map.
func UnmarshalPassageAsProperty(m map[string]interface{}, propertyName string) (result *Passage, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'Passage'", propertyName)
			return
		}
		result, err = UnmarshalPassage(objMap)
	}
	return
}

// UnmarshalPassageSliceAsProperty unmarshals a slice of Passage instances that are stored as a property
// within the specified map.
func UnmarshalPassageSliceAsProperty(m map[string]interface{}, propertyName string) (slice []Passage, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'Passage'", propertyName)
			return
		}
		slice, err = UnmarshalPassageSlice(vSlice)
	}
	return
}

// Qualifer : Object representing an artifact qualifier.
type Qualifer struct {
	// Unique identifier for attribute qualifier.
	ID *string `json:"id,omitempty"`

	// Name of attribute qualifier.
	Name *string `json:"name,omitempty"`
}

// UnmarshalQualifer constructs an instance of Qualifer from the specified map.
func UnmarshalQualifer(m map[string]interface{}) (result *Qualifer, err error) {
	obj := new(Qualifer)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalQualiferSlice unmarshals a slice of Qualifer instances from the specified list of maps.
func UnmarshalQualiferSlice(s []interface{}) (slice []Qualifer, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'Qualifer'")
			return
		}
		obj, e := UnmarshalQualifer(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalQualiferAsProperty unmarshals an instance of Qualifer that is stored as a property
// within the specified map.
func UnmarshalQualiferAsProperty(m map[string]interface{}, propertyName string) (result *Qualifer, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'Qualifer'", propertyName)
			return
		}
		result, err = UnmarshalQualifer(objMap)
	}
	return
}

// UnmarshalQualiferSliceAsProperty unmarshals a slice of Qualifer instances that are stored as a property
// within the specified map.
func UnmarshalQualiferSliceAsProperty(m map[string]interface{}, propertyName string) (slice []Qualifer, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'Qualifer'", propertyName)
			return
		}
		slice, err = UnmarshalQualiferSlice(vSlice)
	}
	return
}

// RangeModel : Object representing an attribute value range.
type RangeModel struct {
	// Operator assigned to attribute value.
	Operator *string `json:"operator,omitempty"`

	// Minimum value assigned to attribute value.
	Min *string `json:"min,omitempty"`

	// Maximum value assigned to attribute value.
	Max *string `json:"max,omitempty"`

	// Corpus frequency for attribute value.
	Count *int64 `json:"count,omitempty"`
}

// UnmarshalRangeModel constructs an instance of RangeModel from the specified map.
func UnmarshalRangeModel(m map[string]interface{}) (result *RangeModel, err error) {
	obj := new(RangeModel)
	obj.Operator, err = core.UnmarshalString(m, "operator")
	if err != nil {
		return
	}
	obj.Min, err = core.UnmarshalString(m, "min")
	if err != nil {
		return
	}
	obj.Max, err = core.UnmarshalString(m, "max")
	if err != nil {
		return
	}
	obj.Count, err = core.UnmarshalInt64(m, "count")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalRangeModelSlice unmarshals a slice of RangeModel instances from the specified list of maps.
func UnmarshalRangeModelSlice(s []interface{}) (slice []RangeModel, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'RangeModel'")
			return
		}
		obj, e := UnmarshalRangeModel(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalRangeModelAsProperty unmarshals an instance of RangeModel that is stored as a property
// within the specified map.
func UnmarshalRangeModelAsProperty(m map[string]interface{}, propertyName string) (result *RangeModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'RangeModel'", propertyName)
			return
		}
		result, err = UnmarshalRangeModel(objMap)
	}
	return
}

// UnmarshalRangeModelSliceAsProperty unmarshals a slice of RangeModel instances that are stored as a property
// within the specified map.
func UnmarshalRangeModelSliceAsProperty(m map[string]interface{}, propertyName string) (slice []RangeModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'RangeModel'", propertyName)
			return
		}
		slice, err = UnmarshalRangeModelSlice(vSlice)
	}
	return
}

// RankedDocument : Object representing a document search result.
type RankedDocument struct {
	// Document identifier.
	DocumentID *string `json:"documentId,omitempty"`

	// Document title.
	Title *string `json:"title,omitempty"`

	// Additional document fields.
	Metadata map[string][]string `json:"metadata,omitempty"`

	// Document section.
	SectionName *string `json:"sectionName,omitempty"`

	// Document section identifier.
	SectionID *string `json:"sectionId,omitempty"`

	// Document corpus.
	Corpus *string `json:"corpus,omitempty"`

	Links *RankedDocLinks `json:"links,omitempty"`

	Passages *PassagesModel `json:"passages,omitempty"`

	// Document annotations.
	Annotations map[string]AnnotationModel `json:"annotations,omitempty"`
}

// UnmarshalRankedDocument constructs an instance of RankedDocument from the specified map.
func UnmarshalRankedDocument(m map[string]interface{}) (result *RankedDocument, err error) {
	obj := new(RankedDocument)
	obj.DocumentID, err = core.UnmarshalString(m, "documentId")
	if err != nil {
		return
	}
	obj.Title, err = core.UnmarshalString(m, "title")
	if err != nil {
		return
	}
	obj.SectionName, err = core.UnmarshalString(m, "sectionName")
	if err != nil {
		return
	}
	obj.SectionID, err = core.UnmarshalString(m, "sectionId")
	if err != nil {
		return
	}
	obj.Corpus, err = core.UnmarshalString(m, "corpus")
	if err != nil {
		return
	}
	obj.Links, err = UnmarshalRankedDocLinksAsProperty(m, "links")
	if err != nil {
		return
	}
	obj.Passages, err = UnmarshalPassagesModelAsProperty(m, "passages")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalRankedDocumentSlice unmarshals a slice of RankedDocument instances from the specified list of maps.
func UnmarshalRankedDocumentSlice(s []interface{}) (slice []RankedDocument, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'RankedDocument'")
			return
		}
		obj, e := UnmarshalRankedDocument(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalRankedDocumentAsProperty unmarshals an instance of RankedDocument that is stored as a property
// within the specified map.
func UnmarshalRankedDocumentAsProperty(m map[string]interface{}, propertyName string) (result *RankedDocument, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'RankedDocument'", propertyName)
			return
		}
		result, err = UnmarshalRankedDocument(objMap)
	}
	return
}

// UnmarshalRankedDocumentSliceAsProperty unmarshals a slice of RankedDocument instances that are stored as a property
// within the specified map.
func UnmarshalRankedDocumentSliceAsProperty(m map[string]interface{}, propertyName string) (slice []RankedDocument, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'RankedDocument'", propertyName)
			return
		}
		slice, err = UnmarshalRankedDocumentSlice(vSlice)
	}
	return
}

// RelatedConceptModel : Model for concept ontology relation.
type RelatedConceptModel struct {
	// Ontology provided unique identifier for artifact.
	Cui *string `json:"cui,omitempty"`

	// Source ontology for artifact.
	Ontology *string `json:"ontology,omitempty"`

	// Ontology provided normalized name for artifact.
	PreferredName *string `json:"preferredName,omitempty"`

	// Ontology provided alternative name for artifact.
	AlternativeName *string `json:"alternativeName,omitempty"`

	// Ontology semantic type for artifact.
	SemanticType *string `json:"semanticType,omitempty"`

	// Search weight assigned to artifact.
	Rank *int64 `json:"rank,omitempty"`

	// Number of corpus documents artifact was found in.
	HitCount *int64 `json:"hitCount,omitempty"`

	// Relevance score for artifact.
	Score *float32 `json:"score,omitempty"`

	// List of artifact synonyms.
	SurfaceForms []string `json:"surfaceForms,omitempty"`

	// List of artifacts for the relation.
	NextConcepts []RelatedConceptModel `json:"nextConcepts,omitempty"`
}

// UnmarshalRelatedConceptModel constructs an instance of RelatedConceptModel from the specified map.
func UnmarshalRelatedConceptModel(m map[string]interface{}) (result *RelatedConceptModel, err error) {
	obj := new(RelatedConceptModel)
	obj.Cui, err = core.UnmarshalString(m, "cui")
	if err != nil {
		return
	}
	obj.Ontology, err = core.UnmarshalString(m, "ontology")
	if err != nil {
		return
	}
	obj.PreferredName, err = core.UnmarshalString(m, "preferredName")
	if err != nil {
		return
	}
	obj.AlternativeName, err = core.UnmarshalString(m, "alternativeName")
	if err != nil {
		return
	}
	obj.SemanticType, err = core.UnmarshalString(m, "semanticType")
	if err != nil {
		return
	}
	obj.Rank, err = core.UnmarshalInt64(m, "rank")
	if err != nil {
		return
	}
	obj.HitCount, err = core.UnmarshalInt64(m, "hitCount")
	if err != nil {
		return
	}
	obj.Score, err = core.UnmarshalFloat32(m, "score")
	if err != nil {
		return
	}
	obj.SurfaceForms, err = core.UnmarshalStringSlice(m, "surfaceForms")
	if err != nil {
		return
	}
	obj.NextConcepts, err = UnmarshalRelatedConceptModelSliceAsProperty(m, "nextConcepts")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalRelatedConceptModelSlice unmarshals a slice of RelatedConceptModel instances from the specified list of maps.
func UnmarshalRelatedConceptModelSlice(s []interface{}) (slice []RelatedConceptModel, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'RelatedConceptModel'")
			return
		}
		obj, e := UnmarshalRelatedConceptModel(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalRelatedConceptModelAsProperty unmarshals an instance of RelatedConceptModel that is stored as a property
// within the specified map.
func UnmarshalRelatedConceptModelAsProperty(m map[string]interface{}, propertyName string) (result *RelatedConceptModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'RelatedConceptModel'", propertyName)
			return
		}
		result, err = UnmarshalRelatedConceptModel(objMap)
	}
	return
}

// UnmarshalRelatedConceptModelSliceAsProperty unmarshals a slice of RelatedConceptModel instances that are stored as a property
// within the specified map.
func UnmarshalRelatedConceptModelSliceAsProperty(m map[string]interface{}, propertyName string) (slice []RelatedConceptModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'RelatedConceptModel'", propertyName)
			return
		}
		slice, err = UnmarshalRelatedConceptModelSlice(vSlice)
	}
	return
}

// RelatedConceptsModel : Model for concept ontology relations.
type RelatedConceptsModel struct {
	// List of artifacts for the relation.
	Concepts []RelatedConceptModel `json:"concepts,omitempty"`
}

// UnmarshalRelatedConceptsModel constructs an instance of RelatedConceptsModel from the specified map.
func UnmarshalRelatedConceptsModel(m map[string]interface{}) (result *RelatedConceptsModel, err error) {
	obj := new(RelatedConceptsModel)
	obj.Concepts, err = UnmarshalRelatedConceptModelSliceAsProperty(m, "concepts")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalRelatedConceptsModelSlice unmarshals a slice of RelatedConceptsModel instances from the specified list of maps.
func UnmarshalRelatedConceptsModelSlice(s []interface{}) (slice []RelatedConceptsModel, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'RelatedConceptsModel'")
			return
		}
		obj, e := UnmarshalRelatedConceptsModel(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalRelatedConceptsModelAsProperty unmarshals an instance of RelatedConceptsModel that is stored as a property
// within the specified map.
func UnmarshalRelatedConceptsModelAsProperty(m map[string]interface{}, propertyName string) (result *RelatedConceptsModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'RelatedConceptsModel'", propertyName)
			return
		}
		result, err = UnmarshalRelatedConceptsModel(objMap)
	}
	return
}

// UnmarshalRelatedConceptsModelSliceAsProperty unmarshals a slice of RelatedConceptsModel instances that are stored as a property
// within the specified map.
func UnmarshalRelatedConceptsModelSliceAsProperty(m map[string]interface{}, propertyName string) (slice []RelatedConceptsModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'RelatedConceptsModel'", propertyName)
			return
		}
		slice, err = UnmarshalRelatedConceptsModelSlice(vSlice)
	}
	return
}

// RelationModel : Object representing an ontology relation.
type RelationModel struct {
	// Relation unique identifier artifact is associated with.
	RelationID *string `json:"relationId,omitempty"`

	// Name of the realtion an artifact is associated with.
	Relation *string `json:"relation,omitempty"`

	// Objeft representing a document text span.
	Source *TextSpan `json:"source,omitempty"`

	// Objeft representing a document text span.
	Target *TextSpan `json:"target,omitempty"`
}

// UnmarshalRelationModel constructs an instance of RelationModel from the specified map.
func UnmarshalRelationModel(m map[string]interface{}) (result *RelationModel, err error) {
	obj := new(RelationModel)
	obj.RelationID, err = core.UnmarshalString(m, "relationId")
	if err != nil {
		return
	}
	obj.Relation, err = core.UnmarshalString(m, "relation")
	if err != nil {
		return
	}
	obj.Source, err = UnmarshalTextSpanAsProperty(m, "source")
	if err != nil {
		return
	}
	obj.Target, err = UnmarshalTextSpanAsProperty(m, "target")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalRelationModelSlice unmarshals a slice of RelationModel instances from the specified list of maps.
func UnmarshalRelationModelSlice(s []interface{}) (slice []RelationModel, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'RelationModel'")
			return
		}
		obj, e := UnmarshalRelationModel(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalRelationModelAsProperty unmarshals an instance of RelationModel that is stored as a property
// within the specified map.
func UnmarshalRelationModelAsProperty(m map[string]interface{}, propertyName string) (result *RelationModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'RelationModel'", propertyName)
			return
		}
		result, err = UnmarshalRelationModel(objMap)
	}
	return
}

// UnmarshalRelationModelSliceAsProperty unmarshals a slice of RelationModel instances that are stored as a property
// within the specified map.
func UnmarshalRelationModelSliceAsProperty(m map[string]interface{}, propertyName string) (slice []RelationModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'RelationModel'", propertyName)
			return
		}
		slice, err = UnmarshalRelationModelSlice(vSlice)
	}
	return
}

// SearchMatchesModel : Object representing a corpus search match.
type SearchMatchesModel struct {
	// Unique identifier for matched document in corpus.
	ExternalID *string `json:"externalId,omitempty"`

	// Unique identifier for matched document in corpus.
	DocumentID *string `json:"documentId,omitempty"`

	// Unique identifier for matched document parent in corpus.
	ParentDocumentID *string `json:"parentDocumentId,omitempty"`

	// Publication name for matched document in corpus.
	PublicationName *string `json:"publicationName,omitempty"`

	// Publication date for matched document in corpus.
	PublicationDate *string `json:"publicationDate,omitempty"`

	// Publication URL for matched document in corpus.
	PublicationURL *string `json:"publicationURL,omitempty"`

	// Authors of matched document in corpus.
	Authors []string `json:"authors,omitempty"`

	// Title of matched document in corpus.
	Title *string `json:"title,omitempty"`

	// Usage license for matched document in corpus.
	MedlineLicense *string `json:"medlineLicense,omitempty"`

	// Pubmed link for matched document in corpus.
	HrefPubMed *string `json:"hrefPubMed,omitempty"`

	HrefPmc *string `json:"hrefPmc,omitempty"`

	HrefDoi *string `json:"hrefDoi,omitempty"`

	// Link to PDF for matched document in corpus.
	PdfURL *string `json:"pdfUrl,omitempty"`

	// Link to sourc origin for matched document in corpus.
	ReferenceURL *string `json:"referenceUrl,omitempty"`

	HighlightedTitle *StringBuilder `json:"highlightedTitle,omitempty"`

	HighlightedAbstract *StringBuilder `json:"highlightedAbstract,omitempty"`

	HighlightedBody *StringBuilder `json:"highlightedBody,omitempty"`

	// Matched document sections with annotation tags.
	HighlightedSections map[string]StringBuilder `json:"highlightedSections,omitempty"`

	// Matched document passages with annotation tags.
	Passages map[string]map[string]MatchEntry `json:"passages,omitempty"`

	// Matched document annotations.
	Annotations map[string]AnnotationModel `json:"annotations,omitempty"`
}

// UnmarshalSearchMatchesModel constructs an instance of SearchMatchesModel from the specified map.
func UnmarshalSearchMatchesModel(m map[string]interface{}) (result *SearchMatchesModel, err error) {
	obj := new(SearchMatchesModel)
	obj.ExternalID, err = core.UnmarshalString(m, "externalId")
	if err != nil {
		return
	}
	obj.DocumentID, err = core.UnmarshalString(m, "documentId")
	if err != nil {
		return
	}
	obj.ParentDocumentID, err = core.UnmarshalString(m, "parentDocumentId")
	if err != nil {
		return
	}
	obj.PublicationName, err = core.UnmarshalString(m, "publicationName")
	if err != nil {
		return
	}
	obj.PublicationDate, err = core.UnmarshalString(m, "publicationDate")
	if err != nil {
		return
	}
	obj.PublicationURL, err = core.UnmarshalString(m, "publicationURL")
	if err != nil {
		return
	}
	obj.Authors, err = core.UnmarshalStringSlice(m, "authors")
	if err != nil {
		return
	}
	obj.Title, err = core.UnmarshalString(m, "title")
	if err != nil {
		return
	}
	obj.MedlineLicense, err = core.UnmarshalString(m, "medlineLicense")
	if err != nil {
		return
	}
	obj.HrefPubMed, err = core.UnmarshalString(m, "hrefPubMed")
	if err != nil {
		return
	}
	obj.HrefPmc, err = core.UnmarshalString(m, "hrefPmc")
	if err != nil {
		return
	}
	obj.HrefDoi, err = core.UnmarshalString(m, "hrefDoi")
	if err != nil {
		return
	}
	obj.PdfURL, err = core.UnmarshalString(m, "pdfUrl")
	if err != nil {
		return
	}
	obj.ReferenceURL, err = core.UnmarshalString(m, "referenceUrl")
	if err != nil {
		return
	}
	obj.HighlightedTitle, err = UnmarshalStringBuilderAsProperty(m, "highlightedTitle")
	if err != nil {
		return
	}
	obj.HighlightedAbstract, err = UnmarshalStringBuilderAsProperty(m, "highlightedAbstract")
	if err != nil {
		return
	}
	obj.HighlightedBody, err = UnmarshalStringBuilderAsProperty(m, "highlightedBody")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSearchMatchesModelSlice unmarshals a slice of SearchMatchesModel instances from the specified list of maps.
func UnmarshalSearchMatchesModelSlice(s []interface{}) (slice []SearchMatchesModel, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SearchMatchesModel'")
			return
		}
		obj, e := UnmarshalSearchMatchesModel(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSearchMatchesModelAsProperty unmarshals an instance of SearchMatchesModel that is stored as a property
// within the specified map.
func UnmarshalSearchMatchesModelAsProperty(m map[string]interface{}, propertyName string) (result *SearchMatchesModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SearchMatchesModel'", propertyName)
			return
		}
		result, err = UnmarshalSearchMatchesModel(objMap)
	}
	return
}

// UnmarshalSearchMatchesModelSliceAsProperty unmarshals a slice of SearchMatchesModel instances that are stored as a property
// within the specified map.
func UnmarshalSearchMatchesModelSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SearchMatchesModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SearchMatchesModel'", propertyName)
			return
		}
		slice, err = UnmarshalSearchMatchesModelSlice(vSlice)
	}
	return
}

// SearchModel : Model for search criteria.
type SearchModel struct {
	// Link.
	Href *string `json:"href,omitempty"`

	// Page number.
	PageNumber *int64 `json:"pageNumber,omitempty"`

	// Search result limit.
	GetLimit *int64 `json:"get_limit,omitempty"`

	// Total number of search matches in the corpus.
	TotalDocumentCount *int64 `json:"totalDocumentCount,omitempty"`

	// Ontology artifact results from search.
	Concepts []Concept `json:"concepts,omitempty"`

	// Ontology semantic types.
	Types []string `json:"types,omitempty"`

	// Attribute artifact results from search.
	Attributes []Attribute `json:"attributes,omitempty"`

	// Attribute artifact value results from search.
	Values []Concept `json:"values,omitempty"`

	// Attribute value range results from search.
	Ranges map[string]RangeModel `json:"ranges,omitempty"`

	// Type-ahead suggestion results in search.
	Typeahead []Concept `json:"typeahead,omitempty"`

	// Aggregate result targets in search.
	Aggregations map[string][]AggregationModel `json:"aggregations,omitempty"`

	// Date range of results from search.
	DateHistograms map[string][]HistogramData `json:"dateHistograms,omitempty"`

	// Attribute qualifier results from search.
	Qualifiers []Qualifer `json:"qualifiers,omitempty"`

	// Object representing repository response.
	Backend *Backend `json:"backend,omitempty"`

	// Search expression that includes all levels of criteria expression.
	ExpandedQuery interface{} `json:"expandedQuery,omitempty"`

	// Object representingn boolean operands search criteria.
	ParsedBoolExpression *BooleanOperands `json:"parsedBoolExpression,omitempty"`

	// Whether ontolgoy artifacts were provided in search conditions.
	ConceptsExist map[string]int64 `json:"conceptsExist,omitempty"`

	CursorID *string `json:"cursorId,omitempty"`

	Vocabs []string `json:"vocabs,omitempty"`

	// Annotations returned for the document.
	Annotations map[string]CommonDataModel `json:"annotations,omitempty"`

	Metadata *MetadataFields `json:"metadata,omitempty"`

	// Documents returned from search.
	Documents []RankedDocument `json:"documents,omitempty"`

	SubQueries []SearchModel `json:"subQueries,omitempty"`
}

// UnmarshalSearchModel constructs an instance of SearchModel from the specified map.
func UnmarshalSearchModel(m map[string]interface{}) (result *SearchModel, err error) {
	obj := new(SearchModel)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.PageNumber, err = core.UnmarshalInt64(m, "pageNumber")
	if err != nil {
		return
	}
	obj.GetLimit, err = core.UnmarshalInt64(m, "get_limit")
	if err != nil {
		return
	}
	obj.TotalDocumentCount, err = core.UnmarshalInt64(m, "totalDocumentCount")
	if err != nil {
		return
	}
	obj.Concepts, err = UnmarshalConceptSliceAsProperty(m, "concepts")
	if err != nil {
		return
	}
	obj.Types, err = core.UnmarshalStringSlice(m, "types")
	if err != nil {
		return
	}
	obj.Attributes, err = UnmarshalAttributeSliceAsProperty(m, "attributes")
	if err != nil {
		return
	}
	obj.Values, err = UnmarshalConceptSliceAsProperty(m, "values")
	if err != nil {
		return
	}
	obj.Typeahead, err = UnmarshalConceptSliceAsProperty(m, "typeahead")
	if err != nil {
		return
	}
	obj.Qualifiers, err = UnmarshalQualiferSliceAsProperty(m, "qualifiers")
	if err != nil {
		return
	}
	obj.Backend, err = UnmarshalBackendAsProperty(m, "backend")
	if err != nil {
		return
	}
	obj.ExpandedQuery, err = core.UnmarshalAny(m, "expandedQuery")
	if err != nil {
		return
	}
	obj.ParsedBoolExpression, err = UnmarshalBooleanOperandsAsProperty(m, "parsedBoolExpression")
	if err != nil {
		return
	}
	obj.CursorID, err = core.UnmarshalString(m, "cursorId")
	if err != nil {
		return
	}
	obj.Vocabs, err = core.UnmarshalStringSlice(m, "vocabs")
	if err != nil {
		return
	}
	obj.Metadata, err = UnmarshalMetadataFieldsAsProperty(m, "metadata")
	if err != nil {
		return
	}
	obj.Documents, err = UnmarshalRankedDocumentSliceAsProperty(m, "documents")
	if err != nil {
		return
	}
	obj.SubQueries, err = UnmarshalSearchModelSliceAsProperty(m, "subQueries")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSearchModelSlice unmarshals a slice of SearchModel instances from the specified list of maps.
func UnmarshalSearchModelSlice(s []interface{}) (slice []SearchModel, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SearchModel'")
			return
		}
		obj, e := UnmarshalSearchModel(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSearchModelAsProperty unmarshals an instance of SearchModel that is stored as a property
// within the specified map.
func UnmarshalSearchModelAsProperty(m map[string]interface{}, propertyName string) (result *SearchModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SearchModel'", propertyName)
			return
		}
		result, err = UnmarshalSearchModel(objMap)
	}
	return
}

// UnmarshalSearchModelSliceAsProperty unmarshals a slice of SearchModel instances that are stored as a property
// within the specified map.
func UnmarshalSearchModelSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SearchModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SearchModel'", propertyName)
			return
		}
		slice, err = UnmarshalSearchModelSlice(vSlice)
	}
	return
}

// SentenceModel : Object representing a document sentence.
type SentenceModel struct {
	// Document section for sentence.
	DocumentSection *string `json:"documentSection,omitempty"`

	Text *StringBuilder `json:"text,omitempty"`

	// Starting sentence offset.
	Begin *int64 `json:"begin,omitempty"`

	// Ending sentence offset.
	End *int64 `json:"end,omitempty"`

	// Timestamp of sentence in video transcript.
	Timestamp *int64 `json:"timestamp,omitempty"`
}

// UnmarshalSentenceModel constructs an instance of SentenceModel from the specified map.
func UnmarshalSentenceModel(m map[string]interface{}) (result *SentenceModel, err error) {
	obj := new(SentenceModel)
	obj.DocumentSection, err = core.UnmarshalString(m, "documentSection")
	if err != nil {
		return
	}
	obj.Text, err = UnmarshalStringBuilderAsProperty(m, "text")
	if err != nil {
		return
	}
	obj.Begin, err = core.UnmarshalInt64(m, "begin")
	if err != nil {
		return
	}
	obj.End, err = core.UnmarshalInt64(m, "end")
	if err != nil {
		return
	}
	obj.Timestamp, err = core.UnmarshalInt64(m, "timestamp")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSentenceModelSlice unmarshals a slice of SentenceModel instances from the specified list of maps.
func UnmarshalSentenceModelSlice(s []interface{}) (slice []SentenceModel, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SentenceModel'")
			return
		}
		obj, e := UnmarshalSentenceModel(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSentenceModelAsProperty unmarshals an instance of SentenceModel that is stored as a property
// within the specified map.
func UnmarshalSentenceModelAsProperty(m map[string]interface{}, propertyName string) (result *SentenceModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SentenceModel'", propertyName)
			return
		}
		result, err = UnmarshalSentenceModel(objMap)
	}
	return
}

// UnmarshalSentenceModelSliceAsProperty unmarshals a slice of SentenceModel instances that are stored as a property
// within the specified map.
func UnmarshalSentenceModelSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SentenceModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SentenceModel'", propertyName)
			return
		}
		slice, err = UnmarshalSentenceModelSlice(vSlice)
	}
	return
}

// ServiceStatus : Object representing service runtime status.
type ServiceStatus struct {
	// scurrent service state.
	ServiceState *string `json:"serviceState,omitempty"`

	// service state details.
	StateDetails *string `json:"stateDetails,omitempty"`
}

// Constants associated with the ServiceStatus.ServiceState property.
// scurrent service state.
const (
	ServiceStatus_ServiceState_Error   = "ERROR"
	ServiceStatus_ServiceState_Ok      = "OK"
	ServiceStatus_ServiceState_Warning = "WARNING"
)

// UnmarshalServiceStatus constructs an instance of ServiceStatus from the specified map.
func UnmarshalServiceStatus(m map[string]interface{}) (result *ServiceStatus, err error) {
	obj := new(ServiceStatus)
	obj.ServiceState, err = core.UnmarshalString(m, "serviceState")
	if err != nil {
		return
	}
	obj.StateDetails, err = core.UnmarshalString(m, "stateDetails")
	if err != nil {
		return
	}

	result = obj
	return
}

// UnmarshalServiceStatusSlice unmarshals a slice of ServiceStatus instances from the specified list of maps.
func UnmarshalServiceStatusSlice(s []interface{}) (slice []ServiceStatus, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'ServiceStatus'")
			return
		}
		obj, e := UnmarshalServiceStatus(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalServiceStatusAsProperty unmarshals an instance of ServiceStatus that is stored as a property
// within the specified map.
func UnmarshalServiceStatusAsProperty(m map[string]interface{}, propertyName string) (result *ServiceStatus, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'ServiceStatus'", propertyName)
			return
		}
		result, err = UnmarshalServiceStatus(objMap)
	}
	return
}

// UnmarshalServiceStatusSliceAsProperty unmarshals a slice of ServiceStatus instances that are stored as a property
// within the specified map.
func UnmarshalServiceStatusSliceAsProperty(m map[string]interface{}, propertyName string) (slice []ServiceStatus, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'ServiceStatus'", propertyName)
			return
		}
		slice, err = UnmarshalServiceStatusSlice(vSlice)
	}
	return
}

// TextSpan : Objeft representing a document text span.
type TextSpan struct {
	// Document section where artifact was found.
	Section *string `json:"section,omitempty"`

	// Start of text span.
	Begin *int64 `json:"begin,omitempty"`

	// End of text span.
	End *int64 `json:"end,omitempty"`

	// Covered text span.
	CoveredText *string `json:"coveredText,omitempty"`

	// Documemnt provider.
	Source *string `json:"source,omitempty"`

	// Text span type.
	Type *string `json:"type,omitempty"`
}

// UnmarshalTextSpan constructs an instance of TextSpan from the specified map.
func UnmarshalTextSpan(m map[string]interface{}) (result *TextSpan, err error) {
	obj := new(TextSpan)
	obj.Section, err = core.UnmarshalString(m, "section")
	if err != nil {
		return
	}
	obj.Begin, err = core.UnmarshalInt64(m, "begin")
	if err != nil {
		return
	}
	obj.End, err = core.UnmarshalInt64(m, "end")
	if err != nil {
		return
	}
	obj.CoveredText, err = core.UnmarshalString(m, "coveredText")
	if err != nil {
		return
	}
	obj.Source, err = core.UnmarshalString(m, "source")
	if err != nil {
		return
	}
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalTextSpanSlice unmarshals a slice of TextSpan instances from the specified list of maps.
func UnmarshalTextSpanSlice(s []interface{}) (slice []TextSpan, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'TextSpan'")
			return
		}
		obj, e := UnmarshalTextSpan(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalTextSpanAsProperty unmarshals an instance of TextSpan that is stored as a property
// within the specified map.
func UnmarshalTextSpanAsProperty(m map[string]interface{}, propertyName string) (result *TextSpan, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'TextSpan'", propertyName)
			return
		}
		result, err = UnmarshalTextSpan(objMap)
	}
	return
}

// UnmarshalTextSpanSliceAsProperty unmarshals a slice of TextSpan instances that are stored as a property
// within the specified map.
func UnmarshalTextSpanSliceAsProperty(m map[string]interface{}, propertyName string) (slice []TextSpan, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'TextSpan'", propertyName)
			return
		}
		slice, err = UnmarshalTextSpanSlice(vSlice)
	}
	return
}

// UnstructuredModel : Model representing unstructed text.
type UnstructuredModel struct {
	// Text of the document.
	Text *string `json:"text,omitempty"`

	// Model representing ontology artifacts.
	Data *DataModel `json:"data,omitempty"`
}

// UnmarshalUnstructuredModel constructs an instance of UnstructuredModel from the specified map.
func UnmarshalUnstructuredModel(m map[string]interface{}) (result *UnstructuredModel, err error) {
	obj := new(UnstructuredModel)
	obj.Text, err = core.UnmarshalString(m, "text")
	if err != nil {
		return
	}
	obj.Data, err = UnmarshalDataModelAsProperty(m, "data")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalUnstructuredModelSlice unmarshals a slice of UnstructuredModel instances from the specified list of maps.
func UnmarshalUnstructuredModelSlice(s []interface{}) (slice []UnstructuredModel, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'UnstructuredModel'")
			return
		}
		obj, e := UnmarshalUnstructuredModel(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalUnstructuredModelAsProperty unmarshals an instance of UnstructuredModel that is stored as a property
// within the specified map.
func UnmarshalUnstructuredModelAsProperty(m map[string]interface{}, propertyName string) (result *UnstructuredModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'UnstructuredModel'", propertyName)
			return
		}
		result, err = UnmarshalUnstructuredModel(objMap)
	}
	return
}

// UnmarshalUnstructuredModelSliceAsProperty unmarshals a slice of UnstructuredModel instances that are stored as a property
// within the specified map.
func UnmarshalUnstructuredModelSliceAsProperty(m map[string]interface{}, propertyName string) (slice []UnstructuredModel, err error) {
	v, foundIt := m[propertyName]
	if foundIt && v != nil {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'UnstructuredModel'", propertyName)
			return
		}
		slice, err = UnmarshalUnstructuredModelSlice(vSlice)
	}
	return
}
